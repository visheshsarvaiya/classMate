import path from "path";
import { parentPort, workerData } from "worker_threads";
import { getExtensionModule } from "../../cli/util.js";
// this worker is used to load the latest version of the extension module.
// because esm doesn't allow clearing the require cache, this allows us to get the latest version of the extension module including any user code changes.
// previously we just appended a query param to the import, but that creates a memory leak where copies of the same module are loaded into memory over and over again and never garbage collected.
class ExtensionWorker {
    extensionModulePath;
    extensionDirectory;
    extension;
    constructor() {
        if (!parentPort) {
            throw new Error("No parent port. extensionWorker must be run in a worker thread.");
        }
        const { extensionPath } = workerData;
        if (!extensionPath) {
            throw new Error(`No extension path provided.`);
        }
        // [userdir]/.ntli/index.js
        this.extensionModulePath = extensionPath;
        // [userdir]/
        this.extensionDirectory = path.dirname(path.dirname(extensionPath));
        parentPort.on(`message`, async (message) => {
            const { type, id, payload } = message;
            if (!type) {
                throw new Error(`No message type provided.`);
            }
            if (!message.id) {
                throw new Error(`No message id provided.`);
            }
            if (type !== `loadModule` && !this.extension) {
                throw new Error(`Extension not loaded but ${type} message was received. The extension worker must be loaded before any other messages are sent.`);
            }
            if (type in this && this[type] && typeof this[type] === `function`) {
                try {
                    const result = await this[type](payload);
                    parentPort?.postMessage({
                        id,
                        result,
                    });
                }
                catch (e) {
                    console.error(e);
                    throw e;
                }
            }
            else {
                throw new Error(`Unknown message type: ${type}`);
            }
        });
    }
    async loadModule(directory) {
        try {
            const extension = await getExtensionModule(this.extensionModulePath, directory);
            this.extension = extension;
            return true;
        }
        catch (e) {
            console.error(e);
            return {
                failed: true,
                message: (e.stack ?? "") +
                    `\n\nextension path: ${this.extensionDirectory}`,
            };
        }
    }
    async hasConnector() {
        return !!this.extension?.netlifyConnectPlugin;
    }
    getConnectorConfig() {
        const config = this.extension?.netlifyConnectPlugin?.config || {};
        return {
            ...config,
            // these cannot be properly passed via postMessage to the parent process because they're not serializable
            initState: undefined,
            defineOptions: undefined,
        };
    }
}
new ExtensionWorker();
//# sourceMappingURL=worker.js.map