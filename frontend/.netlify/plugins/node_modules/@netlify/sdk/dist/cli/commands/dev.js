import readline from "readline";
import chalk from "chalk";
import open from "open";
import { createDevelopmentContentEngine } from "../index.js";
import { getExtensionBuildInfo, getExtensionModule, getSettings, updateSettings, } from "../util.js";
import { ntliLog, printResetHeader } from "../../utils.js";
import { build } from "./build.js";
export const dev = async ({ ...opts }) => {
    process.env.NODE_ENV = `development`;
    const buildApi = await build({
        ...opts,
        mode: "dev",
    });
    if (!buildApi) {
        throw new Error("No extension found");
    }
    const startEngine = opts.connector
        ? await handleConnector({ cwd: opts.cwd, opts })
        : false;
    if (buildApi.extension.netlifyConnectPlugin) {
        if (opts.connector && startEngine) {
            handleConnectorPlugin({ buildApi, startEngine });
        }
    }
};
export let connectorDevMode = getSettings()?.connectorDevMode || `clear cache on save`;
const handleConnectorPlugin = async ({ buildApi, startEngine, }) => {
    ntliLog("connector");
    const engine = await startEngine();
    handleConnectorKeypressListener({
        engine,
    });
    logMode();
    buildApi.onRebuild(async () => {
        // restart content engine with the new bundle.
        // the engine runs in a worker thread and
        // calling .restart() will kill the worker and
        // start a new one that uses the new bundle that was just built.
        ntliLog(`connector`);
        await engine.stop();
        if (connectorDevMode === `rebundle-only on save`) {
            engine.initialize().then(() => {
                logMode();
            });
        }
        else {
            engine
                .sync({
                runServer: true,
                clearCache: connectorDevMode === `clear cache on save`,
            })
                .then(() => {
                logMode();
            });
        }
    });
};
let connectorKeypressListenerAdded = false;
export const handleConnectorKeypressListener = ({ engine, }) => {
    if (!connectorKeypressListenerAdded) {
        connectorKeypressListenerAdded = true;
        readline.emitKeypressEvents(process.stdin);
        process.stdin?.setRawMode?.(true);
        const urls = {
            connect: `http://localhost:8000/__graphql`,
        };
        process.stdin.on("keypress", (_str, key) => {
            if (key.name === "o") {
                process.stdout.write(`\n`);
                ntliLog(`Opening ${urls.connect}`);
                // open( .. { wait: true } causes the open subprocess to hang around forever, creating a memory leak of about 20MB per code save..
                // seems to be related to https://github.com/sindresorhus/open/issues/197
                void open(urls.connect);
            }
            else if (key.name === "m") {
                if (connectorDevMode === `clear cache on save`) {
                    connectorDevMode = `data update on save`;
                }
                else if (connectorDevMode === `data update on save`) {
                    connectorDevMode = `rebundle-only on save`;
                }
                else if (connectorDevMode === `rebundle-only on save`) {
                    connectorDevMode = `clear cache on save`;
                }
                updateSettings({ connectorDevMode });
                console.log(getModeLog());
            }
            else if ((key.ctrl && key.name === "c") || key.name === "q") {
                process.exit(); // If user presses CTRL+C, exit the process
            }
            else if (key.name === "r") {
                printResetHeader();
                ntliLog(`connector`);
                engine
                    .restart({
                    runServer: true,
                    clearCache: connectorDevMode === `clear cache on save`,
                })
                    .then(() => {
                    logMode();
                });
            }
            else if (key.name === "s") {
                console.log("");
                ntliLog(`syncing connector`);
                engine.sync();
            }
        });
    }
};
const getModeLog = () => `${chalk.grey(`[m]`)} mode (${connectorDevMode === `clear cache on save`
    ? chalk.yellow(connectorDevMode)
    : connectorDevMode === `rebundle-only on save`
        ? chalk.blue(connectorDevMode)
        : chalk.green(connectorDevMode)})`;
const logMode = () => {
    console.log(chalk.blue(`Keys:`));
    console.log(getModeLog());
    console.log(`${chalk.grey(`[r]`)} restart process`);
    console.log(`${chalk.grey(`[s]`)} sync data\n`);
    console.log(chalk.blue(`Open:`));
    console.log(`${chalk.grey(`[o]`)} Netlify Connect API`);
};
const handleConnector = async ({ cwd, opts, }) => {
    const { builtPath } = await getExtensionBuildInfo({ cwd });
    const extension = await getExtensionModule(builtPath);
    if (extension) {
        return async () => {
            const { engine } = await createDevelopmentContentEngine({
                extension,
                cwd,
            });
            // do an initial sync of the built connector plugin
            const { exitCode } = await engine.sync({
                runServer: true, // with a GraphQL server for local dev
                clearCache: connectorDevMode === `clear cache on save`,
            });
            if (typeof exitCode !== `undefined`) {
                console.log(chalk.red(`Connector plugin exited with code ${exitCode}.`));
                if (opts.mode === "dev") {
                    console.log(chalk.green(`Save your code to restart the process.`));
                }
            }
            return engine;
        };
    }
    return false;
};
//# sourceMappingURL=dev.js.map