import { type JsonSchema7Type } from "zod-to-json-schema";
import type { TRPCProcedureType } from "@trpc/server";
import { NetlifyExtension } from "../index.js";
export declare const getExtensionModule: (builtPath: string, directory?: string) => Promise<NetlifyExtension<import("zod").ZodUnknown, import("zod").ZodUnknown, import("zod").ZodUnknown, import("zod").ZodUnknown, import("zod").ZodUnknown>>;
export declare const getExtensionBuildInfo: ({ cwd, outDirOveride, }: {
    cwd: string;
    outDirOveride?: string;
}) => Promise<{
    extensionPackageJson: any;
    sourceFilePath: string;
    builtPath: string;
    outDir: string;
    packageName: any;
}>;
type PackageJSON = {
    [key: string]: any;
    main?: string;
    dependencies?: {
        [key: string]: string;
    };
    devDependencies?: {
        [key: string]: string;
    };
    version: string;
};
export declare function getDepNames(packageJsonContents: PackageJSON): string[];
export declare function removeBundledDepsFromPackageJsonContents(packageJsonContents: PackageJSON, importedNodeModules?: Set<string>): PackageJSON;
export declare const getSettings: () => any;
export declare const updateSettings: (newSettings: Record<string, string | undefined>) => void;
export type ExtensionEndpointsSchema = {
    trpcUrl: string;
    trpcProcedures: TRPCProcedure[];
};
export type TRPCProcedure = {
    name: string;
    type: TRPCProcedureType;
    inputSchema: JsonSchema7Type | null;
};
/**
 * This function locates the file with the TRPC router and extracts the TRPC
 * endpoint by parsing the code using ts-morph. If the TRPC router was found,
 * it builds and loads the TRPC router, and extract TRPC procedures and their
 * input schema.
 */
export declare function getExtensionEndpointsSchema({ cwd, outDir, }: {
    cwd: string;
    outDir: string;
}): Promise<undefined | ExtensionEndpointsSchema>;
/**
 * Locates the file with TRPC router wrapped by createNetlifyTRPCHandler()
 * in user's code. Then it patches it such that the exported TRPC handler
 * function returns the parameters it receives and returns the path to the new
 * patched file.
 *
 * The patched file can be built and imported to compute the runtime values
 * passed to the createNetlifyTRPCHandler() function.
 *
 * For example, when the user uses SDK template or documentation, there
 * will be a "src/endpoints/trpc.ts" file with the following code (some parts
 * were redacted):
 *
 * ```js
 * import { createNetlifyTRPCHandler } from "@netlify/sdk/ui/functions/trpc";
 * import { appRouter } from "../server/router.js";
 *
 * const handler = createNetlifyTRPCHandler({
 *   endpoint: "/api/trpc",
 *   router: appRouter,
 * });
 *
 * export default handler;
 * ```
 *
 * The patched file will be:
 * ```js
 * import { createNetlifyTRPCHandler } from "@netlify/sdk/ui/functions/trpc";
 * import { appRouter } from "../server/router.js";
 *
 * function identityTRPCHandlerFunction(options) {
 *     return options;
 * }
 *
 * const handler = identityTRPCHandlerFunction({
 *   endpoint: "/api/trpc",
 *   router: appRouter,
 * });
 *
 * export default handler;
 * ```
 */
export declare function patchTRPCModule(functionsFolder: string): Promise<string | undefined>;
export {};
//# sourceMappingURL=util.d.ts.map