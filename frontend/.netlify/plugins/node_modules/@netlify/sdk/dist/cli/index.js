import fs from "node:fs/promises";
import path, { resolve, parse } from "node:path";
import { execSync } from "node:child_process";
import chalk from "chalk";
import pkg from "fs-extra";
import { outdent as javascript } from "outdent";
import { build as esbuild } from "esbuild";
import { getPackageVersion } from "../extension/package-version.js";
import { esbuildPluginSeenNodeModules, getDefaultEsbuildConfig, } from "./commands/build.js";
import { removeBundledDepsFromPackageJsonContents } from "./util.js";
const { ensureFile, ensureDir, copySync, copyFile, copyFileSync, writeFile, writeJSON, readdirSync, existsSync, readJSON, stat, } = pkg;
export { buildExtensionUI, } from "./build/build_extension_ui.js";
export { generateConnectPlugin, createDevelopmentContentEngine, } from "../extension/connect/cli.js";
export const generateBuildEventHandler = async (extension, config, opts) => {
    if (Object.values(extension.buildHooks).every((value) => !value)) {
        console.log(chalk.white("No build event handlers found."));
        return;
    }
    const { outDir, cwd } = opts;
    const extensionPackageJson = await readJSON(resolve(cwd, "package.json"));
    await ensureDir(resolve(outDir, "build"));
    const esbuildSeenModules = esbuildPluginSeenNodeModules();
    const esbuildOptions = {
        ...getDefaultEsbuildConfig(config),
        entryPoints: [resolve(outDir, "index.js")],
        bundle: true,
        format: "esm",
        platform: "node",
        outfile: resolve(outDir, "build/extension.js"),
        plugins: [esbuildSeenModules.plugin],
    };
    await esbuild(esbuildOptions);
    let exportedPluginCode = javascript `
    import { extension } from './extension.js';
    extension._slug = '${config.slug}';\n
    ${config.hostSiteId ? `extension._hostSiteId = '${config.hostSiteId}';\n` : ""}
  `;
    exportedPluginCode += javascript `
    export default function NetlifyExtension(_inputs, { netlifyConfig }) {
      return extension.getBuildEventHandlersToRun({ netlifyConfig });
    };`;
    const normalizedPackageJSON = removeBundledDepsFromPackageJsonContents(extensionPackageJson, esbuildSeenModules.nodeModulesImports);
    // generate random 5 character string
    const randomString = Math.random().toString(36).substring(2, 7);
    const version = `0.0.0-${randomString}`;
    const name = `${config.slug}-buildhooks`;
    // build any internal functions
    await buildInternalFunctions({
        config,
        extension,
        outDir,
        type: "function",
    });
    // build any internal edge functions
    await buildInternalFunctions({ config, extension, outDir, type: "edge" });
    if (existsSync(resolve(cwd, "assets"))) {
        copySync(resolve(cwd, "assets"), resolve(outDir, "build/assets"));
    }
    await writeFile(resolve(outDir, "build/index.js"), exportedPluginCode);
    await writeJSON(resolve(outDir, "build/package.json"), {
        main: "index.js",
        type: "module",
        version,
        name,
        dependencies: {
            ...normalizedPackageJSON.dependencies,
            "@netlify/sdk": getPackageVersion(),
        },
        devDependencies: {
            ...normalizedPackageJSON.devDependencies,
        },
    });
    await writeFile(resolve(outDir, "build/manifest.yml"), `name: ${name}`);
    execSync(`npm pack`, {
        cwd: resolve(outDir, "build"),
    });
    const packedFile = `${name
        .replaceAll("@", "")
        .replaceAll("/", "-")}-${version}.tgz`;
    await ensureDir(resolve(outDir, "site/static/packages"));
    copyFileSync(resolve(outDir, `build/${packedFile}`), resolve(outDir, "site/static/packages", "buildhooks.tgz"));
};
export const validateDetailsFile = async ({ src, }) => {
    try {
        await fs.access(src, fs.constants.R_OK);
        return { success: true };
    }
    catch (err) {
        return {
            success: false,
            error: new Error(`No \`details.md\` file exists at ${src}. Please create a \`details.md\` file and re-run this command.`, { cause: err }),
        };
    }
};
export const buildDetailsFile = async ({ dest, src, }) => {
    await fs.mkdir(path.dirname(dest), { recursive: true });
    await fs.cp(src, dest);
};
export const copySiteAssets = async ({ cwd, outDir, }) => {
    const assetsDir = resolve(cwd, "assets");
    const outAssetsDir = resolve(outDir, "site/static/ui/assets");
    await ensureDir(outAssetsDir);
    if (existsSync(assetsDir)) {
        console.log(chalk.white(`Copying assets from ${assetsDir} to ${outAssetsDir}...`));
        copySync(assetsDir, outAssetsDir);
        console.log(chalk.white(`Copied assets from ${assetsDir} to ${outAssetsDir}.`));
    }
};
export const processWrappers = async (wrappers, opts) => {
    if (!Object.keys(wrappers).length)
        return;
    const { outDir } = opts;
    console.log(chalk.white("Generating wrapper functions..."));
    const wrapperFile = resolve(outDir, "wrappers/index.js");
    await ensureFile(wrapperFile);
    await copyFile(resolve(outDir, "index.js"), resolve(outDir, "wrappers/extension.js"));
    let wrapperCode = javascript `import { extension } from './extension.js';\n\n`;
    Object.entries(wrappers).map(async ([key]) => {
        wrapperCode += javascript `export const ${key} = extension.wrappers['${key}'];\n`;
    });
    await writeFile(wrapperFile, wrapperCode);
};
const bundleEdgeFunction = (config) => async (srcPath, outPath) => {
    const esbuildOptions = {
        ...getDefaultEsbuildConfig(config),
        entryPoints: [srcPath],
        bundle: true,
        format: "esm",
        platform: "browser",
        outfile: outPath,
        plugins: [
            {
                name: "dependency-check",
                setup(build) {
                    build.onResolve({ filter: /.*/ }, (args) => {
                        // Check if the path is not a URL and not a relative path
                        if (!args.path.startsWith("http://") &&
                            !args.path.startsWith("https://") &&
                            !args.path.startsWith(".") &&
                            !args.path.startsWith("/")) {
                            throw new Error(`Invalid dependency found: ${args.path}. Edge Functions injected through extensions can only import local files, deno modules and npm modules with URL imports.`);
                        }
                        return null;
                    });
                },
            },
        ],
    };
    await esbuild(esbuildOptions);
};
const copyFunctionDirectory = async (source, target, bundleFunction) => {
    await ensureDir(target);
    const items = readdirSync(source, { withFileTypes: true });
    items.forEach(async (item) => {
        const srcPath = resolve(source, item.name);
        const targetPath = resolve(target, item.name);
        if (item.isDirectory()) {
            await copyFunctionDirectory(srcPath, targetPath, bundleFunction);
        }
        else {
            await bundleFunction(srcPath, targetPath);
        }
    });
};
const buildInternalFunctions = async ({ extension, outDir, type, config, }) => {
    const settings = type === "function"
        ? extension._functionsSettings
        : extension._edgeFunctionsSettings;
    if (settings) {
        const { path: internalFunctionsPath, prefix: internalFunctionsPrefix } = settings;
        if (internalFunctionsPath && internalFunctionsPrefix) {
            await ensureDir(internalFunctionsPath);
            const internalFunctions = await pkg.readdir(internalFunctionsPath);
            if (!internalFunctions || internalFunctions.length === 0) {
                throw new Error(`No internal ${type === "edge" ? "edge functions" : "functions"} found.`);
            }
            for (const fn of internalFunctions || []) {
                const newFilePath = resolve(outDir, type === "function" ? "build/functions" : "build/edge-functions", `${internalFunctionsPrefix}_${parse(fn).base}`);
                const oldFilePath = resolve(internalFunctionsPath, fn);
                try {
                    const stats = await stat(oldFilePath);
                    if (stats.isFile()) {
                        await ensureFile(newFilePath);
                        await bundleFunction(config)(oldFilePath, newFilePath);
                    }
                    else if (stats.isDirectory()) {
                        await copyFunctionDirectory(oldFilePath, newFilePath, type === "function"
                            ? bundleFunction(config)
                            : bundleEdgeFunction(config));
                    }
                }
                catch (err) {
                    console.error(err);
                }
            }
        }
    }
};
const bundleFunction = (config) => async (srcPath, outPath) => {
    const esbuildOptions = {
        ...getDefaultEsbuildConfig(config),
        entryPoints: [srcPath],
        bundle: true,
        format: "esm",
        platform: "node",
        outfile: outPath,
    };
    await esbuild(esbuildOptions);
};
//# sourceMappingURL=index.js.map