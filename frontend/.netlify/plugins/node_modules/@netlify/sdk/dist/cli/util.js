import { resolve, join, parse } from "path";
import os from "os";
import chalk from "chalk";
import fsExtraPkg from "fs-extra";
import { build as esbuild } from "esbuild";
import { zodToJsonSchema } from "zod-to-json-schema";
import { Project, SyntaxKind, } from "ts-morph";
const { existsSync, readJSON } = fsExtraPkg;
export const getExtensionModule = async (builtPath, directory = process.cwd()) => {
    try {
        const extensionModule = await import(builtPath);
        const { extension, integration } = extensionModule;
        if (!extension) {
            const { sourceFilePath } = await getExtensionBuildInfo({
                cwd: directory,
            });
            throw new Error(`Your extension must be a named export in your main TS file (at ${sourceFilePath}).

For example:

import { NetlifyExtension } from "@netlify/sdk";
const extension = new NetlifyExtension();

export { extension } // <-- this is required.

${integration ? `Found a deprecated "integration" export in this file. Please rename this export to "extension"` : ``}`);
        }
        return extension;
    }
    catch (e) {
        console.log(chalk.red("Could not load module"));
        if (e.message) {
            console.error(e.message);
        }
        throw e;
    }
};
export const getExtensionBuildInfo = async ({ cwd, outDirOveride, }) => {
    const extensionPackageJson = await readJSON(resolve(cwd, "package.json"));
    // main points to our entrypoint
    const { main } = extensionPackageJson;
    if (!main) {
        throw new Error(`${extensionPackageJson.name || `package`} must set a "main" property in package.json`);
    }
    const sourceFilePath = resolve(cwd, main);
    if (!existsSync(sourceFilePath)) {
        throw new Error(`${extensionPackageJson.name || `package`}'s main property in package.json points to a non-existing file`);
    }
    const outDir = outDirOveride || resolve(`${cwd}/.ntli`);
    const builtPath = `${outDir}/index.js`;
    const packageName = extensionPackageJson.name;
    return {
        extensionPackageJson,
        sourceFilePath,
        builtPath,
        outDir,
        packageName,
    };
};
export function getDepNames(packageJsonContents) {
    const deps = {
        ...(packageJsonContents.dependencies || {}),
        ...(packageJsonContents.devDependencies || {}),
    };
    return Object.keys(deps);
}
export function removeBundledDepsFromPackageJsonContents(packageJsonContents, importedNodeModules) {
    function removeExtraDeps(deps) {
        return Object.fromEntries(Object.entries(deps || {}).filter(([depName]) => {
            return (
            // if no imported modules list is provided, include all deps
            !importedNodeModules?.size ||
                // if it is, then only include the dep if it's been imported somewhere
                importedNodeModules.has(depName));
        }));
    }
    return {
        ...packageJsonContents,
        dependencies: removeExtraDeps(packageJsonContents.dependencies),
        devDependencies: removeExtraDeps(packageJsonContents.devDependencies),
    };
}
export const getSettings = () => {
    const settingsPath = `${os.homedir()}/.netlify/ntli.json`;
    if (!fsExtraPkg.existsSync(settingsPath)) {
        return {};
    }
    const settings = fsExtraPkg.readJSONSync(settingsPath);
    return settings;
};
export const updateSettings = (newSettings) => {
    const settingsPath = `${os.homedir()}/.netlify/ntli.json`;
    const settings = {
        ...(getSettings() || {}),
        ...newSettings,
    };
    fsExtraPkg.ensureFileSync(settingsPath);
    fsExtraPkg.writeJSONSync(settingsPath, settings);
};
/**
 * This function locates the file with the TRPC router and extracts the TRPC
 * endpoint by parsing the code using ts-morph. If the TRPC router was found,
 * it builds and loads the TRPC router, and extract TRPC procedures and their
 * input schema.
 */
export async function getExtensionEndpointsSchema({ cwd, outDir, }) {
    // TODO: read function's folder from netlify.toml
    const functionsFolder = resolve(cwd, "src/endpoints");
    const patchedRouterFilePath = await patchTRPCModule(functionsFolder);
    if (!patchedRouterFilePath) {
        return;
    }
    const trpcRouter = await loadTRPCRouterFromModule({
        patchedRouterFilePath,
        outDir,
    });
    if (!trpcRouter) {
        return undefined;
    }
    const trpcProcedures = getTRPCProcedures(trpcRouter.router);
    if (!trpcProcedures) {
        return undefined;
    }
    return {
        trpcUrl: trpcRouter.endpoint,
        trpcProcedures,
    };
}
/**
 * Locates the file with TRPC router wrapped by createNetlifyTRPCHandler()
 * in user's code. Then it patches it such that the exported TRPC handler
 * function returns the parameters it receives and returns the path to the new
 * patched file.
 *
 * The patched file can be built and imported to compute the runtime values
 * passed to the createNetlifyTRPCHandler() function.
 *
 * For example, when the user uses SDK template or documentation, there
 * will be a "src/endpoints/trpc.ts" file with the following code (some parts
 * were redacted):
 *
 * ```js
 * import { createNetlifyTRPCHandler } from "@netlify/sdk/ui/functions/trpc";
 * import { appRouter } from "../server/router.js";
 *
 * const handler = createNetlifyTRPCHandler({
 *   endpoint: "/api/trpc",
 *   router: appRouter,
 * });
 *
 * export default handler;
 * ```
 *
 * The patched file will be:
 * ```js
 * import { createNetlifyTRPCHandler } from "@netlify/sdk/ui/functions/trpc";
 * import { appRouter } from "../server/router.js";
 *
 * function identityTRPCHandlerFunction(options) {
 *     return options;
 * }
 *
 * const handler = identityTRPCHandlerFunction({
 *   endpoint: "/api/trpc",
 *   router: appRouter,
 * });
 *
 * export default handler;
 * ```
 */
export async function patchTRPCModule(functionsFolder) {
    const project = new Project();
    const fileGlob = resolve(functionsFolder, "**/*.ts");
    const patchFileName = "identityTRPCHandler";
    const patchedFileGlob = resolve(functionsFolder, `**/${patchFileName}.ts`);
    project.addSourceFilesAtPaths([fileGlob, "!" + patchedFileGlob]);
    const namedImport = findFirstNamedImportIdentifier(project, "createNetlifyTRPCHandler");
    if (!namedImport) {
        return undefined;
    }
    const sourceFilePath = namedImport.sourceFile.getFilePath();
    const nodeReferences = namedImport.identifier.findReferencesAsNodes();
    for (const nodeReference of nodeReferences) {
        const parent = nodeReference.getParent();
        // If the reference belongs to an ImportSpecifier, ignore it, as this is the
        // import that was used to find the other references.
        if (parent?.isKind(SyntaxKind.ImportSpecifier)) {
            continue;
        }
        // If the reference belongs to a function call, then add a new identity
        // function and replace the name of the referenced function to the name of
        // the new identity function:
        // function identityTRPCHandlerFunction(options) { return options; }
        if (parent?.isKind(SyntaxKind.CallExpression)) {
            nodeReference.replaceWithText("identityTRPCHandlerFunction");
            namedImport.sourceFile.addFunction({
                name: "identityTRPCHandlerFunction",
                parameters: [{ name: "options" }],
                statements: ["return options;"],
            });
            const pathObject = parse(sourceFilePath);
            const patchedFilePath = join(pathObject.dir, `${patchFileName}${pathObject.ext}`);
            await namedImport.sourceFile.copyImmediately(patchedFilePath, {
                overwrite: true,
            });
            return patchedFilePath;
        }
    }
    return undefined;
}
/**
 * Finds the source file containing the provided "importName", and the imported
 * identifier.
 *
 * For example, if the "src/endpoints/trpc.ts" file contains:
 * ```
 * import { createNetlifyTRPCHandler as aliasHandler } from "...";
 * ```
 *
 * This function returns:
 * ```
 * {
 *   identifier: <Identifier node for aliasHandler>,
 *   sourceFile: <SourceFile for src/endpoints/trpc.ts>
 * }
 * ```
 */
function findFirstNamedImportIdentifier(project, importName) {
    // Get any files from the function's folder (e.g., "src/endpoints")
    // Then, find a file that has a named import for "createNetlifyTRPCHandler"
    // and return the Identifier of the named import:
    // import { createNetlifyTRPCHandler } from "...";
    // import { createNetlifyTRPCHandler as aliasHandler } from "...";
    const sourceFiles = project.getSourceFiles();
    for (const sourceFile of sourceFiles) {
        const importDeclarations = sourceFile.getImportDeclarations();
        for (const importDeclaration of importDeclarations) {
            const namedImports = importDeclaration.getNamedImports();
            for (const namedImport of namedImports) {
                const nameNode = namedImport.getNameNode();
                const isIdentifier = nameNode.isKind(SyntaxKind.Identifier);
                if (isIdentifier && nameNode.getText() === importName) {
                    const aliasNode = namedImport.getAliasNode();
                    return {
                        sourceFile,
                        identifier: aliasNode ?? nameNode,
                    };
                }
            }
        }
    }
    return undefined;
}
async function loadTRPCRouterFromModule({ patchedRouterFilePath, outDir, }) {
    // Build and load the file with the TRPC router.
    const routerFileExists = await fsExtraPkg.pathExists(patchedRouterFilePath);
    if (!routerFileExists) {
        return undefined;
    }
    const outRouterFilePath = resolve(outDir, "identityTRPCHandler.js");
    await esbuild({
        bundle: true,
        format: "esm",
        platform: "node",
        entryPoints: [patchedRouterFilePath],
        outfile: outRouterFilePath,
    });
    const trpcFunctionModule = await import(outRouterFilePath);
    // Cleanup and delete the built TRPC router file.
    await fsExtraPkg.remove(outRouterFilePath);
    await fsExtraPkg.remove(patchedRouterFilePath);
    return {
        router: trpcFunctionModule.default.router,
        endpoint: trpcFunctionModule.default.endpoint,
    };
}
function getTRPCProcedures(trpcRouter) {
    const procedures = trpcRouter._def?.procedures;
    if (!procedures) {
        return undefined;
    }
    const trpcProcedures = [];
    for (const [name, value] of Object.entries(procedures)) {
        if (!("_def" in value) || !value._def.procedure) {
            continue;
        }
        const zodInput = value._def.inputs[0];
        const inputSchema = zodInput
            ? zodToJsonSchema(zodInput, { strictUnions: true })
            : null;
        trpcProcedures.push({
            name: name,
            type: value._def.type,
            inputSchema: inputSchema,
        });
    }
    if (!trpcProcedures.length) {
        return undefined;
    }
    return trpcProcedures;
}
//# sourceMappingURL=util.js.map