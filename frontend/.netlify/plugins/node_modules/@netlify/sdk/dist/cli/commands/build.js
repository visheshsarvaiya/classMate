import { existsSync, mkdirSync, writeFileSync } from "node:fs";
import fs from "node:fs/promises";
import path, { resolve, join, dirname } from "node:path";
import { build as esbuild, context, } from "esbuild";
import { copy } from "esbuild-plugin-copy";
import { ExtensionWorkerManager } from "../worker/manager.js";
import { buildDetailsFile, buildExtensionUI, generateBuildEventHandler, generateConnectPlugin, processWrappers, validateDetailsFile, copySiteAssets, } from "../index.js";
import { getExtensionBuildInfo, getExtensionModule, getDepNames, getExtensionEndpointsSchema, } from "../util.js";
import { resolveExtensionConfiguration, } from "../../extension_configuration/main.js";
import { ntliLog, printResetHeader } from "../../utils.js";
import { getPackageVersion } from "../../extension/package-version.js";
const __dirname = new URL(".", import.meta.url).pathname;
export const build = async (opts) => {
    const isPreview = !!opts.previewUrl;
    const config = await resolveExtensionConfiguration({ cwd: opts.cwd });
    const { outDir, builtPath, sourceFilePath, extensionPackageJson, packageName, } = await getExtensionBuildInfo({
        cwd: opts.cwd,
        outDirOveride: opts.outDir,
    });
    // remove dist folders
    await fs.rm(outDir, { recursive: true, force: true });
    if (opts.connector) {
        // we need to bundle this so it can be used in template files for Connect/Create that are not bundled, but are copied to the built extension
        await esbuild({
            bundle: true,
            format: "esm",
            platform: "node",
            entryPoints: [
                join(__dirname, "../../extension/connect/utils/instance-id.js"),
            ],
            outfile: join(dirname(builtPath), "/connector/instance-id.js"),
        });
    }
    // each function added to this array is invoked when the extension is rebundled
    const rebuildListeners = [];
    function onRebuild(listener) {
        rebuildListeners.push(listener);
    }
    const esbuildSeenModules = esbuildPluginSeenNodeModules();
    const esbuildOptions = {
        ...getDefaultEsbuildConfig(config),
        entryPoints: [sourceFilePath],
        bundle: true,
        format: "esm",
        platform: "node",
        outfile: builtPath,
        external: getDepNames(extensionPackageJson),
        sourcemap: "linked",
        plugins: [
            copy({
                assets: {
                    // resolved based on cwd
                    from: ["src/assets/**/*"],
                    // ^^ doesn't copy files/dirs starting with . for some reason
                    // adding "src/assets/.**/*" causes the copy plugin to throw errors.
                    // possibly due to changes in the new esbuild watch mode API.
                    // resolved based on outfile
                    to: ["assets"],
                    // watch assets for changes in watch mode
                    watch: opts.mode === "dev",
                },
                copyOnStart: true,
            }),
            copy({
                assets: {
                    from: ["./README.md"],
                    to: ["./README.md"],
                    watch: opts.mode === "dev",
                },
            }),
        ],
    };
    const extensionWorker = new ExtensionWorkerManager(builtPath);
    if (opts.mode === "dev") {
        const buildContext = await context({
            ...esbuildOptions,
            plugins: [
                ...(esbuildOptions.plugins || []),
                {
                    name: "rebuild-listener",
                    setup(build) {
                        let shouldNotifyRebuildListeners = false;
                        // sometimes esbuild immediately rebuilds twice on start,
                        setTimeout(() => 
                        // so only notify listeners if it's been more than 100ms since the build started
                        (shouldNotifyRebuildListeners = true), 1000);
                        let notifying = false;
                        build.onEnd(async () => {
                            if (notifying) {
                                return;
                            }
                            notifying = true;
                            if (shouldNotifyRebuildListeners) {
                                printResetHeader();
                                await extensionWorker.reload();
                                for (const listener of rebuildListeners) {
                                    await listener();
                                }
                            }
                            notifying = false;
                        });
                    },
                },
            ],
        });
        printResetHeader();
        await buildContext.rebuild();
        await buildContext.watch();
    }
    else {
        esbuildOptions.plugins ||= [];
        esbuildOptions.plugins.push(esbuildSeenModules.plugin); // only check for seen imported node modules for prod builds, not during local dev
        await esbuild(esbuildOptions);
    }
    const extension = await getExtensionModule(builtPath, opts.cwd);
    await extensionWorker.loadModule(opts.cwd);
    if (!extension) {
        return false;
    }
    if (opts.buildtime) {
        ntliLog("Generating build event handlers...");
        await generateBuildEventHandler(extension, { ...config, slug: isPreview ? "netlify-preview" : config.slug }, {
            cwd: opts.cwd,
            outDir,
        });
    }
    const version = getPackageVersion();
    const handlersToRun = extension.getBuildEventHandlersToRun({
        netlifyConfig: {},
    });
    const hasBuildEventHandler = Object.keys(handlersToRun).length > 0;
    let uiSurfaces = [];
    let hasExtensionUI = false;
    if (config.ui?.surfaces != undefined && config.ui.surfaces.length > 0) {
        // TODO(ndhoule): This is a fairly weak check. We should check to be sure the user has actually
        // emitted artifacts to the build directory defined at `netlify.toml#build.publish`. (We should
        // actually use @netlify/config)
        hasExtensionUI = true;
        uiSurfaces = [...config.ui.surfaces];
    }
    const supports = extension.netlifyConnectPlugin
        ? {
            connect: extension.netlifyConnectPlugin.supports.connect,
            // TODO: "supports.create" in the public API was renamed to "supports.visualEditor"
            // but this manifest system still expects "supports.create"
            // We should update the manifest system to expect "supports.visualEditor"
            create: extension.netlifyConnectPlugin.supports.visualEditor,
        }
        : undefined;
    const endpointsSchema = await getExtensionEndpointsSchema({
        cwd: opts.cwd,
        outDir,
    });
    // TODO(ndhoule): When in `ntli dev` mode, we should write the manifest in watch mode. To do this
    // reliably, we'll need to watch the `extension.yml` file for changes.
    const manifest = {
        sdkVersion: version,
        hasDataIntegration: !!extension.netlifyConnectPlugin,
        hasBuildEventHandler,
        hasIntegrationUI: hasExtensionUI,
        hasMCPContext: !!endpointsSchema,
        uiSurfaces,
        supports,
    };
    if (!existsSync(resolve(opts.cwd, ".ntli/site/static"))) {
        mkdirSync(resolve(opts.cwd, ".ntli/site/static"), { recursive: true });
    }
    writeFileSync(resolve(opts.cwd, ".ntli/site/static/manifest.json"), JSON.stringify(manifest, null, 2));
    if (endpointsSchema) {
        writeFileSync(resolve(opts.cwd, ".ntli/site/static/mcp-context.json"), JSON.stringify(endpointsSchema, null, 2));
    }
    if (extension.wrappers) {
        await processWrappers(extension.wrappers, {
            cwd: opts.cwd,
            outDir,
        });
    }
    if (opts.connector) {
        await generateConnectPlugin(extensionWorker, config, {
            cwd: opts.cwd,
            outDir,
            watchMode: opts.mode === "dev",
            importedNodeModules: esbuildSeenModules.nodeModulesImports,
        });
    }
    if (opts.site) {
        if (config.ui === undefined) {
            ntliLog("No Extension UI configuration found. Skipping UI build...");
        }
        else {
            // TODO(ndhoule): Move these constants into configuration
            const DETAILS_MD_SRC_DIR = opts.cwd;
            const DETAILS_MD_SRC_PATH = path.resolve(DETAILS_MD_SRC_DIR, "details.md");
            const DETAILS_MD_DEST_DIR = path.resolve(outDir, "site/static");
            const DETAILS_MD_DEST_PATH = path.resolve(DETAILS_MD_DEST_DIR, "details.md");
            ntliLog("Copying `details.md` to build...");
            const detailsFileValidationResult = await validateDetailsFile({
                src: DETAILS_MD_SRC_PATH,
            });
            if (!detailsFileValidationResult.success) {
                throw detailsFileValidationResult.error;
            }
            await buildDetailsFile({
                src: DETAILS_MD_SRC_PATH,
                dest: DETAILS_MD_DEST_PATH,
            });
            ntliLog("Copied `details.md` to build.");
            // TODO(ndhoule): This exists to allow users to reference images, etc. in their details.md file.
            // However, I think we'll need to revisit it for a few reasons:
            //
            // - We already support a `src/assets` directory, which supports connectors' Asset type. Having
            //   both `/assets` and `/src/assets` directories is super confusing.
            // - The `ntli` build process should not write to the `${outputDir}/site/static/ui` directory;
            //   that directory must be completely controlled by the UI build tool, which often chooses to
            //   truncate the output directory before building. (E.g. this is Vite's default behavior.)
            // - The UI build process can also place assets in the `ui` directory, and might create a
            //   `ui/assets` directory. (E.g. this is Vite's default behavior.)
            // - It's odd that we output the manifest to `${outputDir}/site/static` and this to `[...]/ui`?
            copySiteAssets({ cwd: opts.cwd, outDir });
            ntliLog(`Building Extension UI${opts.mode === "dev" ? " in watch mode" : ""}...`);
            const buildExtensionUIPromise = buildExtensionUI({
                stderr: process.stderr,
                stdout: process.stdout,
            }, {
                command: {
                    dev: config.ui?.dev?.command,
                },
                cwd: opts.cwd,
                outdir: outDir,
                mode: opts.mode,
                meta: {
                    name: config.name ?? "",
                    slug: config.slug,
                },
                open: opts.open,
                slug: opts.slug,
                redirect: opts.redirect,
            });
            if (opts.mode === "build") {
                // XXX(ndhoule): Sorry! This is a gross hack for the time being. `buildExtensionUI` only
                // resolves when the underlying command completes; in watch mode, it will run as long as
                // you're watching. The control flow in the rest of this function is not really amenable to
                // long-lived promises, though.
                //
                // (In the future, we should use an `AbortSignal` to cancel this long-running task and await
                // all the build steps in a `Promise.all()`.)
                await buildExtensionUIPromise;
            }
        }
    }
    if (opts.mode === "build") {
        ntliLog("Build complete!");
    }
    if (opts.connector && opts.mode === "dev") {
        onRebuild(async () => {
            generateConnectPlugin(extensionWorker, config, {
                cwd: opts.cwd,
                outDir,
                watchMode: opts.mode === "dev",
            });
        });
        if (extension.wrappers) {
            onRebuild(() => {
                processWrappers(extension.wrappers, {
                    cwd: opts.cwd,
                    outDir,
                });
            });
        }
    }
    if (opts.mode === "build") {
        extensionWorker.stop();
    }
    return {
        config,
        cwd: opts.cwd,
        extension,
        onRebuild,
        packageName,
        slug: config.slug,
    };
};
export function getDefaultEsbuildConfig(config) {
    if (config.use_cjs_shims) {
        return { inject: [join(__dirname, `../cjs-shim.js`)] };
    }
    return {};
}
export const esbuildPluginSeenNodeModules = () => {
    const moduleImports = new Set();
    return {
        nodeModulesImports: moduleImports,
        plugin: {
            name: "capture-node-modules-imports",
            setup(build) {
                build.onResolve({ filter: /.*/ }, (args) => {
                    // err on the side of including more rather than fewer deps.
                    // if an import isn't relative, add the path as a seen import
                    // we compare moduleImports against the actual package.json
                    // so if some extra imports are added as false positives it doesn't matter
                    const isNodeModuleImport = !args.path.startsWith(`.`) && !args.path.startsWith(`/`);
                    if (isNodeModuleImport) {
                        moduleImports.add(args.path); // Capture the node module import path
                    }
                    return {};
                });
                if (process.env.LOG_LEVEL === `DEBUG`) {
                    build.onEnd(() => {
                        console.log("Node module imports seen during bundling:", Array.from(moduleImports));
                    });
                }
            },
        },
    };
};
//# sourceMappingURL=build.js.map