import { createRequire } from "node:module";
import path from "node:path";
import process from "node:process";
import semver from "semver";
import chalk from "chalk";
// The range of officially supported Node versions.
// If you update this value, please update the supportedNodeVersionRange in packages/create-sdk/src/utils.ts to match.
const supportedNodeVersionRange = ">= 18.19.0";
const ignoreSupportedVersionError = process.env.NETLIFY_SDK_IGNORE_SUPPORTED_NODE_VERSION_RANGE === "true";
const currentFilePath = new URL(import.meta.url).pathname;
const isInSDKRepo = currentFilePath.includes(`/packages/sdk/dist/bin/index.js`) &&
    !currentFilePath.includes(`node_modules`);
export async function main() {
    if (!semver.satisfies(process.versions.node, supportedNodeVersionRange)) {
        console.error(chalk.red(`
ERROR: The Netlify SDK does not support the current Node version: ${process.versions.node}.
       The range of officially supported Node versions is ${supportedNodeVersionRange}.

       Please install a supported version of node and re-run the process.
      `.trim()));
        if (!ignoreSupportedVersionError) {
            process.exit(1);
        }
    }
    if (await attemptToUseCwdSDKPackage()) {
        return; // we switched to the local bin, don't run the rest of the code below
    }
    const { Command } = await import("@commander-js/extra-typings");
    const { build, dev, init } = await import("../cli/commands/index.js");
    const cwd = process.cwd();
    const program = new Command();
    program
        .command("init")
        .action(init)
        .option("-s, --slug <slug>", "The slug of the extension")
        .option("-d, --description <description>", "The description of the extension")
        .option("-p, --permissions <scopes>", "The permission scopes of the extension")
        .option("--surface <surface>", "The name of a UI surface the extension supports (repeatable)", (value, previous) => [...previous, value], []);
    const withBuildCommonFlags = (program) => {
        return program
            .option("-a, --all", "Build all components of the extension")
            .option("-c, --connector", "Build the Netlify Connect plugin of the extension")
            .option("-b, --buildtime", "Build the buildtime component of the extension")
            .option("-s, --site", "Build the serverless component of the extension");
    };
    withBuildCommonFlags(program.command("build")).action(async ({ all, buildtime, connector, site, ...opts }) => {
        await build({
            cwd,
            mode: "build",
            ...opts,
            ...normalizeBuildTargets({
                all,
                buildtime,
                connector,
                site,
            }),
        });
    });
    withBuildCommonFlags(program
        .command("dev")
        .option("-o, --open", "Open the extension UI local dev server preview in the Netlify UI")
        .option("--slug <slug>", "Override the extension slug to be used in the dev preview")
        .option("-r, --redirect <path>", "A path to redirect to after the Netlify UI dev preview opens")).action(async ({ all, buildtime, connector, site, ...opts }) => {
        if ((opts.slug || opts.redirect) && !opts.open) {
            opts.open = true;
        }
        await dev({
            cwd,
            mode: "dev",
            ...opts,
            ...normalizeBuildTargets({
                all,
                buildtime,
                connector,
                site,
            }),
        });
    });
    program.parse();
}
// this is wrapped conditionally so that when we require the SDK bin from the node_modules of the cwd, we don't immediately run its main function - that would cause infinite recursion of attempting to use the cwd sdk bin
if (!process.env.SDK_BIN_SWITCH_PATH) {
    main();
}
const normalizeBuildTargets = ({ all: _all, buildtime: _buildtime, connector: _connector, site: _site, }) => {
    let buildtime;
    let connector;
    let site;
    // If no build target is explicitly specified, default to all
    if (_all === undefined &&
        _buildtime === undefined &&
        _connector === undefined &&
        _site === undefined) {
        _all = true;
    }
    if (_all) {
        // If all = true, enable all build targets
        buildtime = true;
        connector = true;
        site = true;
    }
    else {
        // Otherwise, only build the specified targets
        buildtime = _buildtime === undefined ? false : _buildtime;
        connector = _connector === undefined ? false : _connector;
        site = _site === undefined ? false : _site;
    }
    return {
        buildtime,
        connector,
        site,
    };
};
async function attemptToUseCwdSDKPackage() {
    if (isInSDKRepo) {
        // if the currently running file is inside the sdk repo and not inside node_modules, we don't want to use the cwd sdk bin
        // this is so we can test our local changes to the SDK without this file switching over to the local bin in the cwd node_modules
        console.warn(`This CLI process is running from your local SDK repo. Using the SDK bin in ${currentFilePath}. Users should not see this message.`);
        return false;
    }
    try {
        // if this is already set, we've already switched to the cwd sdk bin and that bin is itself trying to switch to the cwd sdk bin,
        // so we should stop here to prevent infinite recursion - the fn that called this one will run its own logic when we return false here
        if (process.env.SDK_BIN_SWITCH_PATH) {
            return false;
        }
        const requirePath = path.join(process.cwd() +
            // without subdir it seems to want to resolve from the parent dir of cwd
            `/subdir`);
        const require = createRequire(requirePath);
        const localBinPath = require.resolve("@netlify/sdk/bin");
        if (!localBinPath) {
            return false;
        }
        process.env.SDK_BIN_SWITCH_PATH = localBinPath;
        // @ts-ignore - this import may or may not exist. If it doesn't, we'll catch the error and fall back to the global SDK
        const bin = await import(localBinPath);
        if (`main` in bin && typeof bin.main === `function`) {
            await bin.main();
            return true;
        }
        else {
            return false;
        }
    }
    catch (e) {
        console.log(``);
        e instanceof Error ? console.error(e.message) : console.error(e);
        console.log(``);
        console.warn(`Errored importing local @netlify/sdk module. Falling back to the globally installed bin. Upgrade your project to the latest version of @netlify/sdk to fix this error.\n`);
    }
    return false;
}
//# sourceMappingURL=index.js.map