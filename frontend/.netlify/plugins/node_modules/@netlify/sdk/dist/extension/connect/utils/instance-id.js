import { fastHash } from "./fast-hash.js";
// make an instance ID, used to share state between SDK/Create/Connect who each have an instance of a connector - each instance of the same connector can be looked up with this function
// xxh32 is a extremely fast non-crypto hashing algorithm - totally fine for our use case where we will generate a handful of hashes (one per connector instance - maybe 10 total in a process on the extreme end)
// it being fast means we can call it repeatedly without worrying about performance
// instance IDs are only unique within a single connector, they may clash between multiple connectors, but that's fine as the ID is only used to distinguish between two instances of the same connector
export const makeInstanceID = (options) => {
    const id = fastHash({
        ...options,
        // gatsby & content-engine add an empty plugins array while stackbit doesn't - unconditionally add it here to ensure the hash is the same
        plugins: [],
    });
    return id;
};
// tracks unique instance IDs, in the memory scope of the file that calls it
// makeInstanceID will be called for the same ID multiple times and that's expected,
// but we also need to be able to check if the same ID is created multiple times from a scope that should only initialize a connector instance 1 time
export const makeUniqueInstanceIDTracker = () => {
    const trackedUniqueInstanceIDs = new Set();
    function checkUnique(id) {
        if (trackedUniqueInstanceIDs.has(id)) {
            throw new Error(`Two connectors with the same instance ID ${id} have been initialized. You'll need to ensure multiple connector instances that are using the same connector package have unique plugin options. One way to achieve this is by setting a different typePrefix setting for each configured connector.`);
        }
        trackedUniqueInstanceIDs.add(id);
        setImmediate(() => {
            // we only need to track unique instances within this event loop tick
            // we're trying to catch two separate connectors being instantiated in a way that makes it impossible for the system to differentiate
            // without resetting we're tracking across the entire life of the current process - so if the same connector is reinstantiated (ie when saving stackbit.config.js)
            // we will get a false positive here.
            trackedUniqueInstanceIDs.clear();
        });
        return id;
    }
    return {
        checkUnique,
    };
};
//# sourceMappingURL=instance-id.js.map