import { ModelError } from "../error.js";
import { ModelTransformer, } from "../transformer.js";
export class CrossReferenceTransfromer extends ModelTransformer {
    /*
     * Connect/Create input data parsing (runs before data normalizers for each platform below)
     */
    parseVisitedInputList(input, field, treeContext) {
        const isNullable = field.list !== `required`;
        if (isNullable && !input) {
            return null;
        }
        const isArray = Array.isArray(input);
        const { path } = treeContext;
        // TODO: nope - not right. The walker class is looping through items and passing each one to this fn. All should be passed here instead of each one individually.
        // see same TODO in object transformer
        const isSingleListItem = path[path.length - 1].startsWith(`[`);
        if (!isArray && isSingleListItem) {
            return this.parseVisitedInputSingle(input);
        }
        if (!isArray) {
            throw new ModelError(`Input data for field ${field.name} is not an array but should be. Received ${typeof input}.\n\n${JSON.stringify(input, null, 2)}`);
        }
        return input.map((item) => this.parseVisitedInputSingle(item));
    }
    parseVisitedInputSingle(visited) {
        if (typeof visited !== "number" &&
            typeof visited !== "string" &&
            typeof visited !== `object`) {
            throw new ModelError(`Cross reference input values must always be strings, numbers, or objects, found ${typeof visited}`);
        }
        return visited;
    }
    /*
     * Connect schema definitions
     */
    toConnectDefinition() {
        const { definition } = this;
        let sdl = ``;
        if (definition.description) {
            sdl += `"""${definition.description}"""\n`;
        }
        const sharedCrossReferenceFields = `
  refId: ID!
  modelName: String! ${this.editorProxyFrom(`value.modelName`)}
  connectorName: String! ${this.editorProxyFrom(`refSrcType`)}
  instanceID: String! ${this.editorProxyFrom(`refProjectId`)}`;
        const typeName = definition.prefixedTypeName();
        const addUnresolvedTypesForDebuggingPurposes = [];
        switch (definition.crossReferenceTo.length > 1) {
            case true:
                // for cross references to more than one type, we need to create a union type
                return `${sdl}
type ${typeName} @dontInfer {${sharedCrossReferenceFields}
  reference: ${typeName}Union ${this.editorProxyFrom("value.reference")} @link
}

union ${typeName}Union = ${definition.crossReferenceTo
                    .map((to) => {
                    const { referenceTypePrefix } = definition.getGlobalCrossReference(to.connectorName, to.instanceID);
                    if (referenceTypePrefix === `Unresolved__`) {
                        addUnresolvedTypesForDebuggingPurposes.push(`type ${referenceTypePrefix}${to.modelName} @dontInfer { reference: String }`);
                    }
                    return referenceTypePrefix + to.modelName;
                })
                    .join(` | `)}
${addUnresolvedTypesForDebuggingPurposes.length > 0 ? `\n${addUnresolvedTypesForDebuggingPurposes.join(`\n`)}\n` : ``}`;
            case false: {
                const { referenceTypePrefix } = definition.getGlobalCrossReference(definition.crossReferenceTo[0].connectorName, definition.crossReferenceTo[0].instanceID);
                const crossReferenceTypeName = referenceTypePrefix + definition.crossReferenceTo[0].modelName;
                const addUnresolvedTypeForDebuggingPurposes = referenceTypePrefix === `Unresolved__`
                    ? `type ${crossReferenceTypeName} @dontInfer { reference: String }`
                    : ``;
                return `${sdl}
${addUnresolvedTypeForDebuggingPurposes ? `${addUnresolvedTypeForDebuggingPurposes}\n` : ``}
type ${typeName} @dontInfer${definition.getAuthorizationDirectiveSDL()} {${sharedCrossReferenceFields}
  reference: ${crossReferenceTypeName} ${this.editorProxyFrom(`value.reference`)} @link
}`;
            }
        }
    }
    toConnectSingleFieldDefinition(modelField) {
        // cross reference doesn't require any Create GraphQl proxy for single values
        return this.modelFieldToGraphQLFieldSDL(modelField);
    }
    toConnectListFieldDefinition(modelField) {
        return this.modelFieldToGraphQLFieldSDL(modelField, {
            proxyFrom: `items`,
        });
    }
    /*
     * Create schema definitions
     */
    toCreateDefinition() {
        return null; // Create already has global cross reference types
    }
    toCreateListFieldDefinition(field) {
        return {
            type: "list",
            ...this.modelFieldToSharedCreateProperties(field),
            items: {
                type: "cross-reference",
                models: this.crossReferenceValuesToEditorModelsProperty(),
            },
        };
    }
    toCreateSingleFieldDefinition(field) {
        return {
            type: "cross-reference",
            models: this.crossReferenceValuesToEditorModelsProperty(),
            ...this.modelFieldToSharedCreateProperties(field),
        };
    }
    crossReferenceValuesToEditorModelsProperty() {
        return this.definition.crossReferenceTo.map((to) => ({
            modelName: to.modelName,
            srcType: to.connectorName,
            srcProjectId: to.instanceID,
        }));
    }
    /*
     * Connect data normalizers
     */
    toConnectSingleFieldValue(input, _field, treeContext) {
        const isObject = typeof input === "object";
        const initialRefId = !isObject ? input : input?.reference;
        const value = this.getCrossReferenceFieldValues(input, treeContext.path);
        return {
            ...value,
            // Sometimes the input is a string or number, when it is we should use it as the refId,
            // Otherwise fallback to input id and finally the reference we made
            refId: initialRefId || value.reference,
        };
    }
    toConnectListFieldValue(modelFieldValue, field, treeContext) {
        const { path, visitorState } = treeContext;
        return modelFieldValue?.map?.((node, index) => {
            return field.type.ModelWalker.coerceModelValue(node, { ...field, list: false }, [...path, field.name, `[${index}]`], visitorState);
        });
    }
    /*
     * Create data normalizers
     */
    toCreateListFieldValue(modelFieldValue, field, treeContext) {
        const { path, visitorState } = treeContext;
        const listItems = modelFieldValue?.map?.((node, index) => {
            const fields = field.type.ModelWalker.coerceModelValue(node, { ...field, list: false }, [...path, field.name, `[${index}]`], visitorState);
            return fields;
        });
        return {
            type: `list`,
            items: listItems,
        };
    }
    toCreateSingleFieldValue(input, _field, treeContext) {
        const isObject = typeof input === "object";
        const initialRefId = !isObject ? input : input?.reference;
        const value = this.getCrossReferenceFieldValues(input, treeContext.path);
        return {
            // value is for content-engine to properly resolve the cross reference in GraphQL
            value,
            // the rest of these properties are for Netlify Create
            type: `cross-reference`,
            refType: input.type === `Asset` ? `asset` : `document`,
            // use value, not input as input may be a string or number, while value will have the correct properties
            refId: initialRefId,
            refSrcType: value.connectorName,
            refProjectId: value.instanceID,
        };
    }
    /*
     * Shared data normalizer utils
     */
    getCrossReferenceFieldValues(input, path) {
        const isSingleRefType = this.definition.crossReferenceTo.length === 1;
        // allow passing the refId directly when there's only one possible cross ref type.
        // normalize to expected object shape
        if (isSingleRefType &&
            (typeof input === `string` || typeof input === `number`)) {
            input = {
                reference: input,
            };
        }
        if (isSingleRefType) {
            input.instanceID ||= this.definition.crossReferenceTo[0].instanceID;
            input.connectorName ||= this.definition.crossReferenceTo[0].connectorName;
            input.modelName ||= this.definition.crossReferenceTo[0].modelName;
        }
        else {
            const missingFields = [`instanceID`, `connectorName`, `modelName`].filter((name) => !input[name]);
            // for cross references to multiple types, these fields are required as we don't know which type of the possible types the input value is
            if (missingFields.length) {
                throw new ModelError(`\nCross reference value at path "${path.join(`.`)}" is missing the following fields: \n\t${missingFields.join(`,\n\t`)}\n\nAll multi-type cross reference values must have these fields so that the cross reference can be resolved.`);
            }
        }
        const { createReferenceId, referenceTypePrefix } = this.definition.getGlobalCrossReference(input.connectorName, input.instanceID);
        return {
            ...input,
            reference: createReferenceId(input.reference, input.modelName),
            modelName: `${referenceTypePrefix}${input.modelName}`,
        };
    }
}
//# sourceMappingURL=cross-reference.js.map