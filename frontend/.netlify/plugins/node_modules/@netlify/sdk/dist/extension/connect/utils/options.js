import { z, ZodError, ZodSchema } from "zod";
import { fromZodError } from "zod-validation-error";
export class ConnectorOptionsSchema {
    defineSchema;
    builtSchema = null;
    constructor(schemaDefiner) {
        this.defineSchema = schemaDefiner;
    }
    buildSchema() {
        if (this.builtSchema) {
            return this.builtSchema;
        }
        try {
            const schema = this.defineSchema({ zod: z });
            if (schema instanceof Promise) {
                throw new Error(`extension.addConnector({ defineOptions: () => {} }) must return a zod schema synchronously. Async schema definers are not supported.`);
            }
            if (!(schema instanceof ZodSchema)) {
                throw new Error(`extension.addConnector({ defineOptions: () => ZodSchema }) must return a zod schema.`);
            }
            if (schema?._def?.typeName !== `ZodObject`) {
                throw new Error(`You must return a Zod object in your extension.addConnector({ defineOptions: () => {} }) implementation.
For example:
extension.addConnector({
  defineOptions: ({ zod }) => {
    return zod.object({ // <-- zod.object must be returned.
      foo: zod.string().meta({ label: 'Example field' })
    })
  }
})`);
            }
            const objectSchema = schema;
            if (objectSchema.shape.typePrefix) {
                throw new Error(`typePrefix is a reserved option name. This is set for you automatically and can't be defined by your Connector.`);
            }
            this.builtSchema = this.builtInOptionsSchema().merge(objectSchema);
            return this.builtSchema;
        }
        catch (e) {
            console.error(e);
            process.exit(1);
        }
    }
    builtInOptionsSchema() {
        return z.object({
            instanceID: z.string().optional().meta({
                label: `Instance ID`,
                helpText: `The ID of the project to sync data from. This is used for linking between connectors. It's optional as a project ID is generated if not provided.`,
            }),
            typePrefix: z
                .string()
                .regex(/^$|^[A-Z][A-Za-z0-9_]*$/, {
                message: `Type prefix must start with an uppercase letter and only consist of alphanumeric characters and underscores.`,
            })
                .optional()
                .meta({
                label: `Type prefix`,
                helpText: `The prefix to use for types synced from this data source. It must start with an uppercase letter and can only consist of alphanumeric characters and underscores. For example, **Product** becomes **{Prefix}Product**.`,
            }),
        });
    }
    validate(options, connectorSlug) {
        try {
            this.buildSchema().parse(options);
        }
        catch (e) {
            if (e instanceof ZodError) {
                console.info(`Provided options for connector "${connectorSlug}":`, JSON.stringify(options, null, 2));
                console.error(fromZodError(e, {
                    prefix: `Invalid options for connector "${connectorSlug}"`,
                    prefixSeparator: `:\n  `,
                    issueSeparator: `\n  `,
                }).message);
            }
            else {
                console.error(e);
            }
            process.exit(1);
        }
    }
}
//# sourceMappingURL=options.js.map