import * as CSITypes from "@stackbit/types";
import type { FieldInitialValueFunction, DocumentFieldPreview } from "@stackbit/types";
import { ConnectorSupports } from "../sdk.js";
import { ConfiguredNetlifyConnector, NodesApi } from "../connector-instance.js";
import { ModelWalker } from "./walker.js";
import { ModelBuilder } from "./builder.js";
import { ModelTransformer, RuntimePlatform } from "./transformer.js";
import DataLoader, { BatchLoadFn } from "dataloader";
export type ResolvedModelField = Omit<ModelField, "type"> & {
    originalName: string;
    type: ModelDefinition;
    isRootValue: boolean;
    runtime: boolean;
};
type LoadFunction = ({ source, parameters, options, }: {
    source: any;
    parameters: Record<string, any>;
    options: Record<string, any>;
    load: <T = any>(key: string | number) => Promise<T>;
}) => unknown | Promise<unknown>;
type DefineArgs = {
    name: string;
    description?: string | undefined;
    visitor?: Visitor | undefined;
};
export type VisualEditorSharedSettings = {
    fieldGroups?: FieldGroupItem[] | undefined;
    label?: string | undefined;
};
export type VisualEditorObjectSettings = VisualEditorSharedSettings & {
    preview?: DocumentFieldPreview | undefined;
};
export type VisualEditorDocumentSettings = VisualEditorSharedSettings & {
    preview?: CSITypes.DocumentPreview | undefined;
    /** @description flags a document model as a page type in Netlify Create **/
    isPage?: boolean | undefined;
    /** @description marks this document model as being a singleton type in the Netlify Create editor. This is useful for global, singleton models, which are typically used to affect globally-shared content on the site, such as settings, styles, and default SEO values. **/
    singleInstance?: boolean | undefined;
};
export type DefineObjectArgs = DefineArgs & ({
    /** @description experimental API. only use this if you know what you're doing */
    runtime?: false | undefined | null;
} | {
    /** @description experimental API. only use this if you know what you're doing */
    runtime: true;
    /** @description experimental API. only use this if you know what you're doing */
    loadOne: LoadFunction;
    /** @description experimental API. only use this if you know what you're doing */
    loadMany: false;
} | {
    /** @description experimental API. only use this if you know what you're doing */
    runtime: true;
    /** @description experimental API. only use this if you know what you're doing */
    loadOne: false;
    /** @description experimental API. only use this if you know what you're doing */
    loadMany: LoadFunction;
} | {
    /** @description experimental API. only use this if you know what you're doing */
    runtime: true;
    /** @description experimental API. only use this if you know what you're doing */
    loadOne: LoadFunction;
    /** @description experimental API. only use this if you know what you're doing */
    loadMany: LoadFunction;
}) & {
    /** @description experimental API. only use this if you know what you're doing */
    parameters?: ParamFields;
    /** @description experimental API. only use this if you know what you're doing */
    cacheKeyField?: string | undefined;
    /** @description experimental API. only use this if you know what you're doing */
    batchMany?: BatchLoadFn<string, any>;
    fields: ModelFields;
    editor?: VisualEditorObjectSettings | undefined;
};
export type DefineEnumArgs = DefineArgs & {
    values: string[] | {
        label: string;
        value: string;
    }[];
};
export type DefineNodeArgs = DefineArgs & {
    cacheFieldName?: string | undefined;
    fields: ModelFields;
};
/**
 * Defines a document type.
 */
export type DefineDocumentArgs = DefineArgs & {
    fields: ModelFields;
    cacheFieldName?: string | undefined;
    editor?: VisualEditorDocumentSettings | undefined;
    localized?: boolean | undefined;
};
export type DefineUnionArgs = DefineArgs & {
    types: (string | ModelDefinition)[];
};
type CrossReferenceTo = {
    /** @description the name of the model that this cross-reference is for **/
    modelName: string;
    /** @description the name of the connector that this cross-reference is for **/
    connectorName: string;
    /** @description the instance ID of the connector that this cross-reference is for **/
    instanceID: string;
    /** @description optionally link by a chosen field, uses id by default **/
    linkBy?: string;
};
export type DefineCrossReferenceArgs = DefineInlineArgs<DefineArgs> & {
    /** @description the model this cross-reference can point to **/
    to: CrossReferenceTo[] | CrossReferenceTo;
};
type DefineInlineArgs<T> = Omit<T, "name"> & {
    /** @description If provided, the name will be used as the prefix in the generated type name for the inline type **/
    name?: string | undefined;
};
export type DefineInlineUnionArgs = DefineInlineArgs<DefineUnionArgs>;
export type DefineInlineEnumArgs = DefineInlineArgs<DefineEnumArgs>;
export type DefineInlineObjectArgs = DefineInlineArgs<DefineObjectArgs>;
export type DefineKind = `Object` | `Union` | `Node` | `Enum` | `CrossReference` | `Scalar`;
export type ModelField = {
    name: string;
    type: string | ModelDefinition;
    required?: boolean | undefined;
    list?: boolean | `required` | undefined;
    description?: string | undefined;
    visitor?: FieldVisitor | undefined;
    /**
     * @description Used to resolve conflicts between internal and defined types. ex: Text/String/Boolean/etc.
     * @default "prefer-builtin"
     */
    kind?: `prefer-builtin` | `prefer-defined` | `defined` | `builtin` | undefined;
    localized?: boolean | undefined;
    editor?: VisualEditorFieldSettings | undefined;
    gql?: {
        hidden: boolean;
    };
};
export type VisualEditorFieldSettings = {
    hidden?: boolean | undefined;
    label?: string | undefined;
    readOnly?: boolean | undefined;
    /** @description sets the field group this field will show up in in the Netlify Create Editor **/
    group?: string | undefined;
    /** @description sets the initial value for this field in the Netlify Create editor **/
    initialValue?: FieldInitialValueFunction | undefined | unknown;
    /** @description configures the UI preview data for this field in the Netlify Create editor **/
    preview?: DocumentFieldPreview | undefined;
    controlType?: `slider` | `dropdown` | `button-group` | `checkbox` | `image` | `file` | undefined;
    numberOptions?: {
        min?: number | undefined;
        max?: number | undefined;
        step?: number | undefined;
        unit?: string | undefined;
    } | undefined;
    thumbnailOptions?: {
        label: string;
        thumbnail: string;
        value: string;
    }[] | undefined;
};
export interface FieldGroupItem {
    name: string;
    label: string;
    icon?: string | undefined;
}
export type ParamFields = ParamFieldsArray | ParamFieldsObject;
export type ParamFieldsArray = ParamField[];
export type ParamFieldsObject = {
    [name: string]: Omit<ParamField, "name">;
};
export type ParamField = ModelField;
export type ModelFieldsObject = {
    [name: string]: Omit<ModelField, `name`>;
};
export type ModelFieldsArray = ModelField[];
export type ModelFields = ModelFieldsArray | ModelFieldsObject;
export type RawNodeObject = {
    id?: string | undefined;
    [key: string]: any;
};
type VisitorValue = any;
export type Visitor = (value: VisitorValue, info: {
    visitorContext: any;
    setVisitorContext: (newContext: any) => any;
    fields: ModelWalker["fields"];
}) => VisitorValue;
export type FieldVisitor = (value: VisitorValue, info: ReturnType<ModelWalker["fieldInfoByName"]>) => VisitorValue;
export declare const builtInStackbitStringTypes: Set<string>;
export declare const builtInStackbitTypes: Set<string>;
export declare const builtInTypes: Set<string>;
export declare const mappedBuiltinTypes: Map<string, string>;
export declare const builtInScalars: Set<string>;
export type ModelDefinitionInput = {
    kind: DefineKind;
    ModelBuilder: ModelBuilder;
    TransformerClass: typeof ModelTransformer;
    nodesApi: NodesApi;
    createId: ConfiguredNetlifyConnector["createId"];
    createApi?: CSITypes.Cache | undefined;
    shouldAutoRenameFieldsAndModels: boolean;
    supports: ConnectorSupports;
    isInternalType: boolean;
    isInlineType?: boolean;
    isExtendedDefinition?: boolean;
    runtimePlatform: RuntimePlatform;
    parameters?: ParamFields;
} & Omit<DefineArgs, "name"> & {
    name?: string | undefined;
} & Partial<DefineNodeArgs & DefineObjectArgs & DefineUnionArgs & DefineDocumentArgs & DefineCrossReferenceArgs & DefineEnumArgs>;
export declare class ModelDefinition {
    compositeTypes?: (string | ModelDefinition)[];
    compositeTypesSet: Set<string>;
    description?: string;
    cacheFieldName?: string;
    cacheKeyField?: string;
    ModelWalker: ModelWalker;
    ModelTransformer: ModelTransformer;
    ModelBuilder: ModelBuilder;
    private createId;
    visitor?: Visitor;
    camelToOriginalNames: Map<string, string>;
    originalToCamelNames: Map<string, string>;
    fields: ModelField[];
    fieldsMap: Map<string, ModelField>;
    fieldGroups?: VisualEditorSharedSettings["fieldGroups"];
    localized?: boolean | undefined;
    runtime: boolean;
    loadOne?: LoadFunction;
    loadMany?: LoadFunction;
    dataLoader?: DataLoader<any, any>;
    parameters: ParamFieldsArray;
    values?: {
        label: string;
        value: string;
    }[];
    isMixedUnion: boolean;
    isNodeUnion: boolean;
    private definedKind;
    private typeName;
    originalName?: string;
    private nodesApi;
    private createApi?;
    label?: string;
    private shouldAutoRenameFieldsAndModels;
    private isExtendedDefinition;
    private _isInternalType;
    isPageType?: boolean;
    editorDocumentPreview?: CSITypes.DocumentPreview;
    editorObjectPreview?: CSITypes.DocumentFieldPreview;
    private authLabels?;
    fieldAuthLabels: {
        [fieldName: string]: string[];
    };
    crossReferenceTo: CrossReferenceTo[];
    isEditorSingleInstance?: boolean;
    private _isInlineType;
    constructor(input: ModelDefinitionInput);
    private hashInput;
    private getFieldHashValues;
    private getFieldsHashValues;
    get kind(): DefineKind;
    _mergeExtendedDefinition(extendedDefinition: ModelDefinition, modelBuilder: ModelBuilder): void;
    get hasFields(): boolean;
    getFields(): ModelField[];
    getTypeName(): string;
    getOriginalName(): string;
    get isInternalType(): boolean;
    get isInlineType(): boolean;
    get isNodeType(): boolean;
    get isObjectType(): boolean;
    get isUnionType(): boolean;
    get isEnumType(): boolean;
    get isScalarType(): boolean;
    get isCrossReferenceType(): boolean;
    getDefinedType(type: string | ModelDefinition, onBuilder?: ModelBuilder): ModelDefinition;
    getDefinedTypeName(type: string | ModelDefinition, fieldName?: string): string;
    prefixedTypeName(typeName?: string, field?: Partial<ModelField>): string;
    getFinalFieldName(fieldName: string, unionModelName?: string): string;
    toCreateModel(): CSITypes.ObjectModel | CSITypes.PageModel | CSITypes.DataModel | null;
    /**
     *
     * Introduced specifically to keep the casing of the richText simple type.
     * At the time of writing (March 7 2024) this is the only type with any camelcasing, the rest
     * can be safely lowercased.
     * TODO: move this to the richText transformer
     */
    getFormattedTypename(typename: string): CSITypes.Field["type"];
    private sdkFieldToStackbitField;
    sdkFieldsToStackbitFields(): CSITypes.Field[];
    invalidate: (id?: string | undefined) => void;
    get runtimeDataAPI(): {
        name: string;
        originalName: string;
        readonly fields: import("./walker.js").Fields | undefined;
        invalidate: (id?: string | undefined) => void;
    };
    get dataAPI(): {
        name: string;
        originalName: string;
        readonly fields: import("./walker.js").Fields | undefined;
        insert: (nodes?: RawNodeObject[] | RawNodeObject) => any;
        delete: (nodeIds: string[] | string) => void | void[];
        /** @deprecated - use insert() instead, which has identical behaviour to create() */
        create: typeof this.insert;
    };
    buildWalker(): void;
    private getScalarModelByName;
    parseNameToTransformer(typeName: string): ModelTransformer;
    parseTypeToModel(type: string | ModelDefinition): ModelDefinition;
    parseNameToModel(typeName: string, onBuilder?: ModelBuilder): ModelDefinition;
    getModelByDefinedType(type: ModelField["type"]): ModelDefinition | undefined;
    getModelByName(typeName: string, onBuilder?: ModelBuilder): ModelDefinition | undefined;
    hasField(fieldName: string): boolean;
    private get delete();
    private get insert();
    createNodeId(rawId: string): string;
    resolveModelField(field: ModelField, parentDefinition: ModelDefinition): ResolvedModelField;
    prepareNode(node: RawNodeObject): RawNodeObject;
    setIsMixedUnion(): void;
    setIsNodeUnion(): void;
    getGlobalCrossReference(connectorName: string, instanceID: string): {
        referenceTypePrefix: string;
        createReferenceId: (rawId: string, modelName: string) => string;
    };
    getAuthorizationDirectiveSDL(additionalAuthLabels?: string[]): string;
    getAuthorizationDirectiveForScalarFieldSDL(fieldName: string): string;
    /**
     * Converts a type into the GraphQL Schema language (SDL). It's called for every Model.
     */
    toSDL(): string;
    private containsIllegalChars;
    private getFieldsAsArray;
    private processInputDefinitionFields;
    private processInputDefinition;
    private validateFieldDefinition;
}
export {};
//# sourceMappingURL=definition.d.ts.map