import { omitByUndefined } from "../../utils/omit-by-undefined.js";
import { ModelError } from "../error.js";
import { ModelTransformer, } from "../transformer.js";
export class ObjectTransformer extends ModelTransformer {
    /*
     * Connect schema definitions
     */
    toConnectDefinition() {
        const { definition } = this;
        let sdl = ``;
        if (this.definition.description) {
            sdl += `"""${definition.description}"""\n`;
        }
        sdl += `type ${definition.prefixedTypeName()} @dontInfer${this.definition.getAuthorizationDirectiveSDL()}${this.definition.runtime ? ` @runtime` : ``} {\n`;
        sdl += this.toConnectFieldsDefinitionSDL();
        sdl += `}`;
        return sdl;
    }
    toConnectSingleFieldDefinition(field) {
        return this.modelFieldToGraphQLFieldSDL(field, {
            proxyFrom: `fields`,
        });
    }
    toConnectListFieldDefinition(field) {
        return this.modelFieldToGraphQLFieldSDL(field, {
            proxyFrom: `items.fields`,
        });
    }
    /*
     * Create schema definitions
     */
    toCreateDefinition() {
        const def = this.definition;
        if (
        // Inline types do not have global Create definitions, they're added as inline field definitions
        def.isInlineType ||
            // All current internal types already exist in Create
            def.isInternalType) {
            return null;
        }
        return omitByUndefined({
            name: def.getOriginalName(),
            label: def.label,
            description: def.description,
            fieldGroups: def.fieldGroups,
            singleInstance: def.isEditorSingleInstance,
            fields: def.sdkFieldsToStackbitFields(),
            type: `object`,
            preview: def.editorObjectPreview,
        });
    }
    toCreateListFieldDefinition(field) {
        return {
            type: "list",
            ...this.modelFieldToSharedCreateProperties(field),
            items: this.toFieldDefinitionProperties(field),
        };
    }
    toCreateSingleFieldDefinition(field) {
        return {
            ...this.modelFieldToSharedCreateProperties(field),
            ...this.toFieldDefinitionProperties(field),
        };
    }
    toFieldDefinitionProperties(field) {
        if (this.definition.isInlineType) {
            return omitByUndefined({
                type: "object",
                fieldGroups: this.definition.fieldGroups,
                preview: field.editor?.preview,
                // for inline types, redefine every field type in place
                fields: this.definition.sdkFieldsToStackbitFields(),
            });
        }
        return omitByUndefined({
            type: "model",
            fieldGroups: this.definition.fieldGroups,
            preview: field.editor?.preview,
            // otherwise reference the already existing object model by name
            models: [this.definition.getOriginalName()],
        });
    }
    /*
     * Connect/Create input data parsing (runs before data normalizers for each platform below)
     */
    parseVisitedInputList(input, field, treeContext) {
        const isNullable = field.list !== `required`;
        if (isNullable && !input) {
            return null;
        }
        if (!Array.isArray(input)) {
            return this.parseVisitedInputSingle(input, field, treeContext);
        }
        return input.map((item) => this.parseVisitedInputSingle(item, { ...field, list: false }, treeContext));
    }
    parseVisitedInputSingle(visited, field, treeContext) {
        if (typeof visited !== `object`) {
            if (field.runtime && typeof visited === `undefined`) {
                // runtime fields may be resolved later so we can't throw here.
                return null;
            }
            throw new ModelError(`Found ${typeof visited} value for ${treeContext.path.join(".")} but an object value of type "${this.definition.getTypeName()}" was expected.\n  Value: ${visited}`);
        }
        return this.removeObjectKeysThatHaveNoFieldWithThatName(visited);
    }
    /*
     * Connect data normalizers
     */
    toConnectListFieldValue(input, field, treeContext) {
        return input?.map?.((node, index) => {
            return field.type.ModelWalker.coerceModelValue(node, { ...field, list: false }, [...treeContext.path, `[${index}]`], treeContext.visitorState);
        });
    }
    toConnectSingleFieldValue(input, _field, treeContext) {
        return this.toInsertedObject(input, treeContext);
    }
    /*
     * Create data normalizers
     */
    toCreateListFieldValue(modelFieldValue, field, treeContext) {
        const { path, visitorState } = treeContext;
        const listItems = modelFieldValue?.map?.((node, index) => {
            const fields = field.type.ModelWalker.coerceModelValue(node, { ...field, list: false }, [...path, field.name, `[${index}]`], visitorState);
            return {
                type: `model`,
                modelName: field.type.getOriginalName(),
                fields: fields?.fields || fields,
            };
        });
        return {
            type: `list`,
            items: listItems,
        };
    }
    toCreateSingleFieldValue(input, _field, treeContext) {
        return {
            type: `model`,
            modelName: this.definition.getOriginalName(),
            fields: this.toInsertedObject(input, treeContext),
        };
    }
    toCreateSingleFieldValueLocalized(input, _coersionField, treeContext) {
        return {
            type: "model",
            localized: true,
            locales: this.convertObjectLocaleValues(input, (objectValue, locale) => {
                return {
                    locale,
                    modelName: this.definition.getOriginalName(),
                    fields: this.toInsertedObject(objectValue, treeContext),
                };
            }, treeContext),
        };
    }
    /*
     * Shared data normalization utils
     */
    toInsertedObject(modelValue, treeContext) {
        const valueIsScalar = typeof modelValue !== `object`;
        const coercedValue = valueIsScalar ? modelValue : { ...modelValue };
        const { definition } = this;
        const { path, visitorState } = treeContext;
        if (
        // coercing fields on a null model value will throw errors if one of the fields is required,
        // even if the parent model is not a required field - only check for fields if the modelValue is not null
        modelValue !== null &&
            definition.hasFields) {
            definition.ModelWalker.coerceFields(coercedValue, path, visitorState);
        }
        coercedValue.__typename = this.definition.prefixedTypeName();
        return coercedValue;
    }
    getCacheField(coercedValue) {
        switch (this.runtimePlatform) {
            case "netlify-create":
                return coercedValue?.value;
            case "netlify-connect":
                return coercedValue;
        }
    }
    getCacheValueForRuntimeObject(coercedValue) {
        if (!this.definition.runtime) {
            return null;
        }
        const { cacheFieldName } = this.definition;
        if (cacheFieldName) {
            return this.getCacheField(coercedValue[cacheFieldName]);
        }
        return (
        // Fallback to the updatedAt field.
        this.getCacheField(coercedValue?.updatedAt) ||
            // all falsey values aren't acceptable as cache values
            // always bust the cache if there's no cache key or GraphQL queries will not invalidate
            String(Math.random().toString()));
    }
}
//# sourceMappingURL=object.js.map