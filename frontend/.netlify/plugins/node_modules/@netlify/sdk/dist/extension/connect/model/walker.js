import { builtInScalars, } from "./definition.js";
import { ModelError } from "./error.js";
import { isTest, isLocalDev } from "./utils.js";
export class ModelWalker {
    definition;
    getModelByName;
    allowedFieldNames = new Set();
    constructor({ model, getModelByName, }) {
        this.definition = model;
        this.getModelByName = getModelByName;
    }
    build() {
        if (this.definition.isUnionType && this.definition.compositeTypes) {
            this.allowedFieldNames.add(`__typename`);
            for (const type of this.definition.compositeTypes) {
                const typeName = this.definition.getDefinedTypeName(type, this.definition.getTypeName());
                const typeModel = this.getModelByName(typeName);
                if (!typeModel && !builtInScalars.has(typeName)) {
                    throw new ModelError(`Could not find model for union type "${typeName}" in model "${this.definition.getTypeName()}"`);
                }
                if (typeModel) {
                    for (const { name } of typeModel.getFields()) {
                        this.allowedFieldNames.add(name);
                    }
                }
            }
        }
        for (const fieldDefinition of this.definition.getFields()) {
            const fieldName = fieldDefinition.name;
            const fieldTypeName = this.definition.getDefinedTypeName(fieldDefinition.type, fieldName);
            const isBuiltInType = builtInScalars.has(fieldTypeName);
            const fieldModel = this.getModelByName(fieldTypeName);
            if (!fieldModel && !isBuiltInType) {
                throw new ModelError(`Could not find model for field type "${fieldTypeName}" in model "${this.definition.getTypeName()}"`);
            }
            const unCameled = this.definition.camelToOriginalNames.get(fieldName);
            if (unCameled) {
                this.allowedFieldNames.add(unCameled);
            }
            this.allowedFieldNames.add(fieldName);
        }
    }
    fieldInfoByName(name, visitorState) {
        const definedField = this.definition.fieldsMap.get(name);
        if (!definedField) {
            throw new Error(`No defined field found for ${name}`);
        }
        const field = this.definition.resolveModelField(definedField, this.definition);
        const originalFieldName = this.definition.camelToOriginalNames.get(definedField.name) ||
            definedField.name;
        return {
            name: definedField.name,
            originalName: originalFieldName,
            typeName: field.type.getTypeName(),
            list: field.list || false,
            required: field.required || false,
            is: {
                scalar: field.type.isScalarType,
                node: field.type.isNodeType,
                union: field.type.isUnionType,
                object: field.type.isObjectType,
            },
            get fields() {
                return field.type.ModelWalker.fields;
            },
            get visitorContext() {
                return visitorState.context;
            },
            setVisitorContext(newValue) {
                visitorState.context = newValue;
            },
        };
    }
    get fields() {
        const fields = {};
        const modelFields = this.definition.getFields();
        if (!modelFields.length)
            return undefined;
        for (const field of modelFields) {
            // ID field is on all node types, don't send it to visitor field info as it's not a user-defined field
            if (field.name === `id` && this.definition.isNodeType)
                continue;
            fields[field.name] = this.fieldInfoByName(field.name, {
                context: null,
            });
        }
        return fields;
    }
    visitInputValue(
    // input value can be "any" because the connector author can input any data they want and use the visitor to structure it in the shape defined by their models
    inputValue, visitorState) {
        if (typeof this.definition.visitor !== `function`) {
            return inputValue;
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const walker = this;
        const visitorInfo = {
            setVisitorContext(newContext) {
                visitorState.context = newContext;
            },
            get fields() {
                return walker.fields;
            },
            get visitorContext() {
                return visitorState?.context;
            },
        };
        return this.definition.visitor(inputValue, visitorInfo);
    }
    transformModelValue({ modelValue, field, treeContext, }) {
        const transformer = this.definition.ModelTransformer;
        if (!transformer) {
            throw new Error(`ModelTransformer not found for model ${this.definition.getTypeName()} on field ${field.name}`);
        }
        const value = transformer.toOutputValue(modelValue, field, treeContext); // TODO: this is temporary to satisfy coerceModelValue
        return value;
    }
    coerceModelValue(modelValue, field, path = [], visitorState = { context: null }) {
        const model = field.type.isUnionType ? this.definition : field.type;
        const asWalker = model.ModelWalker;
        return asWalker.transformModelValue({
            modelValue,
            field: field,
            treeContext: {
                path,
                visitorState,
            },
        });
    }
    coerceFields(coercedValue, path, visitorState) {
        for (const definedField of this.definition.getFields()) {
            const field = this.definition.resolveModelField(definedField, this.definition);
            const shouldRenameStoredField = this.definition.ModelBuilder.shouldAutoRenameFieldsAndModels &&
                this.definition.ModelBuilder.runtimePlatform !== `netlify-create`;
            if (shouldRenameStoredField &&
                field.name !== field.originalName &&
                typeof coercedValue[field.originalName] !== `undefined`) {
                coercedValue[field.name] = coercedValue[field.originalName];
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete coercedValue[field.originalName];
            }
            // In Connect any renamed fields are stored as their renamed version
            // In visual editor fields are stored in original format and there's a GraphQL proxy from the renamed field to the original stored one
            const storedFieldName = shouldRenameStoredField
                ? field.name // <- potentially renamed
                : field.originalName; // <- original CMS fieldname
            if (field.visitor) {
                if (
                // if the field is localized
                field.localized &&
                    // and the field is an object with localized keys
                    !field.type.ModelTransformer.inputNeedsDefaultLocalization(coercedValue[storedFieldName])) {
                    // run the field visitor on each locale
                    coercedValue[storedFieldName] =
                        this.definition.ModelTransformer.convertObjectLocaleValues(coercedValue[storedFieldName], (fieldValue) => {
                            return field.visitor?.(fieldValue, this.fieldInfoByName(field.name, visitorState));
                        }, {
                            path,
                            visitorState,
                        });
                }
                else {
                    coercedValue[storedFieldName] = field.visitor(coercedValue[storedFieldName], this.fieldInfoByName(field.name, visitorState));
                }
            }
            const fieldTypename = field.type.getTypeName();
            if ((isLocalDev || isTest) &&
                // if the field is not defined as localized: true
                !field.localized &&
                // for unstructured data there's no way to tell if it's already localized or not, it can have any fields.
                // don't run this check for json/richtext
                fieldTypename !== `JSON` &&
                fieldTypename !== `richText` &&
                // but the field data appears to be localized - ie the input data is an object with locales as keys
                !field.type.ModelTransformer.inputNeedsDefaultLocalization(coercedValue[storedFieldName])) {
                // error because if we silently allow this, the GraphQL API will be broken. Each localized field must have localized: true
                // so that we will add the @localized(codes:x) directive to it, signaling to the server how to resolve localized field data.
                // without this, the gql API will show cryptic errors about resolving the wrong shape for the type of the field.
                throw new ModelError(`Input data for field "${this.definition.getTypeName()}.${field.name}" appears to be localized, but this field is not defined as localized in this connector.

Example:

define.${this.definition.isObjectType ? "object" : "document"}({ 
  name: "${this.definition.getTypeName()}",
  fields: {
    ${field.name}: {
      // ...
      localized: true  <-- this is required but missing
    }
  }
})`);
            }
            coercedValue[storedFieldName] =
                field.type.ModelWalker.transformModelValue({
                    field,
                    modelValue: coercedValue[storedFieldName],
                    treeContext: {
                        path,
                        visitorState,
                    },
                });
        }
    }
}
//# sourceMappingURL=walker.js.map