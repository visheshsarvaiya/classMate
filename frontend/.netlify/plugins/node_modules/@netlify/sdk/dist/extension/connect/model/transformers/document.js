import { omitByUndefined } from "../../utils/omit-by-undefined.js";
import { ModelError } from "../error.js";
import { ModelTransformer, } from "../transformer.js";
import { isLocalDev, isTest } from "../utils.js";
export class DocumentTransformer extends ModelTransformer {
    /*
     * Connect/Create input data parsing (runs before data normalizers for each platform below)
     */
    parseVisitedInputList(input, field, treeContext) {
        const isNullable = field.list !== `required`;
        if (isNullable && !input) {
            return null;
        }
        if (!Array.isArray(input)) {
            throw new ModelError(`Input data for field ${field.name} is not an array but should be. Received ${typeof input}.\n\n${JSON.stringify(input, null, 2)}`);
        }
        return input.map((item, index) => {
            return this.parseVisitedInputSingle(item, field, {
                path: [...treeContext.path, `[${index}]`],
                visitorState: treeContext.visitorState,
            });
        });
    }
    parseVisitedInputSingle(visited, field, treeContext) {
        if (field.isRootValue) {
            if (typeof visited !== `object`) {
                throw new ModelError(`Found ${typeof visited} value for ${treeContext.path.join(".")} but an object value was expected.`);
            }
            if ((isLocalDev || isTest) &&
                visited._locale &&
                !this.definition.localized) {
                throw new ModelError(`Document of type ${this.definition.getTypeName()} was inserted with a _locale field, but this document type is not localized. Please set "localized: true" on the "${this.definition.getTypeName()}" document model definition.`);
            }
            if (!visited._createdAt && this.runtimePlatform === `netlify-create`) {
                throw new ModelError(`Inserted document is missing a "${this.definition.getTypeName()}._createdAt" field value. Connectors must include a _createdAt value on every inserted document.`);
            }
            return this.removeObjectKeysThatHaveNoFieldWithThatName(visited);
        }
        else {
            return this.parseRelationshipField(visited, field, treeContext);
        }
    }
    parseRelationshipField(input, field, treeContext) {
        const inputIsStringOrNumber = typeof input === `string` || typeof input === `number`;
        const rawId = inputIsStringOrNumber ? input : (input?.id ?? input);
        if (!rawId && !field.required)
            return null;
        const rawIdIsStringOrNumber = typeof rawId === "string" || typeof rawId === "number";
        if (!rawIdIsStringOrNumber && field.list) {
            // TODO: this error looks gnarly and needs to be re-used between multiple places - we should abstract this and clean up the error
            throw new ModelError(`The value at input path "${treeContext.path.join(`.`)}.id" is not a valid node id, but is required to be, as it's a relationship to the "${this.definition.getTypeName()}" document model.\nReceived: ${JSON.stringify(rawId, null, 4)}`);
        }
        else if (!rawIdIsStringOrNumber) {
            throw new ModelError(`Invalid "${this.definition.getTypeName()}" input object: ${JSON.stringify(rawId, null, 4)?.replace?.(`    "${field.name}": `, `-->"${field.name}": `)}\n\nThe value at input path "${treeContext.path.join(`.`)}" is not a valid node id string.`);
        }
        return rawId;
    }
    /*
     * Connect schema definitions
     */
    toConnectDefinition() {
        const { definition } = this;
        let sdl = ``;
        if (this.definition.description) {
            sdl += `"""${definition.description}"""\n`;
        }
        sdl += `type ${definition.prefixedTypeName(undefined, {
            // explicitly use the defined type in case of conflicts. IE if there's a document type called Color, we want the internal type to be prefixed like ConnectorPrefixColor - without passing this it will use the builtin Color (since there's no field here.)
            kind: "defined",
        })} implements Node @dontInfer${this.definition.getAuthorizationDirectiveSDL()} {\n`;
        sdl += this.toConnectFieldsDefinitionSDL();
        sdl += `}`;
        return sdl;
    }
    toConnectSingleFieldDefinition(modelField) {
        return this.modelFieldToGraphQLFieldSDL(modelField, {
            proxyFrom: `_connectId`,
            linkFrom: `id`,
        });
    }
    toConnectListFieldDefinition(modelField) {
        return this.modelFieldToGraphQLFieldSDL(modelField, {
            proxyFrom: `items._connectId`,
            linkFrom: `id`,
        });
    }
    /*
     * Create schema definitions
     */
    toCreateDefinition() {
        const { definition: def } = this;
        if (
        // Inline types do not have global Create definitions, they're added as inline field definitions
        def.isInlineType ||
            // All current internal types already exist in Create
            def.isInternalType) {
            return null;
        }
        return omitByUndefined({
            name: def.getOriginalName(),
            label: def.label,
            description: def.description,
            fieldGroups: def.fieldGroups,
            singleInstance: def.isEditorSingleInstance,
            fields: def.sdkFieldsToStackbitFields(),
            type: def.isPageType ? `page` : `data`,
            preview: def.editorDocumentPreview,
            localized: def.localized,
        });
    }
    toCreateListFieldDefinition(field) {
        if (this.definition.getTypeName() === `Asset`) {
            return {
                type: `list`,
                ...this.modelFieldToSharedCreateProperties(field),
                items: {
                    type: this.getAssetEditorType(field),
                },
            };
        }
        return omitByUndefined({
            type: `list`,
            items: omitByUndefined({
                type: "reference",
                models: [this.definition.getOriginalName()],
            }),
            ...this.modelFieldToSharedCreateProperties(field),
        });
    }
    toCreateSingleFieldDefinition(field) {
        if (this.definition.getTypeName() === `Asset`) {
            return {
                type: this.getAssetEditorType(field),
                ...this.modelFieldToSharedCreateProperties(field),
            };
        }
        return omitByUndefined({
            type: "reference",
            models: [this.definition.getOriginalName()],
            ...this.modelFieldToSharedCreateProperties(field),
        });
    }
    getAssetEditorType(field) {
        // control types that don't exist in stackbit are used in the SDK to differentiate
        // between an SDK Asset that becomes an image or file field in stackbit
        return field.editor?.controlType === `image` ? `image` : `file`;
    }
    /*
     * Connect data normalizers
     */
    toConnectSingleFieldValue(input, field, treeContext) {
        if (field.isRootValue) {
            return this.toInsertedDocument(input, treeContext);
        }
        else {
            const rawId = input?.id || input;
            const id = this.definition.createNodeId(rawId);
            const typename = this.definition.prefixedTypeName(undefined, field);
            return {
                id,
                internal: {
                    type: typename,
                },
                __typename: typename,
            };
        }
    }
    toConnectListFieldValue(modelFieldValue, field) {
        return modelFieldValue?.map?.((modelFieldValueListItem) => {
            const typename = this.definition.prefixedTypeName(undefined, field);
            return {
                id: this.definition.createNodeId(modelFieldValueListItem?.id || modelFieldValueListItem),
                internal: {
                    type: typename,
                },
                __typename: typename,
            };
        });
    }
    /*
     * Create data normalizers
     */
    toCreateSingleFieldValue(input, field, treeContext) {
        if (field.isRootValue) {
            return this.toInsertedDocument(input, treeContext);
        }
        else {
            const rawId = input?.id || input;
            const id = field.type.createNodeId(rawId);
            return {
                type: `reference`,
                refType: field.type.getTypeName() === `Asset` ? `asset` : `document`,
                // used by the visual editor to resolve relationships
                refId: rawId,
                // used by the GraphQL API to resolve relationship fields, this is ignored by the visual editor
                _connectId: id,
            };
        }
    }
    toCreateSingleFieldValueLocalized(input, field, treeContext) {
        if (field.isRootValue) {
            throw new Error(`Attempted to field-level localize a top-level document. This is not allowed and is likely a Netlify SDK bug.`);
        }
        return {
            type: "reference",
            refType: field.type.getTypeName() === `Asset` ? `asset` : `document`,
            localized: true,
            locales: this.convertObjectLocaleValues(input, (refId, locale) => {
                return {
                    locale,
                    // used by the visual editor to resolve relationships
                    refId,
                    // used by the GraphQL API to resolve relationship fields, this is ignored by the visual editor
                    _connectId: field.type.createNodeId(refId),
                };
            }, treeContext),
        };
    }
    toCreateListFieldValue(input) {
        return {
            type: `list`,
            items: input?.map?.((inputListItem) => {
                const rawId = inputListItem?.id || inputListItem;
                return {
                    type: `reference`,
                    refType: this.definition.getTypeName() === `Asset` ? `asset` : `document`,
                    // used by the visual editor to resolve relationships
                    refId: rawId,
                    // used by the GraphQL API to resolve relationship fields, this is ignored by the visual editor
                    _connectId: this.definition.createNodeId(rawId),
                };
            }),
        };
    }
    /*
     * Shared data normalization utils
     */
    toInsertedDocument(input, { visitorState, path }) {
        const inputCopy = { ...input };
        const walker = this.definition.ModelWalker;
        this.setNodeId(inputCopy, path);
        if (this.definition.localized &&
            this.definition.ModelBuilder.locales.length > 0 &&
            !inputCopy._locale) {
            inputCopy._locale = this.definition.ModelBuilder.defaultLocale?.code;
        }
        if (
        // coercing fields on a null model value will throw errors if one of the fields is required,
        // even if the parent model is not a required field - only check for fields if the modelValue is not null
        input !== null &&
            this.definition.hasFields) {
            walker.coerceFields(inputCopy, path, visitorState);
        }
        // Add internal fields
        inputCopy.internal ||= {};
        inputCopy.internal.contentDigest = this.getCacheValue(inputCopy);
        inputCopy.internal.type = this.definition.prefixedTypeName(undefined, {
            // explicitly use the defined type in case of conflicts. IE if there's a document type called Color, we want the internal type to be prefixed like ConnectorPrefixColor - without passing this it will use the builtin Color (since there's no field here.)
            kind: "prefer-defined",
        });
        return inputCopy;
    }
    setNodeId(input, path) {
        if (this.definition.isNodeType) {
            const rawId = input.id;
            // If the node is a root node (ie no path yet), we need to add the type name to the path for error messages. ex: "MyModel.foo.bar.id"
            if (!path.length) {
                path.push(this.definition.getTypeName());
                path.push(`(rawId='${rawId}')`);
            }
            if (!rawId) {
                throw new ModelError(`The value at input path "${path.join(`.`)}" is missing an "id".\nAll nodes must have an "id" field which identifies the node.`);
            }
            input._objectId = rawId;
            input._originalType = this.definition.getOriginalName();
            if (!input._updatedAt && input._createdAt) {
                input._updatedAt = input._createdAt;
            }
            input.id = this.definition.createNodeId(rawId);
            if (this.runtimePlatform === `netlify-create`) {
                // used by the GraphQL API to resolve relationship fields, this is ignored by the visual editor
                input._connectId = input.id;
            }
        }
    }
    getCacheField(coercedValue) {
        switch (this.runtimePlatform) {
            case "netlify-create":
                return coercedValue?.value;
            case "netlify-connect":
                return coercedValue;
        }
    }
    getCacheValue(coercedValue) {
        const { cacheFieldName } = this.definition;
        if (cacheFieldName) {
            return this.getCacheField(coercedValue[cacheFieldName]);
        }
        return (
        // Fallback to the updatedAt field.
        // This is a required field in Create
        this.getCacheField(coercedValue?._updatedAt) ||
            // all falsey values aren't acceptable as cache values
            // always bust the cache if there's no cache key or GraphQL queries will not invalidate
            // TODO: when _updatedAt is required for all connectors, remove fallback Math.random
            String(Math.random().toString()));
    }
}
//# sourceMappingURL=document.js.map