import { ModelTransformer, } from "../transformer.js";
import { ModelError } from "../error.js";
export class ScalarBaseTransformer extends ModelTransformer {
    // all scalar field definitions proxy from the same value property in Create
    toConnectSingleFieldDefinition(modelField) {
        // ex -> title: String! @proxy(from: "title.value") # for a non null field in Create
        // or -> title: String # a nullable field in Connect
        return this.modelFieldToGraphQLFieldSDL(modelField, {
            proxyFrom: `value`,
        });
    }
    // all scalar field definitions proxy from the same value property in Connect
    toConnectListFieldDefinition(modelField) {
        // ex -> titles: [String]! @proxy(from: "title.items.value") # for a non null field in Create
        // or -> titles: [String] # a nullable field in Connect
        return this.modelFieldToGraphQLFieldSDL(modelField, {
            proxyFrom: `items.value`,
        });
    }
    toConnectDefinition() {
        // all scalar types are built in to Connect already
        return ``;
    }
    toCreateDefinition() {
        // all scalar types are built in to Create already
        return null;
    }
    toConnectSingleFieldValue(input) {
        // all scalar types are stored as-is in Connect
        return input;
    }
    toConnectListFieldValue(input) {
        // all scalar types are stored as-is in Connect
        return input;
    }
    get visualEditorFieldType() {
        throw this.notImplemented(`get visualEditorFieldType`);
    }
    toCreateSingleFieldValue(input) {
        return {
            type: this.visualEditorFieldType,
            value: input,
        };
    }
    toCreateSingleFieldValueLocalized(input, _field, treeContext) {
        return {
            type: this.visualEditorFieldType,
            localized: true,
            locales: this.convertObjectLocaleValues(input, (value, locale) => {
                return {
                    locale,
                    value,
                };
            }, treeContext),
        };
    }
    toCreateListFieldValue(input) {
        return {
            type: `list`,
            items: input?.map?.((listFieldValue) => {
                return {
                    type: this.visualEditorFieldType,
                    value: listFieldValue,
                };
            }),
        };
    }
    parseVisitedInputList(input, field, treeContext) {
        const isNullable = field.list !== `required`;
        if (isNullable && !input) {
            return null;
        }
        if (!Array.isArray(input)) {
            throw new ModelError(`Insertion failed validation\n  for model "${this.definition.getTypeName()}"\n  on required list field "${field.name}" ${`\n  at input path ${treeContext.path.join(`.`)} <- this field\n  required field type "${field.type.getTypeName()}${field.list ? `[]` : ``}"\n  provided field value:\n    ${field.name} is "${JSON.stringify(input, null, 2)}"`.substring(0, 250) + `\n...`}`);
        }
        return input.map((item) => this.parseVisitedInputSingle(item, field, treeContext));
    }
}
//# sourceMappingURL=scalar.js.map