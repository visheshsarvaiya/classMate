import path, { dirname, join, resolve } from "node:path";
import fs from "node:fs/promises";
import { fileURLToPath } from "node:url";
import { z, ZodError } from "zod";
import { NetlifyExtensionClient, NetlifyExtensionBuildClient, } from "../api/index.js";
import { envVarFromSlug } from "../utils.js";
import { NetlifyConnector, } from "./connect/sdk.js";
import { defaultOnUninstallHandler, defaultOnDisconnectHandler, defaultOnInstallHandler, } from "./api/handlers.js";
import { EXTENSION_API_URL_PROD, EXTENSION_API_URL_STAGING, } from "../constants/urls.js";
import { createExtensionEndpointFetch } from "../utils/extension_endpoint_fetch.js";
const ProviderTokensSchema = z.array(z.object({
    token: z.string().min(1).trim(),
    externalId: z.string().min(1).trim(),
    connectionId: z.string().min(1).trim(),
}));
const parseProviderTokens = (headers) => {
    if (!headers) {
        return [];
    }
    try {
        return ProviderTokensSchema.parse(JSON.parse(headers));
    }
    catch (e) {
        console.error("Failed to parse provider tokens header", e);
        return [];
    }
};
export class NetlifyExtension {
    _buildHooks;
    _wrappers;
    _handlers;
    _netlifyConnectPlugin;
    _buildConfigurationSchema;
    _buildContextSchema;
    _siteConfigSchema;
    _teamConfigSchema;
    _edgeFunctionsSettings;
    _functionsSettings;
    _slug = "";
    _hostSiteId;
    _buildHooksOptions;
    constructor({ buildConfigSchema, buildContextSchema, siteConfigSchema, teamConfigSchema, } = {}) {
        this._buildHooks = {
            onPreBuild: null,
            onBuild: null,
            onPostBuild: null,
            onSuccess: null,
            onError: null,
            onEnd: null,
            onPreDev: null,
            onDev: null,
        };
        this._buildHooksOptions = {
            onPreBuild: null,
            onBuild: null,
            onPostBuild: null,
            onSuccess: null,
            onError: null,
            onEnd: null,
            onPreDev: null,
            onDev: null,
        };
        this._buildConfigurationSchema = buildConfigSchema;
        this._buildContextSchema = buildContextSchema;
        this._siteConfigSchema = siteConfigSchema;
        this._teamConfigSchema = teamConfigSchema;
        this._handlers = {
            "on-install": defaultOnInstallHandler,
            "on-uninstall": defaultOnUninstallHandler,
            "on-disconnect": defaultOnDisconnectHandler,
        };
        this._wrappers = {};
    }
    get buildSlug() {
        return envVarFromSlug(this._slug);
    }
    /**
     * Used to add a build event handlers to the extension.
     */
    addBuildEventHandler(type, func, options) {
        if (options) {
            this._buildHooksOptions[type] = options;
        }
        this._buildHooks[type] = async (context) => {
            const buildToken = process.env[`${this.buildSlug}_BUILD_TOKEN`];
            const { netlifyConfig, constants } = context;
            const buildConfig = this.getBuildConfig({ netlifyConfig });
            const { ACCOUNT_ID, SITE_ID } = constants;
            let buildContext = undefined;
            if (buildToken && this._hostSiteId) {
                const url = `https://${this._hostSiteId}.netlify.app`;
                const buildContextResponse = await fetch(`${url}/.netlify/functions/handler/build-context`, {
                    method: "POST",
                    headers: {
                        ["netlify-token"]: buildToken,
                    },
                    body: JSON.stringify({
                        site_id: process.env.SITE_ID,
                        team_id: ACCOUNT_ID,
                        token: buildToken,
                    }),
                });
                if (!buildContextResponse.ok) {
                    console.warn("Failed to fetch build context, skipping");
                    return;
                }
                try {
                    buildContext =
                        (await buildContextResponse.json());
                }
                catch {
                    /* empty */
                }
            }
            const shouldInjectFunctions = type === "onPreBuild" || type === "onPreDev";
            if (shouldInjectFunctions &&
                this._functionsSettings !== undefined &&
                this._functionsSettings.prefix &&
                this._functionsSettings.path) {
                await this.injectFunctions({
                    constants,
                    prefix: this._functionsSettings.prefix,
                    shouldInjectFunction: this._functionsSettings.shouldInjectFunction,
                })();
            }
            if (shouldInjectFunctions &&
                this._edgeFunctionsSettings !== undefined &&
                this._edgeFunctionsSettings.prefix &&
                this._edgeFunctionsSettings.path) {
                await this.injectEdgeFunctions({
                    constants,
                    prefix: this._edgeFunctionsSettings.prefix,
                    shouldInjectFunction: this._edgeFunctionsSettings.shouldInjectFunction,
                })();
            }
            const netlifyBuildbotToken = context.extensionMetadata?.extension_token || "";
            const isStaging = constants?.NETLIFY_API_HOST?.includes(`api-staging.netlify.com`);
            const jigsawUrl = isStaging
                ? EXTENSION_API_URL_STAGING
                : EXTENSION_API_URL_PROD;
            const netlifyApiUrl = isStaging
                ? `${EXTENSION_API_URL_STAGING}/api/v1`
                : `${EXTENSION_API_URL_PROD}/api/v1`;
            const client = new NetlifyExtensionBuildClient(netlifyBuildbotToken, this._slug, {
                jigsawUrl,
                netlifyApiUrl,
                netlifyTokenIssuer: "buildbot",
            });
            const extensionEndpointFetch = createExtensionEndpointFetch({
                extension: { slug: this._slug, id: this._hostSiteId || "" },
                netlifyToken: netlifyBuildbotToken,
                netlifyTokenIssuer: "buildbot",
                siteId: SITE_ID,
                teamId: ACCOUNT_ID,
            });
            return func({
                ...context,
                buildConfig,
                buildContext,
                client,
                extensionEndpointFetch,
            });
        };
    }
    /**
     * Used to add a build context to the extension that can be used in a build hook.
     * @deprecated, use the client passed into build event handlers instead.
     */
    addBuildEventContext(handler) {
        this._handlers["build-context"] = async (event, { client }) => {
            if (event.httpMethod !== "POST") {
                return {
                    statusCode: 405,
                };
            }
            const body = JSON.parse(event.body || "{}");
            const { site_id, team_id } = body;
            const { team_id: teamId, token } = await client.exchangeBuildToken(site_id, team_id);
            const isStaging = event.rawUrl?.includes(`.netlifystg.app`) ||
                event.path?.includes(`.netlifystg.app`);
            const jigsawUrl = isStaging
                ? EXTENSION_API_URL_STAGING
                : EXTENSION_API_URL_PROD;
            const newClient = new NetlifyExtensionClient(token, this._slug, { jigsawUrl });
            if (!teamId) {
                return {
                    statusCode: 401,
                };
            }
            let teamConfig = {};
            try {
                const config = await client.getTeamConfiguration(teamId);
                teamConfig = {
                    ...config,
                    config: config?.config ?? {},
                };
                if (teamConfig?.id) {
                    client.teamConfigId = teamConfig.id;
                }
            }
            catch (e) {
                console.error("Failed to get team configuration: ", e);
            }
            let siteConfig = {};
            if (site_id) {
                try {
                    const config = await newClient.getSiteConfiguration(teamId, site_id);
                    siteConfig = {
                        ...config,
                        config: config?.config ?? {},
                    };
                }
                catch (e) {
                    console.error("Failed to get site configuration: ", e);
                }
            }
            const buildContextContext = {
                site_id,
                site_config: siteConfig,
                team_config: teamConfig,
                client: newClient,
            };
            try {
                const { config: teamConfig } = (await newClient.getTeamConfiguration(teamId)) ?? {};
                buildContextContext.team_config = teamConfig;
            }
            catch (e) {
                console.error("Failed to get team configuration and set the team config: ", e);
            }
            buildContextContext.team_id = teamId;
            const buildContext = await handler(buildContextContext);
            return {
                statusCode: 200,
                body: JSON.stringify(buildContext),
            };
        };
    }
    /**
     * Used to add an endpoint to the extension.
     */
    addEndpoint(name, handler) {
        this._handlers[name] = handler;
    }
    /**
     * Used to add a Wrapper to the extension.
     */
    addWrapper(name, handler) {
        this._wrappers[name] = handler;
    }
    /**
     * The handler to use for the onInstall endpoint.
     */
    onInstall(handler) {
        this._handlers["on-install"] = async (event, context) => {
            const res = await defaultOnInstallHandler(event, context);
            if (res.statusCode !== 200) {
                return res;
            }
            const { siteId, teamId } = JSON.parse(event.body ?? "{}");
            return handler(event, {
                ...context,
                siteId: siteId ?? null,
                teamId: teamId ?? null,
            });
        };
    }
    /**
     * The handler to use for the onUninstall endpoint.
     */
    onUninstall(handler) {
        this._handlers["on-uninstall"] = async (event, context) => {
            if (event.body === null) {
                return {
                    statusCode: 400,
                    body: JSON.stringify({ message: "Missing body" }),
                };
            }
            const { teamId } = JSON.parse(event.body);
            if (!teamId) {
                return {
                    statusCode: 400,
                    body: JSON.stringify({ message: "Missing teamId" }),
                };
            }
            const integrationHandlerRes = await handler(event, context);
            if (integrationHandlerRes.statusCode !== 200 &&
                integrationHandlerRes.statusCode !== 204) {
                return integrationHandlerRes;
            }
            return await defaultOnUninstallHandler(event, context);
        };
    }
    /**
     * The handler to use for the onDisconnect endpoint.
     */
    onDisconnect(handler) {
        this._handlers["on-disconnect"] = async (event, context) => {
            const integrationHandlerRes = await handler(event, context);
            if (integrationHandlerRes.statusCode !== 200) {
                return integrationHandlerRes;
            }
            return {
                statusCode: 200,
                body: "Disconnected",
            };
        };
    }
    addWebhookHandler(name, handler) {
        const webhookName = name ? `webhook-${name}` : "webhook";
        this._handlers[webhookName] = handler;
    }
    /**
     * Used to inject edge functions into the user's site.
     */
    injectEdgeFunctions({ constants, prefix, shouldInjectFunction, }) {
        return async () => {
            const { INTERNAL_EDGE_FUNCTIONS_SRC } = constants;
            if (!INTERNAL_EDGE_FUNCTIONS_SRC) {
                throw new Error("INTERNAL_EDGE_FUNCTIONS_SRC is not available for this Build Event Handler.");
            }
            // The ef directory will be in the site's base directory if defined, or in the repository root.
            const outDir = join(INTERNAL_EDGE_FUNCTIONS_SRC); //.netlify/edge-functions
            // create the edge functions directory if it doesn't exist
            await fs.mkdir(outDir, { recursive: true });
            const __filename = fileURLToPath(import.meta.url);
            const __dirname = dirname(__filename);
            // Find the edge functions we've copied over into the extension's build folder
            const sourcePath = join(__dirname, "edge-functions");
            try {
                const edgeFunctions = await fs.readdir(sourcePath, {
                    withFileTypes: true,
                });
                const copyPromises = edgeFunctions.map((item) => {
                    // Strip the prefix from the filename to match the user's original function name. Also
                    // strip off the file extension (if any) to that directories containing functions don't
                    // have special treatment vs. the normal function files. This also prevents the scenario
                    // where someone reorganizes a function into a subdirectory and accidentally starts
                    // injecting a function that was previously filtered out.
                    const extname = path.extname(item.name);
                    const name = item.name
                        .replace(`${prefix}_`, "")
                        .replace(new RegExp(`${extname.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}$`), "");
                    if (shouldInjectFunction({ name })) {
                        return fs.cp(join(sourcePath, item.name), resolve(outDir, item.name), { recursive: true });
                    }
                });
                const results = await Promise.all(copyPromises);
                results.forEach((result, index) => {
                    if (result !== undefined) {
                        const functionName = edgeFunctions[index].name;
                        console.log(`Successfully injected edge function: ${functionName}`);
                    }
                });
            }
            catch (error) {
                console.error("Error copying files:", error);
            }
        };
    }
    /**
     * Used to inject functions into the user's site.
     */
    injectFunctions({ constants, prefix, shouldInjectFunction, }) {
        return async () => {
            const { INTERNAL_FUNCTIONS_SRC } = constants;
            if (!INTERNAL_FUNCTIONS_SRC) {
                throw new Error("INTERNAL_FUNCTIONS_SRC is not available for this Build Event Handler.");
            }
            // The ef directory will be in the site's base directory if defined, or in the repository root.
            const outDir = join(INTERNAL_FUNCTIONS_SRC); //.netlify/functions-internal
            // create the edge functions directory if it doesn't exist
            await fs.mkdir(outDir, { recursive: true });
            const __filename = fileURLToPath(import.meta.url);
            const __dirname = dirname(__filename);
            // Find the edge functions we've copied over into the extension's build folder
            const sourcePath = join(__dirname, "functions");
            try {
                const functions = await fs.readdir(sourcePath, { withFileTypes: true });
                const copyPromises = functions.map((item) => {
                    // Strip the prefix from the filename to match the user's original function name. Also
                    // strip off the file extension (if any) to that directories containing functions don't
                    // have special treatment vs. the normal function files. This also prevents the scenario
                    // where someone reorganizes a function into a subdirectory and accidentally starts
                    // injecting a function that was previously filtered out.
                    const extname = path.extname(item.name);
                    const name = item.name
                        .replace(`${prefix}_`, "")
                        .replace(new RegExp(`${extname.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}$`), "");
                    if (shouldInjectFunction({ name })) {
                        return fs.cp(join(sourcePath, item.name), resolve(outDir, item.name), { recursive: true });
                    }
                });
                const results = await Promise.all(copyPromises);
                results.forEach((result, index) => {
                    if (result !== undefined) {
                        const functionName = functions[index].name;
                        console.log(`Successfully injected function: ${functionName}`);
                    }
                });
            }
            catch (error) {
                console.error("Error copying files:", error);
            }
        };
    }
    /**
     * Used to add edge functions to the extension. Edge functions added using this method are
     * injected into a user's site whenever the user's site is built.
     *
     * @example
     * ```ts
     * extension.addEdgeFunctions(
     *   "src/edge-functions",
     *   {
     *     prefix: "my_extension",
     *     shouldInjectFunction: ({ name }) => name === "only-inject-this-one",
     *   },
     * );
     * ```
     */
    addEdgeFunctions(path, { prefix, shouldInjectFunction }) {
        if (typeof path !== "string" || path.length === 0) {
            throw new Error("Path must be a non-empty string.");
        }
        if (!prefix) {
            throw new Error("You must provide a prefix on the edgeFunctionsSettings when initializing the extension.");
        }
        this._edgeFunctionsSettings = {
            path,
            prefix,
            shouldInjectFunction: shouldInjectFunction ?? (() => true),
        };
        this.addFallbackBuildEventHandlers();
    }
    /**
     * Used to add functions to the extension. Functions added using this method are injected into a
     * user's site whenever the user's site is built.
     *
     * @example
     * ```ts
     * extension.addEdgeFunctions(
     *   "src/functions",
     *   {
     *     prefix: "my_extension",
     *     shouldInjectFunction: ({ name }) => name === "only-inject-this-one",
     *   },
     * );
     * ```
     */
    addFunctions(
    /**
     * A path to the directory containing functions. It should be a path relative to your
     * extension's base path, e.g. `src/edge-functions`.
     */
    path, { prefix, shouldInjectFunction }) {
        if (typeof path !== "string" || path.length === 0) {
            throw new Error("Path must be a non-empty string.");
        }
        if (!prefix) {
            throw new Error("You must provide a prefix on the functionsSettings when initializing the extension.");
        }
        this._functionsSettings = {
            path,
            prefix,
            shouldInjectFunction: shouldInjectFunction ?? (() => true),
        };
        this.addFallbackBuildEventHandlers();
    }
    addFallbackBuildEventHandlers() {
        if (!this._buildHooks.onPreBuild) {
            this.addBuildEventHandler("onPreBuild", () => {
                return;
            });
        }
        if (!this._buildHooks.onPreDev) {
            this.addBuildEventHandler("onPreDev", () => {
                return;
            });
        }
    }
    get buildHooks() {
        return this._buildHooks;
    }
    get buildHooksOptions() {
        return this._buildHooksOptions;
    }
    get handlers() {
        return this._handlers;
    }
    get wrappers() {
        return this._wrappers;
    }
    get baseHandler() {
        return async (event, context) => {
            const responseHeaders = {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Headers": "*",
                "Access-Control-Allow-Methods": "*",
            };
            // Fetch the path components from /api/<name> or /.netlify/functions/<name>
            // match with regex
            const routeRegex = /^(?:\/.netlify\/functions\/handler\/|\/api\/)([^/]+)(\/.*)?$/;
            const components = event.path.match(routeRegex);
            const name = components?.[1] ?? "not-found";
            const webhookHandler = name.startsWith("webhook");
            const handler = this._handlers[name];
            const isStaging = event.rawUrl?.includes(`.netlifystg.app`) ||
                event.path?.includes(`.netlifystg.app`);
            const jigsawUrl = isStaging
                ? EXTENSION_API_URL_STAGING
                : EXTENSION_API_URL_PROD;
            if (handler) {
                // Allow CORS preflight requests where the request does not come from the same origin
                if (event.httpMethod === "OPTIONS") {
                    return {
                        statusCode: 200,
                        headers: responseHeaders,
                    };
                }
                let nfToken = event.headers.cookie
                    ?.split(";")
                    .find((c) => c.includes("_nf-auth"))
                    ?.split("=")[1];
                if (!nfToken) {
                    nfToken = event.headers["netlify-token"];
                }
                if (!nfToken && !webhookHandler) {
                    return {
                        statusCode: 401,
                        headers: responseHeaders,
                        body: JSON.stringify({
                            error: "Unauthorized",
                        }),
                    };
                }
                const client = new NetlifyExtensionClient(nfToken ?? "", this._slug, { jigsawUrl });
                const { siteId, teamId, userId } = event.queryStringParameters ?? {};
                const { "provider-oauth-token": providerOAuthToken, "provider-oauth-tokens": providerOAuthTokens, } = event.headers;
                event.path = `/${name}${components?.[2] ?? ""}`;
                const hasConnector = !!this._netlifyConnectPlugin;
                const hasBuildEventHandler = Object.values(this._buildHooks).filter(Boolean).length > 0;
                let teamConfig = {};
                if (teamId) {
                    try {
                        const config = await client.getTeamConfiguration(teamId);
                        teamConfig = {
                            ...config,
                            config: config?.config ?? {},
                        };
                        if (teamConfig?.id) {
                            client.teamConfigId = teamConfig.id;
                        }
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
                let siteConfig = {};
                if (siteId && teamId) {
                    try {
                        siteConfig =
                            (await client.getSiteConfiguration(teamId, siteId)) ?? {};
                        if (siteConfig?.id) {
                            client.siteConfigId = siteConfig.id;
                        }
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
                const providerTokens = parseProviderTokens(providerOAuthTokens);
                try {
                    const response = await handler(event, {
                        ...context,
                        auth: {
                            netlifyToken: nfToken ?? null,
                            providerToken: providerOAuthToken ?? null,
                            providerTokens,
                        },
                        client,
                        hasBuildEventHandler,
                        hasConnector,
                        siteConfig,
                        siteId: siteId ?? null,
                        teamConfig,
                        teamId: teamId ?? null,
                        user: {
                            id: userId ?? null,
                        },
                    });
                    response.headers = {
                        ...responseHeaders,
                        ...response.headers,
                    };
                    return response;
                }
                catch (e) {
                    console.error(e);
                    return {
                        statusCode: 500,
                        headers: responseHeaders,
                        body: "An unhandled error occurred",
                    };
                }
            }
            return {
                statusCode: 404,
                headers: responseHeaders,
                body: JSON.stringify({
                    error: `Handler ${name} not found`,
                }),
            };
        };
    }
    /**
     * `addConnector` creates a connector definition and attaches it to the extension definition.
     */
    addConnector(config) {
        if (this._netlifyConnectPlugin) {
            throw new Error(`Connector plugin already exists. Only one connector can be built per extension.`);
        }
        return (this._netlifyConnectPlugin = new NetlifyConnector(config));
    }
    get netlifyConnectPlugin() {
        return this._netlifyConnectPlugin ?? null;
    }
    getBuildConfig({ netlifyConfig }) {
        let buildConfig;
        // Attempt to find the extension-specific configuration data
        const integrations = netlifyConfig?.integrations || [];
        if (Array.isArray(integrations)) {
            const integration = integrations.find((integration) => integration.name === this._slug);
            if (integration) {
                if (this._buildConfigurationSchema && integration.config) {
                    try {
                        buildConfig = this._buildConfigurationSchema.parse(integration.config);
                    }
                    catch (e) {
                        if (e instanceof ZodError) {
                            console.error("Failed to parse build configuration:", e.message);
                        }
                        return;
                    }
                }
            }
            if (!this._buildConfigurationSchema) {
                buildConfig = integration?.config;
            }
        }
        return buildConfig;
    }
    getBuildEventHandlersToRun({ netlifyConfig, }) {
        const buildConfig = this.getBuildConfig({ netlifyConfig }) || {};
        return Object.entries(this._buildHooks || {}).reduce((buildEventHandlers, [key, buildEventHandler]) => {
            if (!buildEventHandler) {
                return buildEventHandlers;
            }
            const dynamicConditional = this.buildHooksOptions?.[key]?.if;
            if (!dynamicConditional ||
                (dynamicConditional instanceof Function &&
                    dynamicConditional(buildConfig))) {
                buildEventHandlers[key] = buildEventHandler;
            }
            return buildEventHandlers;
        }, {});
    }
}
// Leaving this class here for a sec to make upgrading easier:
// @deprecated use NetlifyExtension instead
export class NetlifyIntegration {
    constructor(_input = {}) {
        throw new Error(`NetlifyIntegration has been renamed to NetlifyExtension, please update your import to use the new class.`);
    }
    addBuildEventHandler(_type, _func, _options) {
        throw new Error(`Deprecated.`);
    }
    addBuildEventContext(_handler) {
        throw new Error(`Deprecated.`);
    }
    addEndpoint(_name, _handler) {
        throw new Error(`Deprecated.`);
    }
    addWrapper(_name, _handler) {
        throw new Error(`Deprecated.`);
    }
    onInstall(_handler) {
        throw new Error(`Deprecated.`);
    }
    onUninstall(_handler) {
        throw new Error(`Deprecated.`);
    }
    onDisconnect(_handler) {
        throw new Error(`Deprecated.`);
    }
    addWebhookHandler(_name, _handler) {
        throw new Error(`Deprecated.`);
    }
    injectEdgeFunctions(_constants) {
        throw new Error(`Deprecated.`);
    }
    injectFunctions(_constants) {
        throw new Error(`Deprecated.`);
    }
    addEdgeFunctions(_path, _edgeFunctionsOptions) {
        throw new Error(`Deprecated.`);
    }
    addFunctions(_path, _functionsOptions) {
        throw new Error(`Deprecated.`);
    }
    addFallbackBuildEventHandlers() {
        throw new Error(`Deprecated.`);
    }
    get buildHooks() {
        throw new Error(`Deprecated.`);
    }
    get buildHooksOptions() {
        throw new Error(`Deprecated.`);
    }
    get handlers() {
        throw new Error(`Deprecated.`);
    }
    get wrappers() {
        throw new Error(`Deprecated.`);
    }
    get baseHandler() {
        throw new Error(`Deprecated.`);
    }
    addConnector({ defineOptions: _, initState: _b, }) {
        throw new Error(`Deprecated.`);
    }
    get netlifyConnectPlugin() {
        throw new Error(`Deprecated.`);
    }
    getBuildConfig({ netlifyConfig: _ }) {
        throw new Error(`Deprecated.`);
    }
    getBuildEventHandlersToRun({ netlifyConfig: _, }) {
        throw new Error(`Deprecated.`);
    }
}
//# sourceMappingURL=index.js.map