import { ModelBuilder } from "./model/builder.js";
import { CSIBridgeAPI } from "./bridge/csi-module-bridge.js";
import { SourcePluginBridgeAPI } from "./bridge/source-plugin-bridge.js";
import { ModelError } from "./model/error.js";
import { delayedExit } from "./utils/delayed-exit.js";
import { getAPIPromises } from "./utils/api-promises.js";
import { lmdbStoredAssetToStackbit, lmdbStoredDocumentToStackbit, lmdbStoredScheduledActionToStackbit, } from "./utils/data.js";
import { createId } from "./utils/create-id.js";
/*
 * This class is used to store a running instance of a connector, and the instanceID used to look it up
 * The NetlifyConnector class represents the connector implementation, and the ConfiguredNetlifyConnector is a running instance of that connector
 * One NetlifyConnector may have many ConfiguredNetlifyConnector instances, each with a unique instanceID
 * Each ConfiguredNetlifyConnector has one NetlifyConnector instance
 * This is so that the same connector can be used multiple times with different options with separate memory state for each
 */
export class ConfiguredNetlifyConnector {
    NetlifyConnector;
    instanceID;
    sourcePluginAPI;
    csiModuleAPI;
    /**
     * As of January 24, 2023:
     *
     * Knowledge of what platform the connector is running on changes the logic that happens as part of Netlify Create.
     * As there might be other platforms that also need to change their behaviour based on the environment that the connector
     * is running in the future, we're storing this information in the connector instance.
     *
     */
    platform = "unknown";
    runtimeSupportsCreate = false;
    warmCacheKey = `netlify-connector-warm-cache`;
    ModelBuilder;
    nodesApi = { webhookBody: {} };
    createApi = {};
    optionsValues = {};
    initState = {};
    syncCount = 0;
    slug;
    config;
    constructor({ NetlifyConnector, instanceID, config, slug, options, }) {
        this.instanceID = instanceID;
        this.NetlifyConnector = NetlifyConnector;
        this.config = config;
        this.slug = slug;
        this.ModelBuilder = new ModelBuilder({
            nodesApi: this.nodesApi,
            createApi: this.createApi,
            supports: NetlifyConnector.supports,
            slug: this.slug,
            createId: this.createId.bind(this),
            shouldHandleCreateSupport: this.shouldHandleCreateSupport.bind(this),
            connectorOptionsValues: options,
            instanceID,
        });
        this.sourcePluginAPI = new SourcePluginBridgeAPI(this);
        this.csiModuleAPI = new CSIBridgeAPI(this);
    }
    createId(id, modelName) {
        return createId(modelName + id, this.instanceID);
    }
    // get getAPIPromises for this configured connector instance by apiName
    getAPIPromises(apiName) {
        const promises = getAPIPromises(this.instanceID, apiName, this.shouldHandleCreateSupport());
        if (apiName === "init") {
            // connect init runs on both Connect/Create so wait for it to resolve before setting the platform
            // no matter the platform, the init promise will always resolve,
            promises.connect?.promise?.finally(() => {
                if (process.env.SDK_ENV === "development") {
                    this.platform = "local";
                }
                else if (process.env.RESOURCE_TYPE === "DATA_LAYER") {
                    // The above env var is set in the Connect codebase itself
                    this.platform = "netlify-connect";
                }
                else if (this.shouldHandleCreateSupport()) {
                    this.platform = "netlify-visual-editor";
                }
            });
        }
        return promises;
    }
    get proxiedSchemas() {
        return this.NetlifyConnector.proxiedSchemas;
    }
    get definedImplementations() {
        return this.NetlifyConnector.definedImplementations;
    }
    get isUsingUnifiedAPI() {
        return this.NetlifyConnector.isUsingUnifiedAPI;
    }
    get supports() {
        return this.NetlifyConnector.supports;
    }
    shouldHandleCreateSupport() {
        return this.runtimeSupportsCreate;
    }
    setRuntimeSupportsCreate() {
        this.runtimeSupportsCreate = true;
        this.getAPIPromises(`runtime`).create.resolve();
    }
    setOptionsValues(options) {
        try {
            this.NetlifyConnector.optionsSchema?.validate(options, this.slug);
        }
        catch (e) {
            if (e instanceof ModelError) {
                console.error(e.message);
            }
            else {
                console.error(e);
            }
            return delayedExit();
        }
        this.optionsValues = options;
    }
    setInitState(state) {
        this.initState = state;
    }
    async getLmdbDatastore() {
        const { getLmdbStore } = (await import(
        // content-engine is an external dep of the SDK, and the same content-engine instance must be used between Stackbit and the SDK
        // this is a non-statically analyzable import so stackbit can't bundle it in esbuild
        `@netlify/content-engine/dist/datastore/lmdb/lmdb-datastore.js?${Math.random()}`));
        const datastore = getLmdbStore();
        await datastore.ready();
        return datastore;
    }
    async restoreAllDocuments() {
        const datastore = await this.getLmdbDatastore();
        const allDocuments = [];
        for (const [name, definition] of this.ModelBuilder.models) {
            // assets are restored separately
            if (name === `Asset`)
                continue;
            // scheduled actions are restored separately
            if (name === "ScheduledAction")
                continue;
            const nodesOfModelType = datastore.getNodesByType(definition.prefixedTypeName());
            nodesOfModelType.forEach((n) => allDocuments.push(lmdbStoredDocumentToStackbit(n, definition)));
        }
        return allDocuments;
    }
    async restoreAllAssets() {
        const definition = this.ModelBuilder.models.get(`Asset`);
        if (!definition) {
            throw new Error("Expected Asset model to be defined, but it is not.");
        }
        const nodesOfModelType = (await this.getLmdbDatastore()).getNodesByType(definition.prefixedTypeName());
        return nodesOfModelType.map(lmdbStoredAssetToStackbit);
    }
    async restoreAllScheduledActions() {
        const definition = this.ModelBuilder.models.get("ScheduledAction");
        if (!definition) {
            throw new Error("Expected ScheduledAction model to be defined, but it is not.");
        }
        const store = await this.getLmdbDatastore();
        return store
            .getNodesByType("ScheduledAction")
            .map(lmdbStoredScheduledActionToStackbit);
    }
    async sync({ actions, cache }) {
        const sync = this.definedImplementations.sync;
        if (!sync) {
            if (this.proxiedSchemas.length) {
                return;
            }
            throw new Error(`No connector.documents({ sync: implementation }) was defined. This API is required for all connectors.`);
        }
        if (this.supports.deltaSync) {
            const { enableStatefulSourceNodes } = actions;
            if (typeof enableStatefulSourceNodes !== `function`) {
                throw new Error(`Could not enable delta syncing. This is a bug in content-engine.`);
            }
            // disables node garbage collection. Plugins must explicitly delete nodes themselves when they support delta syncing. This is the default behaviour
            enableStatefulSourceNodes();
        }
        const isDeltaSync = this.supports.deltaSync
            ? !!(await cache.get(this.warmCacheKey))
            : null;
        const { connect } = this.getAPIPromises(`sync`);
        const models = this.ModelBuilder.modelDataAPIs;
        const runtimeModels = this.ModelBuilder.modelRuntimeDataAPIs;
        const webhookBody = this.nodesApi.webhookBody || {};
        const options = this.optionsValues;
        if (!models || !cache || !options) {
            throw new Error(`Cannot invoke events before models have been defined.`);
        }
        await sync({
            models,
            dynamicModels: runtimeModels,
            cache,
            webhookBody,
            isInitialSync: !isDeltaSync,
            state: this.initState,
            options,
            platform: this.platform,
        });
        connect.resolve();
        if (!isDeltaSync && this.supports.deltaSync) {
            await cache.set(this.warmCacheKey, true);
        }
    }
    get typePrefix() {
        return this.optionsValues?.typePrefix || this.config.typePrefix;
    }
    async _buildDefinedModels(cache) {
        const modeler = this.definedImplementations.model;
        if (!modeler) {
            if (this.proxiedSchemas.length) {
                // if there are proxied schemas, it's fine that the connector didn't define models
                return {
                    sdl: ``,
                };
            }
            throw new Error(`No connector.model(implementation) was defined. This API is required for all connectors.`);
        }
        const { sdl } = await this.ModelBuilder.build({
            modeler,
            typePrefix: this.typePrefix,
            cache,
            configurationOptions: this.optionsValues,
            state: this.initState,
            shouldAutoRenameFieldsAndModels: !!this.config.autoFormatGraphQLTypesAndFields,
            platform: this.platform,
        });
        return {
            sdl,
        };
    }
    async _initialize() {
        // TODO: figure out a way to remove this timeout entirely. It's no longer needed, however a lot of other logic is built around waiting here - removing it seems to cause race conditions.
        // in the meantime, SDK_WAIT_FOR_CREATE_RUNTIME_DURATION is used to speed up tests
        const durationEnvVar = Number(process.env.SDK_WAIT_FOR_CREATE_RUNTIME_DURATION);
        const duration = !isNaN(durationEnvVar) ? durationEnvVar : 500;
        // wait .05s for Create to start and respond to the runtime prom, otherwise assume there's no
        // Create runtime in the current process. This is a workaround because of the dynamic import of the integration in the CSI module. The dynamic import will resolve within this amount of time.
        // by default we resolve runtime create support as false so that the connector still works in Connect without Create
        const { create: createRuntime } = this.getAPIPromises(`runtime`);
        const runtimeCreateTimeout = setTimeout(() => {
            createRuntime.resolve(false);
        }, Number(duration));
        await createRuntime.promise;
        clearTimeout(runtimeCreateTimeout);
        const { create, connect } = this.getAPIPromises(`init`);
        const init = this.definedImplementations.init;
        if (init) {
            const val = await init({
                options: this.optionsValues,
                cache: this.sourcePluginAPI.contentEngineCache,
                platform: this.platform,
            });
            if (val) {
                this.setInitState(val);
            }
        }
        connect.resolve();
        // receive the create API from Create for updating data.
        if (this.shouldHandleCreateSupport()) {
            const createAPI = await create.promise;
            if (createAPI) {
                for (const key of Object.keys(createAPI)) {
                    // @ts-ignore mutating each object key so that any references to the createApi object aren't lost
                    this.createApi[key] = createAPI[key];
                }
            }
        }
    }
}
export function setGlobalConnectorInstance(connectorName, instanceID, connectorInstance) {
    globalThis.__globalConnectorInstances ||= new Map();
    const instances = globalThis.__globalConnectorInstances;
    const instanceName = connectorName + instanceID;
    if (instances.has(instanceName)) {
        throw new Error(`Two connectors with the same name and instance ID ${instanceName} have been initialized. You'll need to ensure multiple connector instances that are using the same connector package have unique plugin options. One way to achieve this is by setting a different typePrefix setting for each configured connector.`);
    }
    instances.set(instanceName, connectorInstance);
}
// we need to get/set globally so instances can be looked up across different connectors in separate bundles - perhaps even on different SDK versions.
// This is to support cross-reference fields which can create a reference field from one connector to any other connector.
export function getGlobalConnectorInstance(connectorName, instanceID) {
    globalThis.__globalConnectorInstances ||= new Map();
    const instanceName = connectorName + instanceID;
    return globalThis.__globalConnectorInstances.get(instanceName);
}
//# sourceMappingURL=connector-instance.js.map