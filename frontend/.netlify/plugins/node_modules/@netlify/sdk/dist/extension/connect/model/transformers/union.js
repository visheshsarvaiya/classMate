import { ModelError } from "../error.js";
import { ModelTransformer, } from "../transformer.js";
import { localDevWarnOnce } from "../utils.js";
import { parseNonUndefined } from "../../../../utils.js";
export class UnionTransformer extends ModelTransformer {
    /*
     * Connect schema definitions
     */
    toConnectDefinition() {
        let sdl = ``;
        if (this.definition.description) {
            sdl += `"""${this.definition.description}"""\n`;
        }
        if (!this.definition.compositeTypes?.length) {
            throw new ModelError(`You've defined a union type ("${this.definition.getTypeName()}") but haven't provided any composite types.`);
        }
        sdl += `union ${this.definition.prefixedTypeName()} = ${this.definition.compositeTypes
            .map((type) => this.definition.prefixedTypeName(this.definition.getDefinedTypeName(type, this.definition.getTypeName())))
            .join(` | `)}`;
        return sdl;
    }
    toConnectSingleFieldDefinition(field) {
        return this.modelFieldToGraphQLFieldSDL(field, {
            proxyFrom: !this.definition.isMixedUnion && this.definition.isNodeUnion
                ? `_connectId`
                : `fields`,
            linkFrom: this.definition.isNodeUnion ? `id` : undefined,
        });
    }
    toConnectListFieldDefinition(field) {
        return this.modelFieldToGraphQLFieldSDL(field, {
            proxyFrom: !this.definition.isMixedUnion && this.definition.isNodeUnion
                ? `items._connectId`
                : `items.fields`,
            linkFrom: this.definition.isNodeUnion ? `id` : undefined,
        });
    }
    /*
     * Create schema definitions
     */
    toCreateDefinition() {
        return null; // Create doesn't have global definitions for union types
    }
    toCreateListFieldDefinition(field) {
        if (field.type.isMixedUnion && field.list) {
            return {
                type: "list",
                ...this.modelFieldToSharedCreateProperties(field),
                // @ts-expect-error - the stackbit types are wrong. "items" can be a list, but the types say otherwise
                items: parseNonUndefined(field.type.compositeTypes).map((ct) => {
                    const type = this.definition.parseTypeToModel(ct);
                    return {
                        type: type.isNodeType
                            ? // SDK fields that are of a Node (document) type are always reference fields
                                `reference`
                            : // otherwise all Stackbit globally named types are referred to as "models" in Stackbit. In the SDK we have node, object, union, and enum and all are globally named types. The SDK does not have non-global inline types like stackbit does
                                `model`,
                        // models is always an array in stackbit, even if there's only 1 model type for this field
                        models: [type.getOriginalName()],
                    };
                }),
            };
        }
        const editorProps = this.getUnionEditorProperties(field);
        if (!editorProps)
            return null;
        return {
            type: "list",
            ...this.modelFieldToSharedCreateProperties(field),
            items: editorProps,
        };
    }
    toCreateSingleFieldDefinition(field) {
        const editorProps = this.getUnionEditorProperties(field);
        if (!editorProps)
            return null;
        return {
            ...this.modelFieldToSharedCreateProperties(field),
            ...editorProps,
        };
    }
    getUnionEditorProperties(field) {
        const { definition: def } = this;
        const models = parseNonUndefined(field.type.compositeTypes).map((ct) => def.parseTypeToModel(ct).getOriginalName());
        if (field.type.isMixedUnion && !field.list) {
            localDevWarnOnce(`mixed union ${def.getTypeName()}`, `Found mixed union type ${def.getTypeName()}. Netlify Visual Editor does not support mixed union types unless the field is a list type, non-list fields of this type will not show up in the Netlify Visual Editor UI`);
            return null;
        }
        if (field.type.isMixedUnion) {
            return null; // List mixed unions are handled in the Create list field definition method
        }
        if (field.type.isNodeUnion) {
            return {
                type: "reference",
                models,
            };
        }
        // Not a mixed or reference union, so this is a union of object model types
        return {
            type: "model",
            models,
        };
    }
    /*
     * Connect/Create input data parsing (runs before data normalizers for each platform below)
     */
    parseVisitedInputSingle(visited, field, treeContext) {
        if (typeof visited !== `object`) {
            throw new ModelError(`Found ${typeof visited} value for ${treeContext.path.join(".")} but an object value was expected. Union values must be an object containing a __typename property identifying the type of the value.`);
        }
        if (!visited && !field.required) {
            return null;
        }
        if (this.definition.isUnionType && !visited?.__typename) {
            throw new ModelError(`Union model "${this.definition.getTypeName()}" insertion failed validation for required field "__typename".\nAll union model values must have a "__typename" which identifies the type of the provided value.\nThe value at input path "${treeContext.path.join(`.`)}" is missing a "__typename".`);
        }
        return { ...visited };
    }
    parseVisitedInputList(input, field, treeContext) {
        const isNullable = field.list !== `required`;
        if (isNullable && !input) {
            return null;
        }
        if (!Array.isArray(input)) {
            throw new ModelError(`Input data for field "${treeContext.path.join(`.`)}" is not an array but should be. \n\nReceived ${JSON.stringify(input, null, 2)}`);
        }
        return input.map((item, index) => this.parseVisitedInputSingle(item, { ...field, list: false }, {
            path: [...treeContext.path, `[${index}]`],
            visitorState: treeContext.visitorState,
        }));
    }
    /*
     * Connect data normalizers
     */
    toConnectSingleFieldValue(input, field, treeContext) {
        const { path, visitorState } = treeContext;
        const memberType = this.parseToMemberType(input, path);
        if (memberType.isNodeType) {
            const prefixedTypename = memberType.prefixedTypeName();
            return {
                id: memberType.createNodeId(this.parseInputRawId(input, memberType, path)),
                internal: {
                    type: prefixedTypename,
                },
                __typename: prefixedTypename,
            };
        }
        return memberType.ModelWalker.coerceModelValue(input, field, path, visitorState);
    }
    toConnectSingleFieldValueLocalized(input, field, treeContext) {
        const formattedLocales = {};
        for (const locale of this.definition.ModelBuilder.locales) {
            const value = input[locale.code];
            if (typeof value === `undefined` || value === null) {
                continue;
            }
            formattedLocales[locale.code] = this.toConnectSingleFieldValue(value, {
                ...field,
                // do not add additional locales inside nested objects, they're already here on this level
                localized: false,
            }, treeContext);
        }
        return formattedLocales;
    }
    toConnectListFieldValue(input, field, treeContext) {
        return input?.map?.((node, index) => {
            if (!node && !field.required)
                return null;
            const model = this.definition.parseNameToModel(node.__typename);
            return model.ModelWalker.coerceModelValue(node, { ...field, localized: false, list: false }, [...treeContext.path, `[${index}]`], treeContext.visitorState);
        });
    }
    /*
     * Create data normalizers
     */
    toCreateListFieldValue(modelFieldValue, field, treeContext) {
        const { path, visitorState } = treeContext;
        const listItems = modelFieldValue?.map?.((node, index) => {
            const itemModel = this.definition.getModelByName(node.__typename);
            const val = this.toCreateSingleFieldValue(node, { ...field, list: false }, {
                path: [...path, field.name, `[${index}]`],
                visitorState,
            });
            val.__typename = itemModel?.prefixedTypeName() || val.__typename;
            return val;
        });
        return {
            type: `list`,
            items: listItems,
        };
    }
    toCreateSingleFieldValueLocalized(input, field, treeContext) {
        if (this.definition.isNodeUnion) {
            return {
                type: "reference",
                localized: true,
                refType: "document",
                locales: this.convertObjectLocaleValues(input, (objectValue, locale) => {
                    const memberType = this.parseToMemberType(objectValue, treeContext.path);
                    const { _connectId, refId, fields } = this.toCreateReferenceValue(memberType, objectValue, field, treeContext);
                    return {
                        locale,
                        refId,
                        _connectId,
                        fields,
                    };
                }, treeContext),
            };
        }
        // object union
        return {
            type: "model",
            localized: true,
            locales: this.convertObjectLocaleValues(input, (objectValue, locale) => {
                const memberType = this.parseToMemberType(objectValue, treeContext.path);
                const val = this.toCreateObjectValue(memberType, objectValue, 
                // set localized to false in the nested object as we're already localizing at this level
                { ...field, localized: false }, treeContext);
                return {
                    locale,
                    modelName: val.modelName,
                    fields: val.fields,
                };
            }, treeContext),
        };
    }
    toCreateObjectValue(memberType, input, field, treeContext) {
        const val = memberType.ModelWalker.coerceModelValue(input, field, treeContext.path, treeContext.visitorState);
        return {
            type: `model`,
            modelName: memberType.getOriginalName(),
            fields: val?.fields || val,
        };
    }
    toCreateReferenceValue(memberType, input, _field, treeContext) {
        const rawId = this.parseInputRawId(input, memberType, treeContext.path);
        const globalId = memberType.createNodeId(rawId);
        return {
            _connectId: globalId,
            refId: rawId,
            refType: "document",
            type: "reference",
            // we store the global id on "fields" to support mixed unions. This is not a standard Netlify Create (Stackbit) field
            // graphql proxy directives can only proxy a single field name - so we proxy "fields" and that allows Stackbit objects and references to both proxy correctly in GraphQL
            // if we were to do it the opposite way (store object fields on _connectId, we would be double storing a lot more data - object fields on fields and on _connectId)
            //
            // In other words, "fields" may be either a relationship field id or an actual object containing field data, because we can only proxy one field for the entire union, and that union might either be a reference or an object type.
            //
            // type ExampleParentObject {
            //    unionFieldExample: ExampleMixedUnion @proxy(from: "unionFieldExample.fields") # <- can only proxy by a single field name
            // }
            //
            // type ExampleMixedUnion = ExampleDocument | ExampleObject
            //
            // type ExampleDocument implements Node {
            //    id: ID!
            // }
            // type ExampleObject {
            //    foo: String!
            // }
            //
            // Then in stored data:
            //
            //  { id: "1", unionFieldExample: { __typename: "ExampleObject", fields: { foo: "bar" } }
            //  { id: "2", unionFieldExample: { __typename: "ExampleDocument", fields: "1" } // <- must be on "fields" since we can only proxy a single field name. We can't change how @proxy works since it's outside this codebase and we must be compatible with Connect
            fields: this.definition.isMixedUnion ? globalId : undefined,
        };
    }
    toCreateSingleFieldValue(input, field, treeContext) {
        const memberType = this.parseToMemberType(input, treeContext.path);
        if (memberType.isNodeType) {
            return this.toCreateReferenceValue(memberType, input, field, treeContext);
        }
        return this.toCreateObjectValue(memberType, input, field, treeContext);
    }
    /*
     * Shared data normalization utils
     */
    parseToMemberType(input, path) {
        const typeName = this.definition.ModelBuilder.pascaledNames.get(input.__typename) ||
            input.__typename;
        try {
            return this.definition.parseTypeToModel(typeName);
        }
        catch {
            throw new ModelError(`Could not find model for union type "${typeName}" in model "${this.definition.getTypeName()}" at node path "${path.join(`.`)}".\n\nAll union model values must have a "__typename" which identifies the correct type of the provided value. You may have a typo in your "__typename" value or you may need to define the ${typeName} model.\n\nUnion input: ${JSON.stringify(input, null, 2)}`);
        }
    }
    parseInputRawId(input, memberType, path) {
        const rawId = input?.id;
        if (!rawId) {
            throw new ModelError(`The value at input path "${path.join(`.`)}" is missing an "id".\nAll node type union model values must have an "id" which identifies the node connection field. The type of the model in this union is "${memberType.getTypeName()}"`);
        }
        if (typeof rawId === `number`) {
            return String(rawId);
        }
        return rawId;
    }
}
//# sourceMappingURL=union.js.map