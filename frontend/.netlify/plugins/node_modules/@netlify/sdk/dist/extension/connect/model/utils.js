import slugify from "@sindresorhus/slugify";
// TODO: currently we need this undefined check because we make 1 bundle for node+browser instead of 2 bundles
export const isLocalDev = typeof process !== `undefined` && process.env.NODE_ENV === `development`;
export const isTest = typeof process !== `undefined` && process.env.NODE_ENV === `test`;
const warned = new Set();
export function localDevWarnOnce(key, warning) {
    if (!isLocalDev || warned.has(key))
        return;
    warned.add(key);
    console.warn(`[Netlify SDK] ${warning}`);
}
export function slugifyLocale(code) {
    return slugify(code, { separator: "_", lowercase: false });
}
export function addCacheTagsFromRuntimeObject(runtimeObject, context, typeName, cacheFieldName) {
    if (!runtimeObject || !(`cacheTags` in context) || !cacheFieldName) {
        return;
    }
    // instanceof is slow at scale so look for .then first
    // if there is .then we do need to check instanceof because a node could have a field called `then`
    if (`then` in runtimeObject && runtimeObject instanceof Promise) {
        runtimeObject.then((resolvedRuntimeObject) => {
            const cacheFieldValue = resolvedRuntimeObject?.[cacheFieldName];
            if (cacheFieldValue) {
                context.cacheTags.add(`${typeName}:${cacheFieldValue}`);
            }
        });
    }
    else {
        const cacheFieldValue = runtimeObject?.[cacheFieldName];
        if (cacheFieldValue) {
            context.cacheTags.add(`${typeName}:${cacheFieldValue}`);
        }
    }
}
export function addAllCacheTag(typeName, context) {
    if (!(`cacheTags` in context)) {
        return;
    }
    context.cacheTags.add(typeName);
}
//# sourceMappingURL=utils.js.map