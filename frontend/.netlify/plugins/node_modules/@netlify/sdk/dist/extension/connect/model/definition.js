import camelcase from "camelcase";
// We need this one as it's the one that is used in the @netlify/content-engine
import camelCase from "lodash.camelcase";
import { lmdbStoredAssetToStackbit, lmdbStoredDocumentToStackbit, lmdbStoredScheduledActionToStackbit, } from "../utils/data.js";
import { getGlobalConnectorInstance, } from "../connector-instance.js";
import { fastHash } from "../utils/fast-hash.js";
import { ModelWalker } from "./walker.js";
import { ModelError } from "./error.js";
import { localDevWarnOnce } from "./utils.js";
import DataLoader from "dataloader";
const DYNAMIC_PARAMETERS_DESCRIPTION_STRING_SEPARATOR = `___dynamicModelParameters`;
export const builtInStackbitStringTypes = new Set([
    // todo: make sure the SDK checks that these are strings when validating input data
    "Slug",
    "Url",
    "Text",
    "Markdown",
    "Color",
    "Html",
]);
export const builtInStackbitTypes = new Set([
    ...builtInStackbitStringTypes.keys(),
    "richText",
]);
export const builtInTypes = new Set([
    ...builtInStackbitTypes.keys(),
    `ID`,
    `String`,
    `Int`,
    `Float`,
    `Boolean`,
    `JSON`,
    `Date`,
    "DateTime", // Added via graphql-scalars package
]);
export const mappedBuiltinTypes = new Map([
    ...Array.from(builtInTypes).map((type) => {
        return [type.toLowerCase(), type];
    }),
    // additional mappings
    [`integer`, `Int`],
    [`number`, `Float`],
    [`RichText`, `richText`],
]);
export const builtInScalars = new Set([
    ...Array.from(builtInTypes),
    ...mappedBuiltinTypes.keys(),
]);
export class ModelDefinition {
    compositeTypes = [];
    compositeTypesSet = new Set();
    description;
    cacheFieldName;
    cacheKeyField;
    ModelWalker;
    ModelTransformer;
    ModelBuilder;
    createId;
    visitor;
    camelToOriginalNames = new Map();
    originalToCamelNames = new Map();
    fields = [];
    fieldsMap = new Map();
    fieldGroups;
    localized;
    runtime = false;
    loadOne;
    loadMany;
    dataLoader;
    parameters = [];
    // User can pass strings as well as this object type, but we want to store it as an object type
    // to avoid having to check for the type of each value in the rest of the code
    values;
    isMixedUnion = false;
    isNodeUnion = false;
    definedKind;
    typeName;
    originalName;
    nodesApi;
    createApi;
    label;
    shouldAutoRenameFieldsAndModels = true;
    isExtendedDefinition;
    _isInternalType;
    isPageType;
    editorDocumentPreview;
    editorObjectPreview;
    authLabels;
    fieldAuthLabels = {};
    crossReferenceTo = [];
    // marks this model as a singleton type in the Netlify Create editor
    isEditorSingleInstance;
    // inlineTypes are types that are defined within another type.
    // They are actually global, but their type name is a hash of the type definition itself.
    // this is for situations where a data source has a non-global type that is used in a field of another type.
    // The connector dev typically wont have a typename available for this type, so we generate one for them.
    _isInlineType;
    constructor(input) {
        this.createId = input.createId;
        this.definedKind = input.kind;
        this.description = input.description;
        this.compositeTypes = input.types;
        this.nodesApi = input.nodesApi;
        this.createApi = input.createApi;
        this.visitor = input.visitor;
        this.shouldAutoRenameFieldsAndModels =
            input.shouldAutoRenameFieldsAndModels;
        this.isExtendedDefinition = !!input.isExtendedDefinition;
        if ("runtime" in input && typeof input.runtime === `boolean`) {
            this.runtime = input.runtime;
            this.description = `${DYNAMIC_PARAMETERS_DESCRIPTION_STRING_SEPARATOR}${JSON.stringify(input.parameters)}${DYNAMIC_PARAMETERS_DESCRIPTION_STRING_SEPARATOR}\n${this.description}`;
        }
        if ("loadOne" in input && input.loadOne) {
            this.loadOne = input.loadOne;
        }
        if ("loadMany" in input && input.loadMany) {
            this.loadMany = input.loadMany;
        }
        if ("batchMany" in input && input.batchMany) {
            this.dataLoader = new DataLoader(input.batchMany);
        }
        if ("parameters" in input && input.parameters) {
            this.parameters = this.getFieldsAsArray(input.parameters);
        }
        if ("localized" in input) {
            this.localized = !!input.localized;
        }
        this._isInternalType = !!input.isInternalType;
        this._isInlineType = !!input.isInlineType;
        if (this.isInlineType) {
            const inlinePrefix = camelcase("Inline_" + (input.name || this.definedKind), {
                pascalCase: true,
            });
            // inline type names are a hash of the definition.
            // the type kind or provided name is prefixed for debugging
            this.typeName = inlinePrefix + "_" + this.hashInput(input);
        }
        else if (!input.name) {
            throw new ModelError(`You must provide a name when defining a type. For example: define.methodName({ name: "MyType", ... }). ${this.isNodeType ? `` : `If you do not have a name for this type, consider using an inline type. Ex: define.inline${this.definedKind}(definition)`}`);
        }
        else {
            this.typeName = input.name;
        }
        const existingDefinition = input.ModelBuilder.models.get(this.typeName);
        if (this._isInlineType && existingDefinition) {
            this.ModelBuilder = existingDefinition.ModelBuilder;
            this.ModelWalker = existingDefinition.ModelWalker;
            this.ModelTransformer = existingDefinition.ModelTransformer;
            // inline types may be redefined as many times as the connector wants, we will only use the first definition
            // this is because the connector doesn't have a name for an inline type, so it doesn't know if it's redefining it
            return existingDefinition;
        }
        this.processInputDefinition(input);
        this.ModelWalker = new ModelWalker({
            model: this,
            getModelByName: this.getModelByName.bind(this),
        });
        if (this.isExtendedDefinition) {
            this.ModelBuilder = input.ModelBuilder.extendModel(this);
        }
        else {
            this.ModelBuilder = input.ModelBuilder.addModel(this);
        }
        this.ModelTransformer = new input.TransformerClass({
            definition: this,
            builder: this.ModelBuilder,
        });
        return this;
    }
    // Used for making a name hash for inline type definitions
    // the hash of the definition makes the inline type globally unique
    // we used to hash the input, but it sometimes led to very deep recursion of
    hashInput(input) {
        const hashValues = [
            input.kind,
            input.name,
            input.types?.map((t) => this.getDefinedTypeName(t)),
            input.to,
            input.description,
            input.visitor,
            input.values,
        ];
        if (input.fields) {
            hashValues.push(this.getFieldsHashValues(input.fields, input.ModelBuilder));
        }
        return fastHash(hashValues);
    }
    getFieldHashValues(name, f, builder) {
        const hashValues = [
            name,
            this.getDefinedTypeName(f.type, undefined),
            f.kind,
            f.list,
            f.required,
            f.localized,
            f.description,
            this.getDefinedType(f.type, builder)?.isInlineType
                ? this.getFieldsHashValues(this.getDefinedType(f.type, builder).fields, builder)
                : undefined,
        ];
        if ("localized" in f)
            hashValues.push(f.localized);
        return hashValues;
    }
    getFieldsHashValues(fields, builder) {
        if (!fields)
            return;
        return Array.isArray(fields)
            ? fields.map((f) => this.getFieldHashValues(f.name, f, builder))
            : Object.entries(fields).map(([name, f]) => this.getFieldHashValues(name, f, builder));
    }
    get kind() {
        return this.definedKind;
    }
    _mergeExtendedDefinition(extendedDefinition, modelBuilder) {
        if (modelBuilder !== this.ModelBuilder) {
            throw new ModelError(`The extended definition must be created with the same ModelBuilder instance as the original definition. If you're a user of the Netlify SDK, this method is for internal use only.`);
        }
        if (this.definedKind !== extendedDefinition.definedKind) {
            throw new ModelError(`The extended definition for model "${extendedDefinition.typeName}" must be of the same kind as the original definition. The original definition is of kind "${this.definedKind}" and the extended definition is of kind "${extendedDefinition.definedKind}".`);
        }
        for (const extendedField of extendedDefinition.fields) {
            // don't extend builtin fields
            if (extendedField.name.startsWith(`_`)) {
                continue;
            }
            const originalField = this.fieldsMap.get(extendedField.name);
            if (originalField && originalField?.type !== extendedField.type) {
                throw new ModelError(`The field "${extendedField.name}" is defined in both the original and extended definitions for model "${extendedDefinition.typeName}". Fields cannot be redefined unless the types are identical. The original field type was ${this.getDefinedTypeName(originalField.type)}, extended field type is ${this.getDefinedTypeName(extendedField.type)}`);
            }
            if (originalField) {
                this.fields = this.fields.filter((f) => f.name != extendedField.name);
            }
            this.fields.push(extendedField);
            this.fieldsMap.set(extendedField.name, extendedField);
        }
        if (extendedDefinition.visitor) {
            this.visitor = extendedDefinition.visitor;
        }
    }
    get hasFields() {
        return !!this.fields?.length;
    }
    getFields() {
        return this.fields;
    }
    getTypeName() {
        return this.typeName;
    }
    getOriginalName() {
        return this.originalName || this.typeName;
    }
    get isInternalType() {
        return this._isInternalType;
    }
    get isInlineType() {
        return this._isInlineType;
    }
    get isNodeType() {
        return this.definedKind === `Node`;
    }
    get isObjectType() {
        return this.definedKind === `Object`;
    }
    get isUnionType() {
        return this.definedKind === `Union`;
    }
    get isEnumType() {
        return this.definedKind === `Enum`;
    }
    get isScalarType() {
        return this.definedKind === `Scalar`;
    }
    get isCrossReferenceType() {
        return this.definedKind === `CrossReference`;
    }
    getDefinedType(type, onBuilder = this.ModelBuilder) {
        if (typeof type === `string`) {
            return this.parseNameToModel(type, onBuilder);
        }
        return type;
    }
    getDefinedTypeName(type, fieldName) {
        const isDefineInstance = type instanceof ModelDefinition;
        const typeName = isDefineInstance ? type.typeName : type;
        if (typeof typeName === `undefined`) {
            throw new ModelError(`The type of field "${fieldName}" is undefined. Please define the type of this field.`);
        }
        return typeName;
    }
    prefixedTypeName(typeName = this.typeName, field) {
        const builtinExists = mappedBuiltinTypes.has(typeName.toLowerCase());
        const typeDefinition = this.ModelBuilder.models.get(typeName);
        if (builtinExists &&
            // field is optional, so default to builtins if no field is passed
            !field) {
            // return an unprefixed (builtin) typename
            return typeName;
        }
        if (builtinExists &&
            field &&
            // return builtin if it exists and is preferred
            (field.kind === `builtin` ||
                field.kind === `prefer-builtin` ||
                // or if defined types are preferred but one doesn't exist with this name
                (field.kind === `prefer-defined` && !typeDefinition))) {
            // return an unprefixed (builtin) typename
            return typeName;
        }
        if (field &&
            // if the kind doesn't start with prefer-, then we don't fall back. no type of that kind exists, so error
            ((field.kind === `builtin` && !builtinExists) ||
                (field.kind === `defined` && !typeDefinition))) {
            throw new ModelError(`Field "${field.name}" of type "${typeName}" is defined with "kind: '${field.kind}'" but no ${field.kind} type "${typeName}" exists.`);
        }
        // finally return the prefixed typename of the connector-defined type.
        // A field was passed in and either there was no builtin with this typename, or there was but "prefer-defined" was set
        return `${this.ModelBuilder.typePrefix}${typeName}`;
    }
    getFinalFieldName(fieldName, unionModelName) {
        if (!this.shouldAutoRenameFieldsAndModels)
            return fieldName;
        const model = unionModelName ? this.getModelByName(unionModelName) : this;
        if (unionModelName &&
            this.isUnionType &&
            model &&
            !this.compositeTypesSet.has(model.getTypeName())) {
            throw new Error(`${unionModelName} does not exist in union type ${this.getTypeName()}`);
        }
        return model?.originalToCamelNames?.get(fieldName) || fieldName;
    }
    toCreateModel() {
        return this.ModelTransformer.toCreateDefinition();
    }
    /**
     *
     * Introduced specifically to keep the casing of the richText simple type.
     * At the time of writing (March 7 2024) this is the only type with any camelcasing, the rest
     * can be safely lowercased.
     * TODO: move this to the richText transformer
     */
    getFormattedTypename(typename) {
        if (typename === "richText") {
            return typename;
        }
        return typename.toLowerCase();
    }
    sdkFieldToStackbitField(field, { skipInline: _skip } = { skipInline: false }) {
        const typeName = this.getDefinedTypeName(field.type);
        return this.parseNameToTransformer(typeName).toCreateFieldDefinition(field, this);
    }
    sdkFieldsToStackbitFields() {
        return this.fields
            .filter((field) => {
            return !field.name.startsWith(`_`);
        })
            .map((field) => this.sdkFieldToStackbitField(field))
            .filter((field) => field !== null); // ts doesn't seem to understand the last filter removes null from the type
    }
    invalidate = (id) => {
        this.nodesApi.dispatch?.({
            type: `DELETE_MISSING_NODE`,
            payload: {
                id,
                type: this.prefixedTypeName(),
            },
        });
    };
    get runtimeDataAPI() {
        const walker = this.ModelWalker;
        return {
            name: this.typeName,
            originalName: this.originalName || this.typeName,
            get fields() {
                return walker.fields;
            },
            invalidate: this.invalidate,
        };
    }
    get dataAPI() {
        const walker = this.ModelWalker;
        return {
            name: this.typeName,
            originalName: this.originalName || this.typeName,
            get fields() {
                return walker.fields;
            },
            insert: this.insert,
            delete: this.delete,
            /** @deprecated - use insert() instead, which has identical behaviour to create() */
            create: ((args) => {
                const fnBase = `models.${this.typeName}`;
                localDevWarnOnce(`createNode`, `${fnBase}.create() has been deprecated and replaced with ${fnBase}.insert().
These work identically, however create() will be removed in a future SDK version.
Use the new method now to make it easier to upgrade later.`);
                return this.insert(args);
            }),
        };
    }
    buildWalker() {
        // FIXME(ndhoule): Incorrect type (https://github.com/netlify/sdk/pull/1170#discussion_r1556157222)
        // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression
        return this.ModelWalker.build();
    }
    getScalarModelByName(typeName, onBuilder = this.ModelBuilder) {
        const model = onBuilder.scalarModels.get(typeName) ||
            onBuilder.scalarModels.get(mappedBuiltinTypes.get(typeName || "") || "");
        return model;
    }
    parseNameToTransformer(typeName) {
        return this.parseNameToModel(typeName).ModelTransformer;
    }
    parseTypeToModel(type) {
        const name = this.getDefinedTypeName(type);
        return this.parseNameToModel(name);
    }
    parseNameToModel(typeName, onBuilder = this.ModelBuilder) {
        const model = this.getModelByName(typeName, onBuilder);
        if (model) {
            return model;
        }
        const scalarModel = this.getScalarModelByName(typeName, onBuilder);
        if (scalarModel) {
            return scalarModel;
        }
        throw new Error(`Could not find model for name ${typeName}. This is a Netlify SDK bug`);
    }
    getModelByDefinedType(type) {
        return this.getModelByName(this.getDefinedTypeName(type));
    }
    getModelByName(typeName, onBuilder = this.ModelBuilder) {
        return (onBuilder.models.get(onBuilder.pascaledNames.get(typeName) || typeName) ||
            onBuilder.models.get(mappedBuiltinTypes.get(typeName) || ""));
    }
    hasField(fieldName) {
        return this.fieldsMap.has(fieldName);
    }
    get delete() {
        return (nodeIds) => {
            if (!this.isNodeType) {
                throw new ModelError(`You cannot call delete() on a non-node type. You can only delete nodes. This model is a "${this.getTypeName()}" type.`);
            }
            const deleteNode = this.nodesApi?.deleteNode;
            if (!deleteNode) {
                throw new ModelError(`models.${this.typeName}.delete() can only be called inside createAllNodes or updateNodes Connector events.`);
            }
            const removeNode = (rawId) => {
                const id = this.createNodeId(rawId);
                if (this.createApi?.updateContent) {
                    if (this.typeName === `Asset`) {
                        this.createApi.updateContent({
                            deletedAssetIds: [rawId],
                        });
                    }
                    else {
                        this.createApi.updateContent({
                            deletedDocumentIds: [rawId],
                        });
                    }
                }
                if (!this.nodesApi?.getNode?.(id)) {
                    // in Connect if we get a delete request for a node that doesn't exist,
                    // we need to make sure it's removed from the ledger even if it's already not in lmdb
                    // calling deleteNode() on an already deleted node will prevent DELETE_NODE from being emitted
                    // this custom action will ensure that the node is removed from the ledger
                    // DELETE_MISSING_NODE instead of DELETE_NODE to avoid side effects in Gatsby and
                    // @netlify/content-engine as that action expects the node to exist
                    this.nodesApi?.dispatch?.({
                        type: `DELETE_MISSING_NODE`,
                        payload: {
                            id,
                            type: this.prefixedTypeName(),
                        },
                    });
                }
                // FIXME(ndhoule): Incorrect type (https://github.com/netlify/sdk/pull/1170#discussion_r1556157222)
                // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression
                return deleteNode({
                    id,
                    internal: {
                        type: this.prefixedTypeName(),
                        contentDigest: `0`,
                    },
                });
            };
            if (Array.isArray(nodeIds)) {
                return nodeIds.map(removeNode);
            }
            // FIXME(ndhoule): Incorrect type (https://github.com/netlify/sdk/pull/1170#discussion_r1556157222)
            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression
            return removeNode(nodeIds);
        };
    }
    get insert() {
        return (nodes) => {
            if (!this.isNodeType) {
                throw new ModelError(`You cannot call create() on a non-node type. You can only create nodes. This model is a "${this.getTypeName()}" type.`);
            }
            const createNode = this.nodesApi?.createNode;
            if (!createNode) {
                throw new ModelError(`models.${this.typeName}.insert() can only be called inside documents.sync, createAllNodes, or updateNodes Connector events.`);
            }
            const insertNode = (node) => {
                if (!node)
                    return null;
                const preparedNode = this.prepareNode(node);
                // if stackbit is present in this process
                if (this.createApi?.updateContent) {
                    switch (this.typeName) {
                        case "Asset":
                            this.createApi.updateContent({
                                assets: [lmdbStoredAssetToStackbit(preparedNode)],
                            });
                            break;
                        case "ScheduledAction":
                            this.createApi.updateContent({
                                scheduledActions: [
                                    lmdbStoredScheduledActionToStackbit(preparedNode),
                                ],
                            });
                            break;
                        default:
                            this.createApi.updateContent({
                                documents: [lmdbStoredDocumentToStackbit(preparedNode, this)],
                            });
                    }
                }
                createNode(preparedNode);
                return preparedNode;
            };
            if (Array.isArray(nodes)) {
                return nodes.map((node) => insertNode(node));
            }
            return insertNode(nodes);
        };
    }
    createNodeId(rawId) {
        return this.createId(rawId, this.typeName);
    }
    resolveModelField(field, parentDefinition) {
        const isRootValue = field.type === `<ROOT_NODE>`;
        const originalName = parentDefinition?.camelToOriginalNames?.get(field.name) || field.name;
        const runtime = parentDefinition.runtime || false;
        if (typeof field.type === `string`) {
            // don't mutate so the users field definitions aren't modified
            return {
                runtime,
                ...field,
                originalName,
                type: isRootValue ? this : this.getDefinedType(field.type),
                isRootValue,
            };
        }
        return { runtime, ...field, originalName };
    }
    prepareNode(node) {
        return this.ModelWalker.coerceModelValue(node, {
            name: `<ROOT_NODE>`,
            originalName: `<ROOT_NODE>`,
            type: this,
            isRootValue: true,
            required: true,
            list: false,
            kind: `prefer-defined`,
            runtime: this.runtime,
        }, [], undefined);
    }
    setIsMixedUnion() {
        this.isMixedUnion = true;
    }
    setIsNodeUnion() {
        this.isNodeUnion = true;
    }
    getGlobalCrossReference(connectorName, instanceID) {
        const globalConnector = getGlobalConnectorInstance(connectorName, instanceID);
        if (!globalConnector) {
            // allow unresolved cross references to be created for debugging purposes, and so that a connector with cross references wont break if the cross referenced connector isn't also installed. These wont be usable but they can be queried in GraphQL to see what the cross reference looks like
            return {
                referenceTypePrefix: `Unresolved__`,
                createReferenceId: (id) => id,
            };
        }
        return {
            referenceTypePrefix: globalConnector.typePrefix,
            createReferenceId: globalConnector.createId.bind(globalConnector),
        };
    }
    getAuthorizationDirectiveSDL(additionalAuthLabels) {
        const authLabels = new Set();
        if (additionalAuthLabels) {
            additionalAuthLabels.forEach((l) => authLabels.add(l));
        }
        if (this.authLabels) {
            this.authLabels.forEach((l) => authLabels.add(l));
        }
        if (authLabels.size > 0) {
            return ` @authorization(labels: [${[...authLabels].map((l) => `"${l}"`).join(", ")}])`;
        }
        else {
            return ``;
        }
    }
    getAuthorizationDirectiveForScalarFieldSDL(fieldName) {
        if (this.fieldAuthLabels[fieldName]) {
            return ` @authorization(labels: [${this.fieldAuthLabels[fieldName].map((l) => `"${l}"`).join(", ")}])`;
        }
        return ``;
    }
    /**
     * Converts a type into the GraphQL Schema language (SDL). It's called for every Model.
     */
    toSDL() {
        return this.ModelTransformer.toConnectDefinition();
    }
    containsIllegalChars(str) {
        return /[^a-zA-Z0-9_]/.test(str);
    }
    getFieldsAsArray(fields) {
        if (!Array.isArray(fields)) {
            return Object.entries(fields).map(([fieldName, field]) => {
                return {
                    name: fieldName,
                    ...field,
                };
            });
        }
        else {
            // otherwise use provided array, do a light clone to avoid modifying the original
            return fields.map((field) => ({ ...field }));
        }
    }
    processInputDefinitionFields(definition) {
        if (!this.isObjectType && !this.isNodeType) {
            // only object/node types have fields currently
            return;
        }
        if ((!Array.isArray(definition.fields) &&
            typeof definition.fields !== `object`) ||
            !definition.fields) {
            throw new ModelError(`Field definitions must be an array or object, found ${typeof definition.fields} fields in "${definition.name}" definition.`);
        }
        // convert object field definitions to array
        this.fields = this.getFieldsAsArray(definition.fields);
        const stackbitIsRunningInThisProcess = !!this.createApi?.updateContent;
        const isUsingConnect = definition.runtimePlatform === `netlify-connect`;
        const builtInFields = [
            // connect fields
            {
                name: `id`,
                type: `ID`,
                required: true,
                editor: {
                    hidden: true,
                    readOnly: true,
                },
                gql: { hidden: true }, // already built into the Node interface in gql
            },
            {
                // this is set internally by the SDK. connector devs will not set this. it needs to be here to be stored in Create
                name: `_objectId`,
                type: `String`,
                required: true,
                description: `The original non-global ID from this data source`,
                editor: {
                    hidden: true,
                    readOnly: true,
                },
                gql: { hidden: false },
            },
            {
                // this is set internally by the SDK. connector devs will not set this. it needs to be here to be stored in Create
                name: `_originalType`,
                type: `String`,
                required: !isUsingConnect,
                description: `The original non-global type name from this data source`,
                editor: {
                    readOnly: true,
                    hidden: true,
                },
                gql: { hidden: true },
            },
            {
                // this is set internally by the SDK. connector devs will not set this. it needs to be here to be stored in Create
                name: `_connectId`,
                type: `String`,
                required: stackbitIsRunningInThisProcess,
                editor: {
                    hidden: true,
                },
                gql: { hidden: true },
            },
            // create fields
            // Make _updatedAt and _createdAt required only for netlify-create
            {
                name: `_updatedAt`,
                type: `Date`,
                required: !isUsingConnect,
                editor: {
                    hidden: true,
                },
                gql: { hidden: false },
            },
            {
                name: `_createdAt`,
                type: `Date`,
                required: !isUsingConnect,
                editor: {
                    hidden: true,
                },
                gql: { hidden: false },
            },
            {
                name: `_status`,
                type: `StatusEnum`,
                required: !isUsingConnect && definition.name !== "ScheduledAction",
                editor: {
                    hidden: true,
                },
                gql: { hidden: true },
            },
            {
                name: `_manageUrl`,
                type: `Url`,
                editor: {
                    hidden: true,
                },
                gql: { hidden: true },
            },
            {
                name: `_createdBy`,
                type: `String`,
                editor: {
                    hidden: true,
                },
                gql: { hidden: true },
            },
            {
                name: `_updatedBy`,
                type: `String`,
                list: true,
                editor: {
                    hidden: true,
                },
                gql: { hidden: true },
            },
        ];
        if (this.localized) {
            builtInFields.push({
                name: `_locale`,
                type: `String`,
                editor: {
                    hidden: true,
                },
                gql: { hidden: false },
            });
            builtInFields.push({
                name: `_translations`,
                type: this.typeName,
                list: true,
                required: false,
                editor: {
                    hidden: true,
                },
                gql: { hidden: false },
            });
        }
        const typeCustomizations = definition.ModelBuilder.getTypeCustomizations(this.getTypeName()) ||
            // Netlify UI sends customizations that include the prefix
            definition.ModelBuilder.getTypeCustomizations(`${definition.ModelBuilder.typePrefix}${this.getTypeName()}`);
        if (
        // if this type has injected auth labels
        typeCustomizations?.authLabels &&
            // and the process has labels passed in
            process.env.DATA_LAYER_AUTHORIZATION_LABELS) {
            // store them so they'll be output during toSDL()
            this.authLabels = typeCustomizations.authLabels;
        }
        if (typeCustomizations?.fieldCustomizations?.length) {
            // for each customized field
            for (const fieldCustomization of typeCustomizations.fieldCustomizations) {
                if (fieldCustomization.authLabels) {
                    this.fieldAuthLabels[fieldCustomization.name] =
                        fieldCustomization.authLabels;
                }
                // This fieldCustomization is only for adding auth labels, and not for cross references
                if (!fieldCustomization.type) {
                    continue;
                }
                // only modify it if the field exists
                let useExistingFieldName;
                const existingFieldIndex = this.fields.findIndex((existingField) => {
                    // If it matches the transformed field name then it doesn't support create
                    if (existingField.name === fieldCustomization.name) {
                        useExistingFieldName = true;
                        return true;
                    }
                    else if (camelCase(existingField.name) === fieldCustomization.name) {
                        useExistingFieldName = false;
                        return true;
                    }
                    else {
                        return false;
                    }
                });
                const fieldAlreadyExists = existingFieldIndex !== -1;
                const isRuntimeField = fieldCustomization.mode === `runtime`;
                // Handle runtime fields, create a new field definition to be over-written later
                if (isRuntimeField && fieldAlreadyExists) {
                    throw new Error(`Field ${fieldCustomization.name} of type ${fieldCustomization.type} overwrites an existing field. This is not allowed as it leads to unexpected breaking behaviours for the GraphQL schema.`);
                }
                if (isRuntimeField) {
                    this.fields.push({
                        name: fieldCustomization.name,
                        type: fieldCustomization.type,
                    });
                    // Handle cross references, overwrite the existing field definition
                }
                else if (fieldAlreadyExists) {
                    const newCrossReferenceField = definition.ModelBuilder.pluginAPI.define.crossReference({
                        to: {
                            linkBy: fieldCustomization.linkBy,
                            modelName: fieldCustomization.type,
                            instanceID: fieldCustomization.instanceID,
                            connectorName: fieldCustomization.connectorName,
                        },
                    });
                    const useFieldCustomizationListVal = typeof fieldCustomization.list === `boolean`;
                    const existingVisitor = this.fields[existingFieldIndex].visitor;
                    const visitorForLinkingByCustomFields = (val, info) => {
                        if ((typeof val === `string` || typeof val === `number`) &&
                            fieldCustomization.list) {
                            return existingVisitor ? existingVisitor([val], info) : [val];
                        }
                        return existingVisitor ? existingVisitor(val, info) : val;
                    };
                    this.fields[existingFieldIndex] = {
                        ...this.fields[existingFieldIndex],
                        name: useExistingFieldName
                            ? this.fields[existingFieldIndex].name
                            : fieldCustomization.name,
                        type: newCrossReferenceField,
                        list: useFieldCustomizationListVal
                            ? fieldCustomization.list
                            : this.fields[existingFieldIndex].list,
                        visitor: useFieldCustomizationListVal
                            ? visitorForLinkingByCustomFields
                            : this.fields[existingFieldIndex].visitor,
                    };
                }
                else {
                    throw new Error(`Tried to customize field ${fieldCustomization.name} on type ${this.typeName}, but no field with that name was found. Field names: ${Object.values(this.fields)
                        .map((field) => field.name)
                        .join(`, `)}`);
                }
            }
        }
        if (!definition.isExtendedDefinition && this.isNodeType) {
            this.fields.push(...builtInFields);
        }
        this.fields.forEach((field) => {
            // don't camelcase or validate builtin fields
            if (!this.isNodeType || !builtInFields.includes(field)) {
                if (this.shouldAutoRenameFieldsAndModels) {
                    const fieldName = field.name;
                    const camelFieldName = camelCase(fieldName);
                    if (fieldName !== camelFieldName) {
                        this.camelToOriginalNames.set(camelFieldName, fieldName);
                        this.originalToCamelNames.set(fieldName, camelFieldName);
                        field.name = camelFieldName;
                    }
                }
                this.validateFieldDefinition(field);
            }
            if (this.fieldsMap.has(field.name)) {
                throw new ModelError(`Model field definition with name ${this.getTypeName()}.${field.name} has been defined more than once. Each field name must be unique.`);
            }
            if (field.kind &&
                ![`prefer-builtin`, `prefer-defined`, `builtin`, `defined`].includes(field.kind)) {
                throw new ModelError(`Field kind must be "prefer-builtin", "prefer-defined", "builtin", or "defined" but ${this.getTypeName()}.${field.name}.kind is set to "${field.kind}"`);
            }
            if (!field.kind)
                field.kind = `prefer-builtin`;
            this.fieldsMap.set(field.name, field);
        });
    }
    processInputDefinition(definition) {
        // TODO: move all these input definition validations to ModelTranformers
        if (this.definedKind !== `Node` && definition.cacheFieldName) {
            throw new ModelError(`You cannot provide a "cacheFieldName" for a non-document type. "cacheFieldName" is only valid when using define.document({ ... }). This setting specifies which property on nodes should be used to invalidate each cached document.`);
        }
        if (typeof this.typeName !== `string`) {
            throw new ModelError(`The name of a model must be a string. For example: define.document({ name: "MyType", ... })`);
        }
        if (this.definedKind !== `Enum` && definition.values) {
            throw new ModelError(`You cannot provide "values" for a non-Enum type. "values" is only valid when using define.enum({ ... }).`);
        }
        if (this.definedKind === `Enum`) {
            const invalidEnumValue = definition.values?.find((value) => {
                if (typeof value !== `string` && typeof value !== `object`) {
                    return true;
                }
                if (typeof value === `object` && !value?.label && !value?.value) {
                    return true;
                }
            });
            if (invalidEnumValue) {
                throw new ModelError(`Enum values can only be strings. "${typeof invalidEnumValue === "object"
                    ? JSON.stringify(invalidEnumValue)
                    : invalidEnumValue}" is not valid.`);
            }
            // Transform all strings into objects to avoid having to check for the type of each value in the rest of the code
            this.values = (definition.values || []).map((value) => {
                if (typeof value === `string`) {
                    return { label: value, value };
                }
                return {
                    label: value.label,
                    value: value.value,
                };
            });
        }
        // For Netlify Create don't camel case model names. In a future release this will become the default, but this is a breaking change for now so do it conditionally.
        if (this.shouldAutoRenameFieldsAndModels && !this.isInternalType) {
            const pascaled = camelcase(this.typeName, {
                pascalCase: true,
            });
            if (pascaled !== definition.name) {
                definition.ModelBuilder.pascaledNames.set(this.typeName, pascaled);
                this.originalName = definition.name;
                this.typeName = definition.name = pascaled;
            }
        }
        if (this.containsIllegalChars(this.typeName)) {
            throw new ModelError(`Names can only contain english language letters and numbers. "${definition.name}" is not valid.`);
        }
        if (definition.editor) {
            const { label, isPage, singleInstance, preview, fieldGroups } = definition.editor;
            if (label) {
                this.label = label;
            }
            if (isPage) {
                this.isPageType = true;
            }
            if (singleInstance) {
                this.isEditorSingleInstance = true;
            }
            if (preview) {
                if (definition.kind === `Object`) {
                    this.editorObjectPreview = preview;
                }
                if (definition.kind === `Node`) {
                    this.editorDocumentPreview = preview;
                }
            }
            if (fieldGroups) {
                this.fieldGroups = fieldGroups;
            }
        }
        if (definition.kind === `CrossReference`) {
            if (!definition.to)
                throw new ModelError(`CrossReference must have a "to" field`);
            this.crossReferenceTo = Array.isArray(definition.to)
                ? definition.to
                : [definition.to];
        }
        this.processInputDefinitionFields(definition);
        this.compositeTypes?.forEach((type) => {
            this.compositeTypesSet.add(this.getDefinedTypeName(type));
        });
        this.cacheKeyField = definition.cacheKeyField;
        this.cacheFieldName = definition.cacheFieldName;
        if (this.cacheFieldName) {
            const cacheFieldDef = this.fieldsMap.get(this.cacheFieldName);
            if (!cacheFieldDef) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") but haven't defined a field with that name.`);
            }
            if (!cacheFieldDef.required) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") but that field is not defined as required. For proper cache invalidation this field must always exist.`);
            }
            if (cacheFieldDef.list) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") but that field type is a list. For proper cache invalidation the cacheFieldName can only be set to a non-list field type.`);
            }
            const cacheFieldTypeName = this.getDefinedTypeName(cacheFieldDef.type);
            if (cacheFieldDef.type !== `String` &&
                mappedBuiltinTypes.get(cacheFieldTypeName) !== `String`) {
                throw new ModelError(`You've defined a cacheFieldName ("${this.cacheFieldName}") For proper cache invalidation the cacheFieldName can only be set to a "String" field type. The "${this.cacheFieldName}" field is of type "${cacheFieldTypeName}".`);
            }
        }
    }
    validateFieldDefinition(fieldDef) {
        const fieldName = fieldDef.name;
        if (typeof fieldName !== `string`) {
            throw new ModelError(`Field names must be strings. "${JSON.stringify(fieldName, null, 2)}" is not a string`);
        }
        if (this.containsIllegalChars(fieldName)) {
            throw new ModelError(`Names can only contain english language letters and numbers. "${fieldName}" is not valid.`);
        }
        if (fieldName.match(/^\d/)) {
            throw new ModelError(`Names cannot start with a number. "${fieldName}" is not valid.`);
        }
        if (typeof fieldDef !== `object` || Array.isArray(fieldDef)) {
            throw new ModelError(`Field type definitions must be objects. "${JSON.stringify(fieldDef, null, 2)}" is not an object.`);
        }
        if (typeof fieldDef.type === `string`) {
            const lowercasedBuiltIn = mappedBuiltinTypes.get(fieldDef.type);
            if (lowercasedBuiltIn) {
                fieldDef.type = lowercasedBuiltIn;
            }
        }
        const fieldTypeName = this.getDefinedTypeName(fieldDef.type, fieldName);
        if (typeof fieldTypeName !== `string`) {
            throw new ModelError(`Field definition "${fieldName}.type" must be defined as a string. For ex -> ${fieldName}: { type: "Boolean" }
Instead you have defined it as "${JSON.stringify(fieldTypeName, null, 2)}"`);
        }
        if ([`[`, `]`, `!`].some((char) => fieldTypeName.includes(char))) {
            throw new ModelError(`The type of field "${fieldName}" must not be an SDL string.
For example this is not allowed
  ${fieldName}: { type: "${fieldTypeName}" }
use something like the following instead
  ${fieldName}: { type: "${fieldTypeName
                .replaceAll(`[`, ``)
                .replaceAll(`]`, ``)
                .replaceAll(`!`, ``)}", required: ${fieldTypeName.includes(`!`)}${fieldTypeName.includes(`[`)
                ? `, list: ${fieldTypeName.includes(`]!`) ? `"required"` : `true`}`
                : ``} }`);
        }
        if ([`id`, `internal`, `fields`, `__typename`, `versionId`].includes(fieldName.toLowerCase())) {
            throw new ModelError(`"${fieldName}" is a built-in reserved field name and cannot be redefined, a different field name must be used.`);
        }
        if (this.isUnionType && !this.compositeTypes?.length) {
            throw new ModelError(`You must provide at least one type when defining a union. For example: define.union({ name: "MyUnion", types: ["MyType"] })`);
        }
        if (fieldDef.visitor && typeof fieldDef.visitor !== `function`) {
            throw new ModelError(`Field visitors must be defined as a function. Found ${typeof fieldDef.visitor}`);
        }
        if (`required` in fieldDef &&
            typeof fieldDef.required !== `undefined` &&
            typeof fieldDef.required !== `boolean`) {
            throw new ModelError(`The "required" property in field definitions must either be undefined or a boolean value. Found ${typeof fieldDef.required} for field ${fieldDef.name}`);
        }
    }
}
//# sourceMappingURL=definition.js.map