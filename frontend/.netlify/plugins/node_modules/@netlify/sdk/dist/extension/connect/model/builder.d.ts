import { type SourceNodesArgs } from "@netlify/content-engine";
import * as CSITypes from "@stackbit/types";
import { type ConnectorSupports, type PlatformType } from "../sdk.js";
import { type ConfiguredNetlifyConnector, type NodesApi } from "../connector-instance.js";
import { type Locale } from "../types/csi.js";
import { DefineCrossReferenceArgs, DefineDocumentArgs, DefineEnumArgs, DefineInlineEnumArgs, DefineInlineObjectArgs, DefineInlineUnionArgs, DefineNodeArgs, DefineObjectArgs, DefineUnionArgs, ModelDefinition, ModelField, ModelFields, Visitor } from "./definition.js";
import type { ModelTransformer, RuntimePlatform } from "./transformer.js";
export type Define = ModelBuilder["pluginAPI"]["define"];
export type Extend = ModelBuilder["pluginAPI"]["extend"];
export type ModelerArgs<State, Options = any> = {
    define: Define;
    extend: Extend;
    cache: SourceNodesArgs["cache"];
    state: State;
    platform: PlatformType;
    options: Options;
};
export type Modeler<State, ConfigurationOptions extends Record<string, any>> = (args: ModelerArgs<State, ConfigurationOptions>, configurationOptions: ConfigurationOptions) => Promise<void>;
export type Models = {
    [modelName: string]: ModelDefinition["dataAPI"];
    [Symbol.iterator](): IterableIterator<ModelDefinition["dataAPI"]>;
} & Record<string, ModelDefinition["dataAPI"]> & {
    concurrent(count: number, callback: (model: ModelDefinition["dataAPI"]) => Promise<void> | void): Promise<void> | void;
};
export type DynamicModels = {
    [modelName: string]: ModelDefinition["runtimeDataAPI"];
    [Symbol.iterator](): IterableIterator<ModelDefinition["runtimeDataAPI"]>;
} & Record<string, ModelDefinition["runtimeDataAPI"]> & {
    concurrent(count: number, callback: (model: ModelDefinition["runtimeDataAPI"]) => Promise<void> | void): Promise<void> | void;
};
export type ModelsIteratorObject = Models;
export type DynamicModelsIteratorObject = DynamicModels;
export type SchemaCustomizationsByInstanceID = {
    instanceIDs: {
        [id: string]: SchemaCustomizations;
    };
};
type SchemaCustomizations = {
    typeCustomizations: {
        [typeName: string]: TypeCustomization;
    };
};
type TypeCustomization = {
    authLabels?: string[];
    fieldCustomizations: FieldCustomization[];
};
type FieldCustomizationMode = "runtime";
type FieldCustomization = {
    name: string;
    authLabels?: string[];
    type: string;
    connectorName: string;
    instanceID: string;
    linkBy?: string;
    list?: boolean;
    parameters?: Record<string, any>;
    mode?: FieldCustomizationMode;
} & ModelField;
export declare class ModelBuilder {
    models: Map<string, ModelDefinition>;
    private extendedModels;
    scalarModels: Map<string, ModelDefinition>;
    transformers: Map<string, ModelTransformer>;
    modelDataAPIs: Models;
    modelRuntimeDataAPIs: DynamicModels;
    complete: boolean;
    sdl: string;
    locales: Locale[];
    localeCodes: Set<string>;
    defaultLocale?: Locale;
    schemaCustomizations?: SchemaCustomizations;
    typePrefix: string;
    nodesApi: NodesApi;
    createApi?: CSITypes.Cache;
    createId: ConfiguredNetlifyConnector["createId"];
    shouldHandleCreateSupport: ConfiguredNetlifyConnector["shouldHandleCreateSupport"];
    slug: string;
    supports: ConnectorSupports;
    instanceID: string;
    pascaledNames: Map<string, string>;
    private seenTypePaths;
    private connectorOptionsValues;
    shouldAutoRenameFieldsAndModels: boolean;
    constructor({ nodesApi, createApi, supports, slug, createId, shouldHandleCreateSupport, instanceID, connectorOptionsValues, }: {
        nodesApi: NodesApi;
        createApi?: CSITypes.Cache;
        supports: ConnectorSupports;
        slug: string;
        createId: ConfiguredNetlifyConnector["createId"];
        shouldHandleCreateSupport: ConfiguredNetlifyConnector["shouldHandleCreateSupport"];
        instanceID: string;
        connectorOptionsValues?: Record<string, any>;
    });
    getDefaultLocale(): string | undefined;
    get runtimePlatform(): RuntimePlatform;
    private defineAPI;
    private getRuntimeLoadManyResolver;
    private getRuntimeResolverContextValues;
    private getRuntimeLoadOneResolver;
    private getRuntimeFieldResolver;
    getRuntimeFieldsResolvers(): Record<string, Record<string, any>>;
    get pluginAPI(): {
        define: {
            /**
             * @warning This API is experimental. Only use if you know what you're doing.
             */
            crossReference: (args: DefineCrossReferenceArgs) => ModelDefinition;
            /**
             * Defines an enum scalar type. Enum types are used to define fields on node models where the field may only contain one of the values specified as
             * part of the type definition.
             */
            enum: (args: DefineEnumArgs) => ModelDefinition;
            /**
             * Defines an enum scalar type. Enum types are used to define fields on node models where the field may only contain one of the values specified as
             * part of the type definition.
             * Inline enum types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineEnum: (args: DefineInlineEnumArgs) => ModelDefinition;
            /**
             * Defines a document model. Documents are database records that can be queried by their ID. Defining a document model allows you to create and update records of that model type during connector.sync(fn).
             *
             * Replaces the deprecated define.nodeModel() function.
             */
            document: (args: DefineDocumentArgs) => ModelDefinition;
            /**
             * @deprecated - use define.document() instead, which is a direct replacement for this API
             */
            nodeModel: (_args: DefineNodeArgs) => never;
            /**
             * Defines an object type. Object types are used to define fields on node models.
             */
            object: (args: DefineObjectArgs) => ModelDefinition;
            /**
             * Defines an inline object type. Object types are used to define fields on node models.
             * Inline object types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineObject: (args: DefineInlineObjectArgs) => ModelDefinition;
            /**
             * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
             */
            union: (args: DefineUnionArgs) => ModelDefinition;
            /**
             * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
             * Inline union types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineUnion: (args: DefineInlineUnionArgs) => ModelDefinition;
            /**
             * @warning this is an experimental API. Only use if you know what you're doing :)
             */
            locales: (locales: Locale[]) => void;
        };
        extend: {
            Asset: (definition: {
                fields: ModelFields;
                visitor?: Visitor;
            }) => void | undefined;
        };
    };
    private get defineInternal();
    private defineInternalCreateModels;
    build({ modeler, typePrefix, cache, configurationOptions, state, shouldAutoRenameFieldsAndModels, platform, }: {
        modeler: Modeler<any, any>;
        typePrefix: string;
        cache: SourceNodesArgs["cache"];
        configurationOptions: Record<string, any>;
        state: Record<string, any>;
        shouldAutoRenameFieldsAndModels?: boolean;
        platform: PlatformType;
    }): Promise<{
        sdl: string;
    }>;
    private initializeScalarDefinitions;
    private newModelDefinition;
    getTypeCustomizations(typeName: string): TypeCustomization | undefined;
    toCreateModels(): (CSITypes.ObjectModel<unknown> | CSITypes.PageModel<unknown> | CSITypes.DataModel<unknown>)[];
    extendModel(model: ModelDefinition): this;
    addModel(model: ModelDefinition): this;
    private reset;
    private finalizeModels;
    private setSeenTypePaths;
    throwOnInvalidRuntimeParameters(): void;
    private validateModelHarmony;
    private throwOnInlineUnionMemberTypes;
    private throwOnMixedUnionListFields;
    private renamePascaledFieldTypes;
    private throwOnLocalizedFieldsWhenNoLocalesAreDefined;
    private handleMixedUnionTypes;
    private panicOnUndefinedModels;
}
export {};
//# sourceMappingURL=builder.d.ts.map