import { writeFileSync } from "fs";
import { join } from "path";
import { getGlobalConnectorInstance, } from "../connector-instance.js";
import { ModelDefinition, builtInTypes, mappedBuiltinTypes, } from "./definition.js";
import { ModelError } from "./error.js";
import * as scalar from "./transformers/scalar/index.js";
import { DocumentTransformer } from "./transformers/document.js";
import { ObjectTransformer } from "./transformers/object.js";
import { EnumTransformer } from "./transformers/enum.js";
import { UnionTransformer } from "./transformers/union.js";
import { CrossReferenceTransfromer } from "./transformers/cross-reference.js";
import { addAllCacheTag, addCacheTagsFromRuntimeObject } from "./utils.js";
export class ModelBuilder {
    models = new Map();
    extendedModels = new Map();
    scalarModels = new Map();
    transformers = new Map();
    modelDataAPIs;
    modelRuntimeDataAPIs;
    complete = false;
    sdl = ``;
    locales = [];
    localeCodes = new Set();
    defaultLocale;
    schemaCustomizations;
    typePrefix = ``;
    nodesApi;
    createApi;
    createId;
    shouldHandleCreateSupport;
    slug;
    supports;
    instanceID;
    // original -> pascal
    pascaledNames = new Map();
    seenTypePaths = new Map();
    connectorOptionsValues = {};
    shouldAutoRenameFieldsAndModels = true;
    constructor({ nodesApi, createApi, supports, slug, createId, shouldHandleCreateSupport, instanceID, connectorOptionsValues, }) {
        this.nodesApi = nodesApi;
        this.createApi = createApi;
        this.supports = supports;
        this.slug = slug;
        this.instanceID = instanceID;
        this.createId = createId;
        this.shouldHandleCreateSupport = shouldHandleCreateSupport;
        if (connectorOptionsValues) {
            this.connectorOptionsValues = connectorOptionsValues;
        }
        this.reset();
    }
    getDefaultLocale() {
        return this?.defaultLocale?.code;
    }
    get runtimePlatform() {
        return this.shouldHandleCreateSupport()
            ? `netlify-create`
            : `netlify-connect`;
    }
    defineAPI({ isInternalType, isExtendedDefinition, }) {
        return {
            /**
             * @warning This API is experimental. Only use if you know what you're doing.
             */
            crossReference: (args) => this.newModelDefinition({
                ...args,
                kind: `CrossReference`,
                isInlineType: true,
                isInternalType,
                TransformerClass: CrossReferenceTransfromer,
            }),
            /**
             * Defines an enum scalar type. Enum types are used to define fields on node models where the field may only contain one of the values specified as
             * part of the type definition.
             */
            enum: (args) => this.newModelDefinition({
                ...args,
                kind: `Enum`,
                isInternalType,
                TransformerClass: EnumTransformer,
            }),
            /**
             * Defines an enum scalar type. Enum types are used to define fields on node models where the field may only contain one of the values specified as
             * part of the type definition.
             * Inline enum types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineEnum: (args) => this.newModelDefinition({
                ...args,
                kind: `Enum`,
                isInternalType,
                isInlineType: true,
                TransformerClass: EnumTransformer,
            }),
            /**
             * Defines a document model. Documents are database records that can be queried by their ID. Defining a document model allows you to create and update records of that model type during connector.sync(fn).
             *
             * Replaces the deprecated define.nodeModel() function.
             */
            document: (args) => this.newModelDefinition({
                ...args,
                kind: `Node`,
                isInternalType,
                isExtendedDefinition,
                TransformerClass: DocumentTransformer,
            }),
            /**
             * @deprecated - use define.document() instead, which is a direct replacement for this API
             */
            nodeModel: (_args) => {
                throw new Error(`define.nodeModel() has been deprecated and renamed to define.document(). They work identically, but the deprecated method no longer works.`);
            },
            /**
             * Defines an object type. Object types are used to define fields on node models.
             */
            object: (args) => this.newModelDefinition({
                ...args,
                kind: `Object`,
                isInternalType,
                TransformerClass: ObjectTransformer,
            }),
            /**
             * Defines an inline object type. Object types are used to define fields on node models.
             * Inline object types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineObject: (args) => this.newModelDefinition({
                ...args,
                kind: `Object`,
                isInternalType,
                isInlineType: true,
                TransformerClass: ObjectTransformer,
            }),
            /**
             * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
             */
            union: (args) => this.newModelDefinition({
                ...args,
                kind: `Union`,
                isInternalType,
                TransformerClass: UnionTransformer,
            }),
            /**
             * Defines a union type. Union types are used to define fields on node models where the field may be of multiple different types.
             * Inline union types are identical to object types, but do not require a name. The name will be generated by hashing the definition.
             */
            inlineUnion: (args) => this.newModelDefinition({
                ...args,
                kind: `Union`,
                isInternalType,
                isInlineType: true,
                TransformerClass: UnionTransformer,
            }),
            /**
             * @warning this is an experimental API. Only use if you know what you're doing :)
             */
            locales: (locales) => {
                if (!Array.isArray(locales) || locales.length === 0) {
                    return;
                }
                const defaultLocales = locales.filter((l) => l.default);
                if (defaultLocales.length > 1) {
                    throw new ModelError(`More than one default locale found. Only one default locale is allowed.`);
                }
                if (defaultLocales.length === 0) {
                    // No default locale found, so set the first locale as default
                    locales[0].default = true;
                    this.defaultLocale = locales[0];
                }
                else {
                    this.defaultLocale = defaultLocales[0];
                }
                this.locales = locales;
                for (const locale of this.locales) {
                    this.localeCodes.add(locale.code);
                }
            },
        };
    }
    getRuntimeLoadManyResolver(modelField, parentTypeName) {
        const loadMany = modelField.type.loadMany;
        if (typeof loadMany !== `function` && typeof loadMany !== `boolean`) {
            throw new Error(`Type ${modelField.type.getTypeName()} is set to "runtime". No loadMany function was set, but is required for runtime models. If you want to omit this, explicitly opt out with "loadMany: false"`);
        }
        if (!loadMany) {
            return false;
        }
        const loader = modelField.type.dataLoader;
        const resolve = async (source, _args, context) => {
            if (!modelField.type.loadMany) {
                throw new Error(`Executing a resolver for runtime object type ${modelField.type.getTypeName()} on list field "${modelField.name}" but the "loadMany" function doesn't exist. This is a Netlify SDK bug.`);
            }
            const resolvedValue = await modelField.type.loadMany({
                source,
                ...this.getRuntimeResolverContextValues(source, modelField.type, parentTypeName),
                load: loader
                    ? (key) => loader.load(key)
                    : async (key) => {
                        throw new Error(`Can't call load(${key}) from type ${modelField.type.prefixedTypeName()} in field ${modelField.name} as no ${modelField.type.prefixedTypeName()}.batchMany() function is defined.`);
                    },
            });
            if (!resolvedValue) {
                return null;
            }
            if (!Array.isArray(resolvedValue)) {
                throw new Error(`Expected a list value but found ${typeof resolvedValue}`);
            }
            resolvedValue.forEach((val) => {
                addCacheTagsFromRuntimeObject(val, context, modelField.type.prefixedTypeName(), modelField.type.cacheKeyField);
            });
            addAllCacheTag(modelField.type.prefixedTypeName(), context);
            const transformedData = resolvedValue.map((v) => {
                if (v === null)
                    return v;
                const preparedValue = modelField.type.prepareNode(v);
                switch (this.runtimePlatform) {
                    case "netlify-connect":
                        return preparedValue;
                    case "netlify-create":
                        return preparedValue.fields;
                }
            });
            return transformedData;
        };
        return resolve;
    }
    getRuntimeResolverContextValues = (source, modelDef, parentTypeName) => {
        const typeCustomization = modelDef.ModelBuilder.getTypeCustomizations(parentTypeName) ||
            // Netlify UI sends customizations that include the prefix
            modelDef.ModelBuilder.getTypeCustomizations(`${modelDef.ModelBuilder.typePrefix}${parentTypeName}`);
        const fieldCustomization = typeCustomization?.fieldCustomizations?.find((fieldCustomization) => fieldCustomization.type === modelDef.getTypeName());
        // This will only happen if we add a runtime object to a model in the connector itself
        // Otherwise the validation for runtime objects happen at build time.
        if (!fieldCustomization) {
            return { parameters: {}, options: this.connectorOptionsValues };
        }
        const connector = getGlobalConnectorInstance(fieldCustomization.connectorName, fieldCustomization.instanceID);
        const options = connector?.optionsValues;
        if (!options) {
            throw new Error(`Couldn't access connector options. This is a Netlify SDK bug.`);
        }
        const parameters = modelDef?.parameters.reduce((acc, param) => {
            const paramName = param.name;
            const sourceFieldNameMapping = fieldCustomization &&
                fieldCustomization.parameters &&
                fieldCustomization.parameters[paramName];
            const fieldValue = fieldCustomization && fieldCustomization.parameters
                ? source[sourceFieldNameMapping]
                : undefined;
            if (!fieldValue && param.required) {
                throw Error(`Missing parameter value for ${paramName}`);
            }
            if (fieldValue) {
                // TODO make localized fields work
                if (this.runtimePlatform === "netlify-create") {
                    acc[paramName] = fieldValue.value;
                }
                else {
                    acc[paramName] = fieldValue;
                }
            }
            return acc;
        }, {});
        return { parameters, options };
    };
    getRuntimeLoadOneResolver(modelField, parentTypeName) {
        const loadOne = modelField.type.loadOne;
        if (typeof loadOne !== `function` && typeof loadOne !== `boolean`) {
            throw new Error(`Type ${modelField.type.getTypeName()} is set to "runtime". No loadOne function was set, but is required for runtime models. If you want to omit this, explicitly opt out with "loadOne: false"`);
        }
        if (!loadOne) {
            return false;
        }
        const loader = modelField.type.dataLoader;
        const resolve = async (source, _args, context) => {
            if (!modelField.type.loadOne) {
                throw new Error(`Executing a resolver for runtime object type ${modelField.type.getTypeName()} on field "${modelField.name}" but the "loadOne" function doesn't exist. This is a Netlify SDK bug.`);
            }
            const resolvedValue = await modelField.type.loadOne({
                source,
                ...this.getRuntimeResolverContextValues(source, modelField.type, parentTypeName),
                load: loader
                    ? (key) => loader.load(key)
                    : async (key) => {
                        throw new Error(`Can't call load(${key}) from type ${modelField.type.prefixedTypeName()} in field ${modelField.name} as no ${modelField.type.prefixedTypeName()}.batchMany() function is defined.`);
                    },
            });
            addCacheTagsFromRuntimeObject(resolvedValue, context, modelField.type.prefixedTypeName(), modelField.type.cacheKeyField);
            addAllCacheTag(modelField.type.prefixedTypeName(), context);
            const transformedData = modelField.type.prepareNode(resolvedValue);
            switch (this.runtimePlatform) {
                case "netlify-connect":
                    return transformedData;
                case "netlify-create":
                    return transformedData.fields;
            }
        };
        return resolve;
    }
    getRuntimeFieldResolver(modelField, parentTypeName) {
        switch (modelField.list) {
            case undefined:
            case false: {
                const resolve = this.getRuntimeLoadOneResolver(modelField, parentTypeName);
                if (resolve) {
                    // this is the resolver definition that content-engine will use to add this runtime resolver to the schema
                    return {
                        type: modelField.type.ModelTransformer.modelFieldToGraphQlFieldType(modelField),
                        resolve,
                    };
                }
                break;
            }
            case "required":
            case true: {
                const resolve = this.getRuntimeLoadManyResolver(modelField, parentTypeName);
                if (resolve) {
                    // this is the resolver definition that content-engine will use to add this runtime resolver to the schema
                    return {
                        type: modelField.type.ModelTransformer.modelFieldToGraphQlFieldType(modelField),
                        resolve,
                    };
                }
                break;
            }
        }
    }
    getRuntimeFieldsResolvers() {
        let runtimeFieldResolvers = {};
        for (const definition of this.models.values()) {
            const typeName = definition.prefixedTypeName();
            const unprefixedTypeName = definition.getTypeName();
            let resolvers = false;
            for (const field of definition.fields || []) {
                const modelField = definition.resolveModelField(field, definition);
                if (modelField.type.runtime) {
                    if (!resolvers)
                        resolvers = {};
                    if (!resolvers[typeName])
                        resolvers[typeName] = {};
                    // this is the resolver definition that content-engine will use to add this runtime resolver to the schema
                    resolvers[typeName][field.name] = this.getRuntimeFieldResolver(modelField, unprefixedTypeName);
                }
            }
            if (resolvers) {
                runtimeFieldResolvers = {
                    ...runtimeFieldResolvers,
                    ...resolvers,
                };
            }
        }
        return runtimeFieldResolvers;
    }
    get pluginAPI() {
        return {
            define: this.defineAPI({ isInternalType: false }),
            extend: {
                Asset: (definition) => {
                    // for now only allow extending the builtin Asset model
                    const extended = this.defineAPI({
                        // not an internal type since the connector dev is adding this extended definition
                        isInternalType: false,
                        isExtendedDefinition: true,
                    }).document({
                        name: `Asset`,
                        fields: definition.fields,
                        visitor: definition.visitor,
                    });
                    return this.models
                        .get(`Asset`)
                        ?._mergeExtendedDefinition(extended, this);
                },
            },
        };
    }
    get defineInternal() {
        return this.defineAPI({ isInternalType: true });
    }
    defineInternalCreateModels() {
        this.defineInternal.enum({
            name: `StatusEnum`,
            values: [`published`, `added`, `modified`],
        });
        this.defineInternal.document({
            name: `Asset`,
            editor: {
                label: `Asset`,
            },
            fields: {
                title: {
                    type: `String`,
                    required: true,
                },
                url: {
                    type: `String`,
                    required: true,
                },
                fileName: {
                    type: `String`,
                },
                contentType: {
                    type: `String`,
                },
                size: {
                    type: `Int`,
                },
                width: {
                    type: `Int`,
                },
                height: {
                    type: `Int`,
                },
            },
        });
        this.defineInternal.enum({
            name: "ScheduledActionAction",
            values: ["publish", "unpublish"],
        });
        this.defineInternal.enum({
            name: "ScheduledActionState",
            values: ["cancelled", "executing", "failed", "scheduled", "succeeded"],
        });
        this.defineInternal.document({
            name: "ScheduledAction",
            fields: {
                name: {
                    type: "String",
                    required: true,
                },
                action: {
                    type: "ScheduledActionAction",
                    required: true,
                },
                state: {
                    type: "ScheduledActionState",
                    required: true,
                },
                executeAt: {
                    type: "Date",
                    required: true,
                },
                documentIds: {
                    type: "String",
                    required: true,
                    list: true,
                },
            },
        });
    }
    async build({ modeler, typePrefix, cache, configurationOptions, state, shouldAutoRenameFieldsAndModels, platform, }) {
        this.reset();
        this.typePrefix = typePrefix;
        this.shouldAutoRenameFieldsAndModels =
            typeof shouldAutoRenameFieldsAndModels === `undefined`
                ? true
                : shouldAutoRenameFieldsAndModels;
        this.defineInternalCreateModels();
        this.initializeScalarDefinitions();
        try {
            const { define, extend } = this.pluginAPI;
            await modeler({
                define,
                extend,
                cache,
                state,
                platform,
                options: configurationOptions,
            }, configurationOptions);
        }
        catch (e) {
            console.warn(`Encountered errors while running the connector.model() API:`);
            console.error(e);
            process.exit(1);
        }
        this.validateModelHarmony();
        this.complete = true;
        this.finalizeModels();
        return {
            sdl: this.sdl,
        };
    }
    initializeScalarDefinitions() {
        this.scalarModels.clear();
        const scalars = [
            [`String`, scalar.StringTransformer],
            [`Slug`, scalar.SlugTransformer],
            [`Html`, scalar.HtmlTransformer],
            [`Color`, scalar.ColorTransformer],
            [`Text`, scalar.TextTransformer],
            [`Markdown`, scalar.MarkdownTransformer],
            [`JSON`, scalar.JSONTransformer],
            [`richText`, scalar.RichTextTransformer],
            [`Url`, scalar.UrlTransformer],
            [`Date`, scalar.DateTransformer],
            [`DateTime`, scalar.DateTimeTransformer],
            [`Boolean`, scalar.BooleanTransformer],
            [`Float`, scalar.FloatTransformer],
            [`Int`, scalar.IntegerTranformer],
            [`ID`, scalar.IDTransformer],
        ];
        for (const [name, TransformerClass] of scalars) {
            this.newModelDefinition({
                name,
                kind: `Scalar`,
                TransformerClass,
                isInternalType: true,
            });
        }
    }
    newModelDefinition(input) {
        const { nodesApi, createApi, shouldAutoRenameFieldsAndModels, supports, runtimePlatform, } = this;
        return new ModelDefinition({
            ...input,
            createId: this.createId,
            ModelBuilder: this,
            nodesApi,
            createApi,
            shouldAutoRenameFieldsAndModels,
            supports,
            runtimePlatform,
        });
    }
    getTypeCustomizations(typeName) {
        return this.schemaCustomizations?.typeCustomizations?.[typeName];
    }
    toCreateModels() {
        const createModels = [];
        if (!this.complete) {
            throw new Error(`Cannot generate Create models before ModelBuilder has built its internal models via ModelBuilder.build()`);
        }
        this.models.forEach((model) => {
            const createModel = model.toCreateModel();
            if (createModel)
                createModels.push(createModel);
        });
        if (process.env.NODE_ENV === `development`) {
            // write out stackbit types to a file for debugging
            writeFileSync(join(process.cwd(), `.ntli/netlify-create-types.json`), JSON.stringify(createModels, null, 2));
        }
        return createModels;
    }
    extendModel(model) {
        const typeName = model.getTypeName();
        this.extendedModels.set(typeName, model);
        return this;
    }
    // called by the ModelDefinition constructor for all new models that are created while modelDefiner is running in this.build()
    addModel(model) {
        const typeName = model.getTypeName();
        const existingDefinition = this.models.get(typeName);
        // inline types are allowed to be redefined any number of times - their type name is a hash of their definition
        // so it's impossible for them to conflict with other types
        if (existingDefinition && existingDefinition?.isInlineType) {
            return this;
        }
        if (existingDefinition &&
            existingDefinition.isInternalType &&
            existingDefinition.getTypeName() === `ScheduledAction`) {
            throw new ModelError(`The "ScheduledAction" model is a builtin model and cannot be redefined.`);
        }
        if (existingDefinition &&
            existingDefinition.isInternalType &&
            existingDefinition.getTypeName() === `Asset`) {
            throw new ModelError(`The "Asset" model is a builtin model and cannot be redefined. You can extend it with additional fields using the extend API:
connector.model(({ extend }) => {
  extend.Asset({
    fields: {
      newField: {
        type: "String",
        required: true,
      },
    },
  });
});`);
        }
        else if (existingDefinition && existingDefinition.isInternalType) {
            throw new ModelError(`Model name "${typeName}" is a reserved model name and cannot be redefined. Please choose a different name.`);
        }
        else if (existingDefinition) {
            throw new Error(`Model with name "${typeName}" was defined more than once. Model names must be unique. The first definition was:\n\n${existingDefinition.toSDL()}`);
        }
        // TODO: these are only separate temporarily while ModelTransformers are being added
        // we're adding scalar models first, with transformers, since no recursion is needed for scalar transformers
        // we'll then follow up and make all models use transformers
        if (model.isScalarType) {
            this.scalarModels.set(typeName, model);
        }
        else {
            this.models.set(typeName, model);
        }
        if (model.isNodeType) {
            this.modelDataAPIs[typeName] = model.dataAPI;
            // add keys with original input name, ie if name was product_categories, the
            // model name is ProductCategories, but the connector will likely need to fetch
            // and insert data with the original product_categories name
            if (model.getOriginalName() !== typeName) {
                this.modelDataAPIs[model.getOriginalName()] = model.dataAPI;
            }
        }
        else if (model.runtime) {
            this.modelRuntimeDataAPIs[typeName] = model.runtimeDataAPI;
            if (model.getOriginalName() !== typeName) {
                this.modelRuntimeDataAPIs[model.getOriginalName()] =
                    model.runtimeDataAPI;
            }
        }
        return this;
    }
    reset() {
        this.locales = [];
        this.pascaledNames = new Map();
        this.models = new Map();
        this.extendedModels = new Map();
        this.seenTypePaths = new Map();
        this.modelDataAPIs = {
            async concurrent(count, modelCallback) {
                if (typeof count !== `number`) {
                    throw new ModelError(`models.concurrent(arg1) must be a number`);
                }
                if (count < 1) {
                    throw new ModelError(`models.concurrent(arg1) must be a positive number`);
                }
                if (Math.round(count) !== count) {
                    throw new ModelError(`models.concurrent(arg1) must be a whole number`);
                }
                const models = Array.from(this);
                const slots = Array(count).fill(null);
                function runNextModelInSlot() {
                    const model = models.pop();
                    if (!model)
                        return;
                    const mbePromise = modelCallback(model);
                    if (mbePromise && `then` in mbePromise) {
                        return mbePromise.then(runNextModelInSlot);
                    }
                    else {
                        return runNextModelInSlot();
                    }
                }
                await Promise.all(slots.map(runNextModelInSlot));
            },
        };
        this.modelRuntimeDataAPIs = {
            async concurrent(count, modelCallback) {
                if (typeof count !== `number`) {
                    throw new ModelError(`dynamicModels.concurrent(arg1) must be a number`);
                }
                if (count < 1) {
                    throw new ModelError(`dynamicModels.concurrent(arg1) must be a positive number`);
                }
                if (Math.round(count) !== count) {
                    throw new ModelError(`dynamicModels.concurrent(arg1) must be a whole number`);
                }
                const models = Array.from(this);
                const slots = Array(count).fill(null);
                function runNextModelInSlot() {
                    const model = models.pop();
                    if (!model)
                        return;
                    const mbePromise = modelCallback(model);
                    if (mbePromise && `then` in mbePromise) {
                        return mbePromise.then(runNextModelInSlot);
                    }
                    else {
                        return runNextModelInSlot();
                    }
                }
                await Promise.all(slots.map(runNextModelInSlot));
            },
        };
        Object.defineProperty(this.modelDataAPIs, Symbol.iterator, {
            value: function* () {
                for (const [name, model] of Object.entries(this)) {
                    if (typeof model === "function")
                        continue; // skip the iterator
                    if (`concurrent` === name)
                        continue; // skip non-model methods
                    if (name === model?.originalName && model.name !== model.originalName)
                        continue; // skip any original name models, these are duplicates added by original name for convinience
                    if (name === `Asset` || name === `ScheduledAction`)
                        continue; // skip builtin models that weren't defined by the connector
                    yield model;
                }
            },
            enumerable: false,
        });
        Object.defineProperty(this.modelRuntimeDataAPIs, Symbol.iterator, {
            value: function* () {
                for (const [name, model] of Object.entries(this)) {
                    if (typeof model === "function")
                        continue; // skip the iterator
                    if (`concurrent` === name)
                        continue; // skip non-model methods
                    if (name === model?.originalName && model.name !== model.originalName)
                        continue; // skip any original name models, these are duplicates added by original name for convinience
                    yield model;
                }
            },
            enumerable: false,
        });
        this.complete = false;
        this.sdl = ``;
    }
    finalizeModels() {
        this.sdl = ``;
        this.models.forEach((model) => {
            model.buildWalker();
            this.sdl += `${model.toSDL()}\n\n`;
        });
        this.scalarModels.forEach((model) => {
            const sdl = model.toSDL();
            if (sdl) {
                this.sdl += `${sdl}\n\n`;
            }
        });
        this.sdl = this.sdl.trim();
    }
    // used to track which types have been referenced by other types so we can throw errors (with helpful paths) for undefined types after building models
    setSeenTypePaths() {
        this.models.forEach((model) => {
            const modelTypeName = model.getTypeName();
            if (!this.seenTypePaths.has(modelTypeName)) {
                this.seenTypePaths.set(modelTypeName, [modelTypeName]);
            }
            for (const compositeType of model?.compositeTypes || []) {
                const compositeTypename = model.getDefinedTypeName(compositeType);
                if (!this.seenTypePaths.has(compositeTypename)) {
                    this.seenTypePaths.set(compositeTypename, []);
                }
                this.seenTypePaths.get(compositeTypename).push(`union ${modelTypeName} = ${compositeTypename} | ...`);
            }
            for (const fieldDefinition of model.getFields()) {
                const fieldName = fieldDefinition.name;
                const typeName = model.getDefinedTypeName(fieldDefinition.type, fieldName);
                if (!this.seenTypePaths.has(typeName)) {
                    this.seenTypePaths.set(typeName, []);
                }
                // store a backreference to this type. IE if the field is One.fieldA and fieldA has type Two, then
                // Two => ['One.fieldA', 'OtherType.fieldSomething'] is stored where we keep a list of every place that references this type
                this.seenTypePaths.get(typeName).push(`${modelTypeName}.${fieldName}`);
            }
        });
    }
    throwOnInvalidRuntimeParameters() {
        for (const model of this.models.values()) {
            const typeCustomization = this.getTypeCustomizations(model.getTypeName()) ||
                // Netlify UI sends customizations that include the prefix
                this.getTypeCustomizations(model.prefixedTypeName());
            const fieldCustomizations = typeCustomization?.fieldCustomizations?.filter((fieldCustomization) => fieldCustomization.mode === "runtime");
            if (!fieldCustomizations)
                continue;
            fieldCustomizations.forEach((fieldCustomization) => {
                if (!fieldCustomization.parameters)
                    return;
                const connector = getGlobalConnectorInstance(fieldCustomization.connectorName, fieldCustomization.instanceID);
                const runtimeModel = connector?.ModelBuilder.models.get(fieldCustomization.type);
                if (!runtimeModel) {
                    throw new ModelError(`Runtime model "${fieldCustomization.type}" does not exist on connector "${fieldCustomization.connectorName}"`);
                }
                const runtimeModelParams = runtimeModel.parameters;
                Object.entries(fieldCustomization.parameters).forEach(([runtimeModelParamName, mappedFieldName]) => {
                    const field = model.fieldsMap.get(mappedFieldName);
                    if (!field) {
                        throw new Error(`Runtime parameter ${runtimeModelParamName} mapped to field "${mappedFieldName}" does not exist on model "${model.getTypeName()}".`);
                    }
                    const fieldType = model.getDefinedTypeName(field.type);
                    const runtimeModelParam = runtimeModelParams?.find((param) => param.name === runtimeModelParamName);
                    if (runtimeModelParam && !runtimeModelParam.kind) {
                        // need to default to builtin types so that types like number or Float aren't prefixed
                        runtimeModelParam.kind = `prefer-builtin`;
                    }
                    if (!runtimeModelParam) {
                        throw new Error(`Runtime parameter ${runtimeModelParamName} does not exist on model "${runtimeModel?.getTypeName()}".`);
                    }
                    const resolvedParamField = runtimeModel.resolveModelField(runtimeModelParam, runtimeModel);
                    const resolvedModelField = model.resolveModelField(field, model);
                    const fieldSdl = model.ModelTransformer.modelFieldToGraphQlFieldType({
                        ...resolvedModelField,
                        required: 
                        // allow nullable params to accept non-null field inputs
                        // If the input is Float! and the parameter is Float that works, but an input of Float for a parameter of Float! is no good because the code will assume the parameter cannot be null
                        // while the input can be null.
                        // So allow non-null inputs on null parameters, but don't allow nullable inputs on non-null parameters.
                        resolvedModelField.required && !resolvedParamField.required
                            ? false
                            : resolvedModelField.required,
                        list: 
                        // allow nullable field list parameters to accept non-null list field inputs
                        resolvedModelField.list &&
                            resolvedModelField.list === `required` &&
                            resolvedParamField.list &&
                            resolvedParamField.list !== `required`
                            ? true
                            : resolvedModelField.list,
                    });
                    const runtimeParamSdl = runtimeModel.ModelTransformer.modelFieldToGraphQlFieldType(resolvedParamField);
                    // compare SDL representations to make sure the input is compatible with the parameter definition.
                    // for ex Float and [Float] aren't compatible (hence why we can't just compare the type names of inputs/parameters)
                    // Other examples of comparisons would be
                    // Float !== Float!
                    // [Float] !== [Float!]!
                    // PrefixedCustomFloat !== Float
                    // String !== Float
                    // etc
                    if (fieldSdl !== runtimeParamSdl) {
                        throw new Error(`Mapped runtime field "${model.getTypeName()}.${field.name}" is of type "${fieldType}" but runtime parameter expects "${runtimeModelParamName}" to be of type "${resolvedParamField.type.getTypeName()}".`);
                    }
                });
            });
        }
    }
    validateModelHarmony() {
        this.renamePascaledFieldTypes();
        this.setSeenTypePaths();
        this.panicOnUndefinedModels();
        this.handleMixedUnionTypes();
        this.throwOnLocalizedFieldsWhenNoLocalesAreDefined();
        this.throwOnMixedUnionListFields();
        this.throwOnInlineUnionMemberTypes();
        this.throwOnInvalidRuntimeParameters();
    }
    // "inline" types are types where the typename is a hash of the type definition.
    // these types shouldn't be used in unions because the __typename can't be set when inserting documents, and the query isn't predictable when querying (... on InlineObject_432j32kl) as the hash may change - which will then require all client queries to be updated to continue working
    throwOnInlineUnionMemberTypes() {
        for (const model of this.models.values()) {
            if (!model.isUnionType)
                continue;
            for (const type of model?.compositeTypes || []) {
                const typeName = model.getDefinedTypeName(type);
                if (this.models.get(typeName)?.isInlineType) {
                    throw new ModelError(`Inline types cannot be used in unions. The type "${typeName}" is an inline type and is used in a union in "${model.getTypeName()}"`);
                }
            }
        }
    }
    throwOnMixedUnionListFields() {
        // this limitation only applies if the connector is running inside Netlify Create
        if (this.runtimePlatform !== `netlify-create`)
            return;
        for (const [, model] of this.models) {
            for (const [, field] of model.fieldsMap) {
                const fieldModel = this.models.get(model.getDefinedTypeName(field.type));
                if (!fieldModel)
                    continue;
                if (fieldModel.isMixedUnion && !field.list) {
                    throw new ModelError(`Mixed unions (documents and objects) are only supported when they're used in list fields. A non-list field with a mixed union type exists as "${model.getTypeName()}.${field.name}"`);
                }
            }
        }
    }
    renamePascaledFieldTypes() {
        if (!this.pascaledNames.size) {
            return;
        }
        for (const model of this.models.values()) {
            // pascal union/interface type references
            if (model.compositeTypes) {
                let index = -1;
                for (const type of model.compositeTypes) {
                    index++;
                    // Definition objects don't need to be renamed here, only rename strings
                    if (typeof type !== `string`)
                        continue;
                    const pascaled = this.pascaledNames.get(type);
                    if (pascaled) {
                        model.compositeTypes[index] = pascaled;
                        model.compositeTypesSet.delete(type);
                        model.compositeTypesSet.add(pascaled);
                    }
                }
            }
            for (const def of Object.values(model.fields)) {
                const pascaled = this.pascaledNames.get(model.getDefinedTypeName(def.type));
                if (pascaled) {
                    def.type = pascaled;
                }
            }
        }
    }
    throwOnLocalizedFieldsWhenNoLocalesAreDefined() {
        if (this.locales.length > 0)
            return;
        for (const model of this.models.values()) {
            for (const field of model.getFields()) {
                if (field.localized) {
                    throw new ModelError(`Field ${model.getTypeName()}.${field.name}.localized is set to true, but this connector has not defined any locales. Fields cannot be localized unless locales are defined.

Example:

connector.model(({ define }) => {
  define.locales([
    { code: "en-US", default: true },
    { code: "ca-FR" }
  ])
})`);
                }
            }
        }
    }
    handleMixedUnionTypes() {
        for (const model of this.models.values()) {
            if (model.isUnionType && model.compositeTypes) {
                const foundTypes = {
                    node: [],
                    object: [],
                    union: [],
                    scalar: [],
                };
                for (const type of model.compositeTypes) {
                    const typename = model.getDefinedTypeName(type);
                    if (builtInTypes.has(typename)) {
                        foundTypes.scalar.push(typename);
                        continue;
                    }
                    const fullType = this.models.get(typename);
                    if (!fullType)
                        continue;
                    if (fullType.isObjectType)
                        foundTypes.object.push(typename);
                    if (fullType.isNodeType)
                        foundTypes.node.push(typename);
                    if (fullType.isUnionType)
                        foundTypes.union.push(typename);
                }
                if (foundTypes.object.length && foundTypes.scalar.length) {
                    throw new ModelError(`Object and scalar types cannot be mixed in a union. Found: ${[
                        ...foundTypes.object,
                        ...foundTypes.scalar,
                    ].join(`, `)} types in ${model.getTypeName()}`);
                }
                if (foundTypes.node.length && foundTypes.scalar.length) {
                    throw new ModelError(`Node and scalar types cannot be mixed in a union. Found: ${[
                        ...foundTypes.node,
                        ...foundTypes.scalar,
                    ].join(`, `)} types in ${model.getTypeName()}`);
                }
                const isMixedUnion = foundTypes.node.length && foundTypes.object.length;
                if (isMixedUnion) {
                    model.setIsMixedUnion();
                }
                if (foundTypes.node.length) {
                    model.setIsNodeUnion();
                }
            }
        }
    }
    panicOnUndefinedModels() {
        const undefinedModelErrors = new Map();
        for (const [seenTypeName, sdlPaths] of this.seenTypePaths.entries()) {
            if (!this.models.has(seenTypeName) &&
                !builtInTypes.has(seenTypeName) &&
                !mappedBuiltinTypes.has(seenTypeName)) {
                if (!undefinedModelErrors.has(seenTypeName)) {
                    undefinedModelErrors.set(seenTypeName, new Set());
                }
                for (const sdlPath of sdlPaths) {
                    undefinedModelErrors.get(seenTypeName).add(sdlPath);
                }
            }
        }
        if (undefinedModelErrors.size > 0) {
            const errorMessages = Array.from(undefinedModelErrors.entries()).map(([typeName, sdlPaths]) => {
                return `Undefined type "${typeName}", referenced on type fields:\n\n${Array.from(sdlPaths.keys())
                    .map((sdlPath) => {
                    return ` - ${sdlPath}`;
                })
                    .join(`\n`)}\n`;
            });
            errorMessages.forEach((message) => {
                console.error(message);
            });
            if (undefinedModelErrors.size > 1) {
                console.error(`There were ${undefinedModelErrors.size} referenced type names which haven't been defined. Either your plugin has a typo or there are types which haven't been defined yet using the connector.model(({ define }) => {}) API.\n`);
            }
            else {
                console.error(`There was 1 referenced type name which hasn't been defined. Either your plugin has a typo or there is a type which hasn't been defined yet using the connector.model(({ define }) => {}) API.\n`);
            }
            setTimeout(() => {
                // leave a little time for large errors to print
                process.exit(1);
            }, 100);
        }
    }
}
//# sourceMappingURL=builder.js.map