import path from "path";
import { writeFile } from "fs/promises";
import { DateTimeTypeDefinition } from "graphql-scalars";
import chalk from "chalk";
import { builtInStackbitStringTypes } from "../model/definition.js";
import { ModelError } from "../model/error.js";
import { delayedExit } from "../utils/delayed-exit.js";
import { getRemoteGraphQLSchemaFn } from "../utils/get-remote-graphql-schema.js";
import { BridgePluginAPI } from "./bridge.js";
import { DirectiveLocation } from "graphql";
// the internal source plugin calls APIs on this class to interact with the connector
// the methods on this class are content-engine/Gatsby APIs
export class SourcePluginBridgeAPI extends BridgePluginAPI {
    contentEngineCache;
    async onPluginInit(helpers, pluginOptions) {
        const startTime = Date.now();
        const connector = this.runningConnector;
        const { cache } = helpers;
        this.contentEngineCache = {
            get: cache.get.bind(cache),
            set: cache.set.bind(cache),
            delete: cache.del.bind(cache),
        };
        await connector.setOptionsValues(pluginOptions);
        await connector._initialize();
        // Customizations are used to customize the schema through a config generated in the Connect UI
        const schemaCustomizations = process.env.OVERRIDE_SCHEMA_CUSTOMIZATIONS ||
            connector.optionsValues?.schemaCustomizations ||
            ``;
        if (schemaCustomizations) {
            const customizationsParsed = JSON.parse(schemaCustomizations);
            const customizationsForInstance = customizationsParsed?.instanceIDs?.[connector.optionsValues.instanceID];
            if (customizationsForInstance) {
                // Definition class will query these from the builder instance which is added to each Definition instance
                connector.ModelBuilder.schemaCustomizations = customizationsForInstance;
            }
        }
        this.log(`initialized ${chalk.blue(`${(Date.now() - startTime).toString()}ms`)}`);
    }
    createResolvers({ createResolvers, emitter, store, }) {
        const resolverDefinitions = this.runningConnector.ModelBuilder.getRuntimeFieldsResolvers();
        if (Object.keys(resolverDefinitions).length > 0) {
            const connectorPlugin = store.getState().flattenedPlugins.find((plugin) => this.runningConnector.instanceID === plugin.pluginOptions?.instanceID);
            if (!connectorPlugin) {
                throw new Error(`InstanceID is needed for dynamic objects. Could not find plugin with instanceID ${this.runningConnector.instanceID}. Please set the instanceID for your ${this.runningConnector.slug} connector.`);
            }
            emitter.emit("LEDGER_DEPENDENCY_MANAGER_SHOULD_INSTALL_DYNAMIC_CONNECTOR", {
                plugin: connectorPlugin,
            });
            createResolvers(resolverDefinitions);
        }
    }
    /**
     * content-engine / Gatsby API - will be called by internal source plugin
     */
    async createSchemaCustomization(schemaCustomizationApi) {
        const connector = this.runningConnector;
        if (connector.proxiedSchemas.length) {
            await Promise.all(connector.proxiedSchemas?.map(async (fn) => {
                const schema = (await fn({
                    options: connector.optionsValues,
                    typePrefix: connector.config.typePrefix,
                    state: connector.initState,
                    getRemoteGraphQLSchema: getRemoteGraphQLSchemaFn(connector.config.typePrefix),
                }));
                schemaCustomizationApi.actions.addThirdPartySchema({
                    schema,
                });
            }));
        }
        schemaCustomizationApi.actions.createTypes(Array.from(builtInStackbitStringTypes.keys()).map((name) => schemaCustomizationApi.schema.buildScalarType({
            name,
            description: `Netlify visual editor ${name} String type`,
        })));
        const directivesEnvVarValue = process.env.DATA_LAYER_AUTHORIZATION_LABELS;
        if (typeof directivesEnvVarValue === `string` &&
            process.env.AUTH_LABELS_SET !== `true`) {
            // only add to schema customization one time. Multiple connectors will run this code
            process.env.AUTH_LABELS_SET = `true`;
            schemaCustomizationApi.actions.createTypes(`
        enum DATA_LAYER_AUTHORIZATION_LABELS {
          ${directivesEnvVarValue.split(`,`).join(`\n`)}
        }
    `);
        }
        schemaCustomizationApi.actions.createTypes(DateTimeTypeDefinition);
        const { connect } = connector.getAPIPromises("model");
        const startTime = Date.now();
        const { sdl } = await connector._buildDefinedModels(schemaCustomizationApi.cache);
        if (sdl)
            schemaCustomizationApi.actions.createTypes(sdl);
        if (
        // if there are locales
        this.runningConnector.ModelBuilder.locales.length > 0) {
            const state = schemaCustomizationApi.store.getState();
            const { fieldExtensions } = state.schemaCustomization;
            // only define the @localized field schema directive once across all connector instances
            // if we need to change how @localized works, we need to make an @localizedv2 because connector
            // instances may all be on different SDK versions and we can't retroactively change how they expect @localized to work
            // @localized needs to be defined here and not in content-engine because if we add @localized to the schema but it isn't
            // defined (ie in production Connect which may be running Gatsby or an older content-engine version), the GraphQL schema
            // will not build. so we define it one time and check every time if it's already been defined
            if (!fieldExtensions?.localized) {
                // instead of schemaCustomizationApi.actions.createFieldExtension, dispatch directly
                // Connect doesn't implement createFieldExtension, and that function just dispatches the following anyway:
                schemaCustomizationApi.store.dispatch({
                    type: `CREATE_FIELD_EXTENSION`,
                    payload: {
                        // @localized() defines how a field is localized, it's different than the client side directive @locale which comes over in gql queries.
                        // this directive is so the server can understand how each field can be resolved when handling a query containing @locale
                        // This is added here rather than in content-engine so that we don't also need to update Gatsby to support this.
                        // Production connect still uses Gatsby for now.
                        name: "localized",
                        extension: {
                            locations: [DirectiveLocation.FIELD_DEFINITION],
                            args: {
                                // ex codes: ["en-US", "ca-FR"]
                                codes: {
                                    type: "[String]",
                                },
                                // ex codesProxyFrom: ["fieldName.locales.en-US.value", etc
                                // since CREATE_FIELD_EXTENSION doesn't support complex input types for field extensions (object inputs)
                                // we just create 2 string arrays where the index between each is correlated.
                                // ie codes[0] maps to codesProxyFrom[0]
                                codesProxyFrom: {
                                    type: "[String]",
                                },
                            },
                        },
                    },
                });
            }
        }
        if (process.env.NODE_ENV === `development` ||
            process.env.NODE_ENV === `test`) {
            const moreThanOneDevConnector = Array.isArray(connector.config.localDevOptions) &&
                connector.config.localDevOptions.length > 1;
            await writeFile(path.join(process.cwd(), `dev-model${moreThanOneDevConnector ? "-" + connector.ModelBuilder.typePrefix : ``}.gql`), `# this file is automatically generated. Its only purpose is for debugging and understanding how your model definitions translate to GraphQL\n\n${sdl}`);
        }
        this.log(`defined ${connector.ModelBuilder.models.size} models ${chalk.blue(`${(Date.now() - startTime).toString()}ms`)}`);
        connect.resolve(connector.ModelBuilder);
    }
    async sourceNodes(args, options) {
        const connector = this.runningConnector;
        connector.syncCount = 0;
        connector.nodesApi.createNode = (input) => {
            connector.syncCount++;
            return args.actions.createNode(input);
        };
        connector.nodesApi.deleteNode = (input) => {
            connector.syncCount++;
            // FIXME(ndhoule): Incorrect type (https://github.com/netlify/sdk/pull/1170#discussion_r1556157222)
            // eslint-disable-next-line @typescript-eslint/no-confusing-void-expression
            return args.actions.deleteNode(input);
        };
        connector.nodesApi.dispatch = args.store.dispatch;
        connector.nodesApi.getNode = args.getNode;
        connector.nodesApi.cache = args.cache;
        connector.nodesApi.pluginOptions = options;
        connector.nodesApi.webhookBody = args.webhookBody || {};
        const syncingLog = setTimeout(() => {
            this.log(`syncing`, {
                symbol: `â§—`,
                symbolColor: `yellow`,
            });
        }, 3000);
        const startTime = Date.now();
        try {
            await connector.sync(args);
        }
        catch (e) {
            if (e instanceof ModelError) {
                console.error(e.message);
            }
            else if (e instanceof Error) {
                console.error(e.stack);
            }
            else {
                console.error(e);
            }
            return delayedExit();
        }
        finally {
            connector.nodesApi.deleteNode = undefined;
            connector.nodesApi.cache = undefined;
            connector.nodesApi.pluginOptions = undefined;
        }
        clearTimeout(syncingLog);
        this.log(`synced ${connector.syncCount} records ${chalk.blue(`${(Date.now() - startTime).toString()}ms`)}\n`);
    }
}
//# sourceMappingURL=source-plugin-bridge.js.map