import { GraphQLNonNull, GraphQLObjectType, print, } from "graphql";
import { RenameTypes, schemaFromExecutor } from "@graphql-tools/wrap";
import { addTypes, modifyObjectFields, } from "@graphql-tools/utils";
import { stitchSchemas } from "@graphql-tools/stitch";
const buildHTTPExecutor = (url, headers) => {
    return async ({ document, variables, operationName, extensions }) => {
        const query = print(document);
        const fetchResult = await fetch(url, {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json",
                ...headers,
            },
            body: JSON.stringify({ query, variables, operationName, extensions }),
        });
        return fetchResult.json();
    };
};
class NamespaceUnderFieldTransform {
    typeName;
    fieldName;
    constructor({ typeName, fieldName, }) {
        this.typeName = typeName;
        this.fieldName = fieldName;
    }
    transformSchema(schema) {
        const queryConfig = schema.getQueryType().toConfig();
        const nestedQuery = new GraphQLObjectType({
            ...queryConfig,
            name: this.typeName,
        });
        /*
          Creating a new schema from the existing schema nested under the typename provided
          This also sets the typename for Query.someTypeName to the typePrefix
          
          For example:
          Query {
            someTypeName {
              existingResolver1
              existingResolver2
            }
          }
    
          Rather than:
          Query {
            existingResolver1
            existingResolver2
          }
        */
        const newSchema = addTypes(schema, [nestedQuery]);
        const newRootFieldConfigMap = {
            [this.fieldName]: {
                type: new GraphQLNonNull(nestedQuery),
                resolve: () => {
                    return {};
                },
            },
        };
        // Add in the new field generated above to the schema
        const [modifiedNewSchema] = modifyObjectFields(newSchema, queryConfig.name, () => true, newRootFieldConfigMap);
        return modifiedNewSchema;
    }
}
export function getRemoteGraphQLSchemaFn(typePrefix) {
    return async function (args) {
        const remoteExecutor = buildHTTPExecutor(args.uri, args.headers || {});
        const schema = {
            schema: await schemaFromExecutor(remoteExecutor),
            executor: remoteExecutor,
            transforms: [
                // Rename all the existing types in order to avoid type collision
                new RenameTypes((name) => `${typePrefix}Proxy${name}`),
                new NamespaceUnderFieldTransform({
                    typeName: typePrefix,
                    fieldName: typePrefix[0].toLocaleLowerCase() + typePrefix.slice(1),
                }),
            ],
        };
        return stitchSchemas({
            subschemas: [schema],
        });
    };
}
//# sourceMappingURL=get-remote-graphql-schema.js.map