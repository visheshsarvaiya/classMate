import zodLib from "zod";
import { register } from "zod-metadata";
register(zodLib);
import { ConnectorOptionsSchema, } from "./utils/options.js";
import { ModelError } from "./model/error.js";
import { makeInstanceID } from "./utils/instance-id.js";
import { ConfiguredNetlifyConnector, getGlobalConnectorInstance, setGlobalConnectorInstance, } from "./connector-instance.js";
export class NetlifyConnector {
    config;
    started = false; // true if the first event loop tick has occurred. Plugin APIs cannot be dynamically assigned after this as the "exports" should be static. so this value is checked before assigning plugin APIs. It must be false to assign plugin APIs.
    definedImplementations = Object.create(null);
    isUsingUnifiedAPI = false;
    optionsSchema;
    proxiedSchemas = [];
    supports = {
        connect: false,
        visualEditor: false,
        deltaSync: true,
    };
    constructor(config) {
        if (!config?.typePrefix) {
            throw new Error(`You must provide a default typePrefix when creating a connector.`);
        }
        if (`create` in config.supports) {
            throw new Error(`Found property "create" in extension.addConnector({ supports: { create: ${config.supports.create} } })\n\nThis property has been renamed to "visualEditor".\nAll connectors are required to update their code to use this new property name.`);
        }
        if (typeof config.initState === `function`) {
            this.checkCanDefine(`extension.addConnector({ initState })`);
            this.definedImplementations.init = config.initState;
        }
        this.config = {
            ...config,
            localDevOptions: config.localDevOptions ?? {},
            supports: config.supports ?? {},
        };
        this.supports = {
            ...this.supports,
            ...config.supports,
        };
        if (typeof config.defineOptions === `function`) {
            this.checkCanDefine(`extension.addConnector({ defineOptions })`);
            this.optionsSchema = new ConnectorOptionsSchema(config.defineOptions);
        }
        else {
            this.optionsSchema = new ConnectorOptionsSchema(({ zod }) => zod.object({}));
        }
        setImmediate(() => {
            // plugins may only add APIs on the first event loop tick.
            // exported APIs are static and cannot be dynamically assigned.
            this.started = true;
            if (!this.supports.connect && !this.supports.visualEditor) {
                throw new Error(`Every connector needs to support Connect, the visual editor or both.
Example:
  const connector = extension.addConnector({
    supports: {
      visualEditor: true, // or false
      connect: false, // or true
    }
  });`);
            }
            // error if no models were defined
            if (!this.definedImplementations.model) {
                // unless the connector only defines a dynamic proxied schema
                if (this.proxiedSchemas.length) {
                    return;
                }
                throw new Error(`No connector.model(implementation) was defined. This API is required for all connectors.`);
            }
            // error if no sync fn was defined
            if (!this.definedImplementations.sync) {
                // unless the connector only resolves data dynamically
                if (this.proxiedSchemas.length) {
                    return;
                }
                throw new Error(`No connector.sync(fn) implementation was defined. This API is required for all connectors.`);
            }
        });
    }
    /**
     * @deprecated use `NetlifyExtension#addConnector({ initState, <...> })` instead
     */
    init = (_init) => {
        throw new Error(`connector.init(fn) is deprecated. Use extension.addConnector({ initState: fn }) instead - it works the same way but allows for proper type inference of the "options" object in other methods like connector.sync() and connector.model().`);
    };
    /**
     * @deprecated use extension.addConnector({ defineOptions: fn }) instead.
     */
    defineOptions = (_definer) => {
        throw new Error(`connector.defineOptions(fn) has been moved to extension.addConnector({ defineOptions: fn }). Please move your options definition function to this new location.`);
    };
    getOptionsSchema() {
        return this.optionsSchema.buildSchema();
    }
    /**
     * Defines the content model for your Connector.
     * @link https://sdk.netlify.com/connectors/connector-apis/#model
     */
    model(modeler) {
        this.checkCanDefine(`model`);
        if (this.definedImplementations.model) {
            throw new ModelError(`connector.model() may only be called one time, but has been called more than once.`);
        }
        this.definedImplementations.model = modeler;
    }
    sync(sync) {
        this.checkCanDefine(`sync`);
        if (this.definedImplementations.sync) {
            throw new ModelError(`connector.sync() may only be called one time, but has been called more than once.`);
        }
        this.definedImplementations.sync = sync;
    }
    hasAccess(userFn) {
        this.checkCanDefine(`hasAccess`);
        this.definedImplementations.hasAccess = userFn;
    }
    assets(args) {
        this.checkCanDefine(`assets`);
        if (this.definedImplementations["assets.upload"]) {
            throw new ModelError(`connector.assets() may only be called one time, but has been called more than once.`);
        }
        const { create } = args;
        if (!create) {
            throw new ModelError(`connector.assets({ create }) must be called with a 'create' implementation.`);
        }
        this.definedImplementations[`assets.upload`] = create;
    }
    documents(args) {
        this.checkCanDefine(`documents`);
        for (const apiName of [
            `documents.update`,
            `documents.create`,
            `documents.delete`,
            `documents.publish`,
        ]) {
            if (this.definedImplementations[apiName]) {
                throw new ModelError(`connector.documents() may only be called one time, but it's been called more than once.`);
            }
        }
        this.definedImplementations["documents.update"] = args.update;
        this.definedImplementations["documents.create"] = args.create;
        this.definedImplementations["documents.delete"] = args.delete;
        this.definedImplementations["documents.publish"] = args.publish;
    }
    scheduledActions(methods) {
        this.checkCanDefine("scheduledActions");
        for (const apiName of [
            "scheduledActions.update",
            "scheduledActions.create",
            "scheduledActions.delete",
        ]) {
            if (this.definedImplementations[apiName]) {
                throw new ModelError("connector.scheduledActions() may only be called one time, but it's been called more than once.");
            }
        }
        this.definedImplementations["scheduledActions.create"] = methods.create;
        this.definedImplementations["scheduledActions.delete"] = methods.delete;
        this.definedImplementations["scheduledActions.update"] = methods.update;
    }
    /**
     * @deprecated This API has been replaced with connector.sync(({ isInitialSync }) => {})
     */
    event(_name, _implementation) {
        throw new Error(`connector.event(name, fn) has been deprecated. Update your connector code to use connector.sync(({ isInitialSync }) => {}) instead.`);
    }
    checkCanDefine(apiName) {
        if (this.started) {
            throw new Error(`Cannot call ${apiName} after the first event loop tick.\n\nPlease call connector().${apiName}() synchronously in your plugin's main module. Plugin implementations cannot be dynamically assigned.`);
        }
    }
    proxySchema(fn) {
        this.proxiedSchemas.push(fn);
    }
    // Multiple instances of the same connector may need to exist within the same process, so create and store instances by a unique hashed ID
    getConnectorInstance(options, connectorName) {
        const instanceID = options.instanceID ?? makeInstanceID(options);
        const existingConnector = getGlobalConnectorInstance(connectorName, instanceID);
        if (existingConnector) {
            return existingConnector;
        }
        const connectorInstance = new ConfiguredNetlifyConnector({
            slug: connectorName,
            options,
            instanceID,
            NetlifyConnector: this,
            config: this.config,
        });
        setGlobalConnectorInstance(connectorName, instanceID, connectorInstance);
        return connectorInstance;
    }
}
//# sourceMappingURL=sdk.js.map