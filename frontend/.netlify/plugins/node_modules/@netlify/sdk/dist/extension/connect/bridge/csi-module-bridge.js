import { lmdbStoredAssetToStackbit } from "../utils/data.js";
import { ModelError } from "../model/error.js";
import { parseNonUndefined } from "../../../utils.js";
import { BridgePluginAPI } from "./bridge.js";
export class CSIBridgeAPI extends BridgePluginAPI {
    cache;
    constructor(configuredConnector) {
        super(configuredConnector);
        const validateScheduledActionDefinitionsResult = validateScheduledActionDefinitions({
            create: this.runningConnector.definedImplementations["scheduledActions.create"],
            delete: this.runningConnector.definedImplementations["scheduledActions.delete"],
            update: this.runningConnector.definedImplementations["scheduledActions.update"],
        });
        if (!validateScheduledActionDefinitionsResult.success) {
            throw new Error(validateScheduledActionDefinitionsResult.error.message, {
                cause: validateScheduledActionDefinitionsResult.error,
            });
        }
    }
    get stackbitCache() {
        if (!this.cache) {
            throw new Error(`Netlify Visual Editor cache is not available but it should be. This is a bug in the Netlify SDK.`);
        }
        return this.cache;
    }
    async init({ cache }) {
        // wait for Connects init to finish
        const { connect, create } = this.runningConnector.getAPIPromises("init");
        await connect.promise;
        // send back the Create cache so the SDK can use it to insert & delete
        // documents/assets/etc
        create.resolve(cache);
        this.cache = cache;
    }
    async hasAccess(args) {
        const connector = this.runningConnector;
        const access = connector.definedImplementations.hasAccess;
        if (access) {
            return access(args);
        }
        return Promise.resolve({
            hasPermissions: true,
            hasConnection: true,
        });
    }
    async uploadAsset(args) {
        const connector = this.runningConnector;
        const upload = connector.definedImplementations["assets.upload"];
        if (upload) {
            const returnVal = await upload({
                fileName: args.fileName,
                mimeType: args.mimeType,
                base64: args.base64,
                url: args.url,
                locale: args.locale,
                userContext: args.userContext,
                state: connector.initState,
            });
            return lmdbStoredAssetToStackbit(connector.ModelBuilder.modelDataAPIs.Asset.insert(returnVal));
        }
        throw new Error("connector.assets({ upload: fn }) is not implemented");
    }
    async updateDocument(args) {
        const connector = this.runningConnector;
        const update = connector.definedImplementations["documents.update"];
        const modelName = args.document.modelName;
        if (update) {
            const model = connector.ModelBuilder.modelDataAPIs[modelName];
            if (!model) {
                throw new ModelError(`No model found with name ${modelName}`);
            }
            const getDocument = this.stackbitCache.getDocumentById;
            return update({
                model,
                models: connector.ModelBuilder.modelDataAPIs,
                document: args.document,
                state: connector.initState,
                cache: parseNonUndefined(connector.sourcePluginAPI.contentEngineCache),
                options: connector.optionsValues,
                operations: args.operations,
                userContext: args.userContext,
                platform: connector.platform,
                getDocument,
            });
        }
        throw new Error("connector.documents({ update: fn }) is not implemented");
    }
    async createDocument(args) {
        const connector = this.runningConnector;
        const create = connector.definedImplementations["documents.create"];
        if (!create) {
            throw new Error("connector.documents({ create: fn }) is not implemented");
        }
        const modelName = args.model.name;
        const model = connector.ModelBuilder.modelDataAPIs[modelName];
        if (!model) {
            throw new ModelError(`No model found with name ${modelName}`);
        }
        const getDocument = this.stackbitCache.getDocumentById;
        const connectorReturnedVal = await create({
            model,
            models: connector.ModelBuilder.modelDataAPIs,
            state: connector.initState,
            options: connector.optionsValues,
            cache: parseNonUndefined(connector.sourcePluginAPI.contentEngineCache),
            updateOperationFields: args.updateOperationFields,
            userContext: args.userContext,
            platform: connector.platform,
            getDocument,
        });
        return connectorReturnedVal;
    }
    async deleteDocument(args) {
        const connector = this.runningConnector;
        const del = connector.definedImplementations["documents.delete"];
        if (!del) {
            throw new Error("connector.documents({ delete: fn }) is not implemented");
        }
        const modelName = args.document?.modelName;
        const model = connector.ModelBuilder.modelDataAPIs[modelName];
        if (!model) {
            throw new ModelError(`No model found with name ${modelName}`);
        }
        const getDocument = this.stackbitCache.getDocumentById;
        return del({
            model,
            models: connector.ModelBuilder.modelDataAPIs,
            cache: connector.sourcePluginAPI.contentEngineCache,
            options: connector.optionsValues,
            document: args.document,
            state: connector.initState,
            userContext: args.userContext,
            platform: connector.platform,
            getDocument,
        });
    }
    async publishDocuments(args) {
        const connector = this.runningConnector;
        const publish = connector.definedImplementations["documents.publish"];
        if (!publish) {
            throw new Error("connector.documents({ publish: fn }) is not implemented");
        }
        return publish({
            documents: args.documents,
            options: connector.optionsValues,
            cache: connector.sourcePluginAPI.contentEngineCache,
            state: connector.initState,
            userContext: args.userContext,
            platform: connector.platform,
        });
    }
    async getModels() {
        const { connect, create } = this.runningConnector.getAPIPromises("model");
        const modelBuilder = await connect.promise;
        if (!modelBuilder) {
            return;
        }
        try {
            return modelBuilder.toCreateModels();
        }
        catch (e) {
            create.reject(e);
        }
        finally {
            create.resolve();
        }
    }
    getLocales() {
        return this.runningConnector.ModelBuilder.locales;
    }
    getProjectManageUrl() {
        return this.runningConnector.initState?.projectManageUrl || ``;
    }
    async connectSyncFinished() {
        const { connect } = this.runningConnector.getAPIPromises(`sync`);
        await connect.promise;
        return this.runningConnector;
    }
    async getDocuments() {
        const { connect } = this.runningConnector.getAPIPromises(`sync`);
        await connect.promise;
        return (await this.connectSyncFinished()).restoreAllDocuments();
    }
    async getAssets() {
        const { connect } = this.runningConnector.getAPIPromises(`sync`);
        await connect.promise;
        return (await this.connectSyncFinished()).restoreAllAssets();
    }
    async updateScheduledAction({ userContext, ...data }) {
        const impl = this.runningConnector.definedImplementations["scheduledActions.update"];
        if (typeof impl !== "function") {
            throw new TypeError(`Expected scheduledActions.update to be implemented but received: ${impl}`);
        }
        const result = await impl({
            cache: parseNonUndefined(this.runningConnector.sourcePluginAPI.contentEngineCache),
            options: this.runningConnector.optionsValues,
            platform: this.runningConnector.platform,
            scheduledAction: {
                id: data.scheduledActionId,
                documentIds: data.documentIds,
                executeAt: data.executeAt,
                name: data.name,
            },
            state: this.runningConnector.initState,
            userContext,
        });
        return { updatedScheduledActionId: result.id };
    }
    async cancelScheduledAction({ userContext, ...data }) {
        const impl = this.runningConnector.definedImplementations["scheduledActions.delete"];
        if (typeof impl !== "function") {
            throw new TypeError(`Expected scheduledActions.delete to be implemented but received: ${impl}`);
        }
        const result = await impl({
            cache: parseNonUndefined(this.runningConnector.sourcePluginAPI.contentEngineCache),
            options: this.runningConnector.optionsValues,
            platform: this.runningConnector.platform,
            scheduledAction: {
                id: data.scheduledActionId,
            },
            state: this.runningConnector.initState,
            userContext,
        });
        return { cancelledScheduledActionId: result.id };
    }
    async createScheduledAction({ userContext, ...data }) {
        const impl = this.runningConnector.definedImplementations["scheduledActions.create"];
        if (typeof impl !== "function") {
            throw new TypeError(`Expected scheduledActions.create to be implemented but received: ${impl}`);
        }
        const result = await impl({
            cache: parseNonUndefined(this.runningConnector.sourcePluginAPI.contentEngineCache),
            options: this.runningConnector.optionsValues,
            platform: this.runningConnector.platform,
            scheduledAction: {
                name: data.name,
                action: data.action,
                documentIds: data.documentIds,
                executeAt: data.executeAt,
            },
            state: this.runningConnector.initState,
            userContext,
        });
        return { newScheduledActionId: result.id };
    }
    async getScheduledActions() {
        await this.connectSyncFinished();
        return this.runningConnector.restoreAllScheduledActions();
    }
}
const validateScheduledActionDefinitions = (methods) => {
    const isAnyScheduledActionMethodDefined = typeof methods.create === "function" ||
        typeof methods.delete === "function" ||
        typeof methods.update === "function";
    const areAllScheduledActionMethodsDefined = typeof methods.create === "function" &&
        typeof methods.delete === "function" &&
        typeof methods.update === "function";
    if (!isAnyScheduledActionMethodDefined ||
        areAllScheduledActionMethodsDefined) {
        return {
            areAllDefined: areAllScheduledActionMethodsDefined,
            error: undefined,
            success: true,
        };
    }
    const missingMethods = Object.entries(methods)
        .filter(([, action]) => action === undefined || action === false)
        .map(([name]) => name)
        .sort();
    return {
        error: new Error(`You must either define all three scheduled actions methods (create, delete, update) or none. Missing: ${missingMethods.join(", ")}`),
        success: false,
    };
};
//# sourceMappingURL=csi-module-bridge.js.map