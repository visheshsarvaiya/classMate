import { GraphQLSchema } from "graphql";
import zodLib from "zod";
import { type SourceNodesArgs, type PluginOptions } from "@netlify/content-engine";
import * as CSITypes from "@stackbit/types";
import { type MaybePromise } from "../../lib/types.js";
import { type User } from "./types/csi.js";
import { type DynamicModelsIteratorObject, type ModelBuilder, type Modeler, type ModelsIteratorObject } from "./model/builder.js";
import { ConnectorOptionsSchema, type BaseOptionsSchema, type DefineOptionsSchema, type DefineOptionsSchemaOptions, type DefineOptionsSchemaOutput } from "./utils/options.js";
import { ConfiguredNetlifyConnector } from "./connector-instance.js";
import { ModelDefinition } from "./model/definition.js";
import { RawAsset } from "./utils/data.js";
import { ConnectorBaseOptionsSchema, ConnectorDefineOptionsSchemaOutput } from "./sdk.js";
type GetDocument = (id: string) => CSITypes.Document<unknown> | undefined;
export type AddConnectorInput<State extends ConnectorContextState, OptionsSchema extends ConnectorBaseOptionsSchema, LocalDevOptions extends BaseConnectorLocalDevOptions | BaseConnectorLocalDevOptions[]> = {
    defineOptions?: ConnectorDefineOptions<OptionsSchema> | undefined;
    initState?: ConnectorInitState<State, ConnectorDefineOptionsSchemaOutput<OptionsSchema>> | undefined;
    localDevOptions?: LocalDevOptions | undefined;
    supports: ConnectorSupports;
    typePrefix: string;
    autoFormatGraphQLTypesAndFields?: boolean;
};
export declare class NetlifyConnector<State extends ConnectorContextState, OptionsSchema extends BaseOptionsSchema, LocalDevOptions extends BaseConnectorLocalDevOptions | BaseConnectorLocalDevOptions[] = BaseConnectorLocalDevOptions> {
    config: ConnectorConfig<LocalDevOptions>;
    private started;
    definedImplementations: DefinedImplementations<any, OptionsSchema, State>;
    isUsingUnifiedAPI: boolean;
    optionsSchema: ConnectorOptionsSchema<OptionsSchema>;
    proxiedSchemas: ProxiedSchemaFn<State, OptionsSchema>[];
    supports: ConnectorSupports;
    constructor(config: AddConnectorInput<State, OptionsSchema, LocalDevOptions>);
    /**
     * @deprecated use `NetlifyExtension#addConnector({ initState, <...> })` instead
     */
    init: (_init: ConnectorInitState<DefineOptionsSchemaOutput<OptionsSchema>, State>) => never;
    /**
     * @deprecated use extension.addConnector({ defineOptions: fn }) instead.
     */
    defineOptions: (_definer: DefineOptionsSchema<OptionsSchema>) => never;
    getOptionsSchema(): OptionsSchema;
    /**
     * Defines the content model for your Connector.
     * @link https://sdk.netlify.com/connectors/connector-apis/#model
     */
    model(modeler: Modeler<State, DefineOptionsSchemaOutput<OptionsSchema>>): void;
    sync(sync: (args: {
        cache: Cache;
        isInitialSync: boolean | null;
        models: ModelsIteratorObject;
        dynamicModels: DynamicModelsIteratorObject;
        options: DefineOptionsSchemaOutput<OptionsSchema>;
        platform: PlatformType;
        state: State;
        webhookBody: Record<string, unknown>;
    }) => Promise<void> | void): void;
    hasAccess(userFn: (options: {
        userContext?: {
            name: string;
            email: string;
            sso?: {
                idpId: string;
                firstName?: string;
                lastName?: string;
                emails?: {
                    value: string;
                    type?: string;
                    primary?: boolean;
                }[];
                attributes?: Record<string, any>;
            } | undefined;
        } | undefined;
    }) => Promise<{
        hasConnection: boolean;
        hasPermissions: boolean;
    }>): void;
    assets<AssetsType extends {
        userContext: unknown;
    }>(args: {
        create: (args: {
            state: State;
            fileName: string;
            mimeType: string;
            locale?: string;
            userContext?: User<AssetsType["userContext"]>;
            url?: string;
            base64?: string;
        }) => Promise<RawAsset> | RawAsset;
    }): void;
    documents<DocumentsType extends {
        userContext: unknown;
    }>(args: ConnectorDocuments<DocumentsType, OptionsSchema, State>): void;
    scheduledActions<DocumentsType extends {
        userContext: unknown;
    }>(methods: ConnectorScheduledActions<DocumentsType, OptionsSchema, State>): void;
    /**
     * @deprecated This API has been replaced with connector.sync(({ isInitialSync }) => {})
     */
    event(_name: "createAllNodes" | "updateNodes", _implementation: CreateNodesPluginApi | false): void;
    private checkCanDefine;
    proxySchema(fn: ProxiedSchemaFn<State, OptionsSchema>): void;
    getConnectorInstance(options: Record<string, any>, connectorName: string): ConfiguredNetlifyConnector;
}
declare module "zod" {
    interface ZodMeta {
        [k: string | number | symbol]: unknown;
    }
    interface ZodTypeDef {
        meta?: ZodMeta;
    }
    interface ZodType<Output = any, Def extends zodLib.ZodTypeDef = zodLib.ZodTypeDef, Input = Output> {
        getMeta(): this["_def"] extends {
            meta: infer M;
        } ? M : ZodMeta | undefined;
        meta<T extends ZodMeta = ZodMeta>(meta: T): ZodType<Output, Def extends {
            meta: infer M;
        } ? Def & {
            meta: M & T;
        } : Def & {
            meta: T;
        }, Input>;
    }
}
type ConnectorScheduledActionActionType = "publish" | "unpublish";
type ConnectorScheduledActionsCommonOptions<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = {
    cache: Cache;
    options: DefineOptionsSchemaOutput<OptionsSchema>;
    platform: PlatformType;
    state: State;
    userContext: (User & DocumentsType["userContext"]) | undefined;
};
type ConnectorScheduledActionsCreateOptions<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = ConnectorScheduledActionsCommonOptions<DocumentsType, OptionsSchema, State> & {
    scheduledAction: {
        name: string;
        action: ConnectorScheduledActionActionType;
        documentIds: string[];
        executeAt: string;
    };
};
export type ConnectorScheduledActionsCreate<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = (options: ConnectorScheduledActionsCreateOptions<DocumentsType, OptionsSchema, State>) => MaybePromise<{
    id: string;
}>;
type ConnectorScheduledActionsDeleteOptions<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = ConnectorScheduledActionsCommonOptions<DocumentsType, OptionsSchema, State> & {
    scheduledAction: {
        id: string;
    };
};
export type ConnectorScheduledActionsDelete<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = (options: ConnectorScheduledActionsDeleteOptions<DocumentsType, OptionsSchema, State>) => MaybePromise<{
    id: string;
}>;
type ConnectorScheduledActionsUpdateOptions<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = ConnectorScheduledActionsCommonOptions<DocumentsType, OptionsSchema, State> & {
    scheduledAction: {
        id: string;
        documentIds?: string[] | undefined;
        executeAt?: string | undefined;
        name?: string | undefined;
    };
};
export type ConnectorScheduledActionsUpdate<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = (options: ConnectorScheduledActionsUpdateOptions<DocumentsType, OptionsSchema, State>) => MaybePromise<{
    id: string;
}>;
export type ConnectorScheduledActions<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = {
    create: ConnectorScheduledActionsCreate<DocumentsType, OptionsSchema, State>;
    delete: ConnectorScheduledActionsDelete<DocumentsType, OptionsSchema, State>;
    update: ConnectorScheduledActionsUpdate<DocumentsType, OptionsSchema, State>;
};
export type ConnectorDocuments<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = {
    update: ConnectorDocumentsUpdate<DocumentsType, OptionsSchema, State>;
    create: ConnectorDocumentsCreate<DocumentsType, OptionsSchema, State>;
    delete: ConnectorDocumentsDelete<DocumentsType, OptionsSchema, State>;
    publish: ConnectorDocumentsPublish<DocumentsType, OptionsSchema, State>;
};
export type ConnectorDocumentsUpdate<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = (args: {
    cache: Cache;
    document: any;
    getDocument: GetDocument;
    model: ModelDefinition["dataAPI"];
    models: ModelBuilder["modelDataAPIs"];
    operations: CSITypes.UpdateOperation[];
    options: DefineOptionsSchemaOutput<OptionsSchema>;
    platform: PlatformType;
    state: State;
    userContext: (User & DocumentsType["userContext"]) | undefined;
}) => MaybePromise<void>;
export type ConnectorDocumentsCreate<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = (args: {
    cache: Cache;
    getDocument: GetDocument;
    model: ModelDefinition["dataAPI"];
    models: ModelBuilder["modelDataAPIs"];
    options: DefineOptionsSchemaOutput<OptionsSchema>;
    platform: PlatformType;
    state: State;
    updateOperationFields: Record<string, CSITypes.UpdateOperationField>;
    userContext: (User & DocumentsType["userContext"]) | undefined;
}) => MaybePromise<{
    documentId: string;
}>;
export type ConnectorDocumentsDelete<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = (args: {
    cache: Cache;
    document: any;
    getDocument: GetDocument;
    model: ModelDefinition["dataAPI"];
    models: ModelBuilder["modelDataAPIs"];
    options: DefineOptionsSchemaOutput<OptionsSchema>;
    platform: PlatformType;
    state: State;
    userContext: (User & DocumentsType["userContext"]) | undefined;
}) => MaybePromise<void>;
export type ConnectorDocumentsPublish<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends BaseOptionsSchema, State extends ConnectorContextState> = (args: {
    state: State;
    cache: Cache;
    options: DefineOptionsSchemaOutput<OptionsSchema>;
    documents: any[];
    userContext: (User & DocumentsType["userContext"]) | undefined;
    platform: PlatformType;
}) => MaybePromise<void>;
export type ConnectorSupports = {
    connect: boolean;
    visualEditor: boolean;
    deltaSync?: boolean;
    create?: boolean;
};
export type ConnectorConfigInputSupports = Partial<ConnectorSupports>;
export type ConnectorConfigInput<LocalDevOptions extends BaseConnectorLocalDevOptions | BaseConnectorLocalDevOptions[] = BaseConnectorLocalDevOptions> = {
    localDevOptions?: LocalDevOptions | undefined;
    supports: ConnectorConfigInputSupports;
    typePrefix: string;
    autoFormatGraphQLTypesAndFields?: boolean;
};
export type getRemoteGraphQLSchema = {
    uri: string;
    headers?: Record<string, string>;
};
export type BaseConnectorLocalDevOptions = {
    [key: string]: string | boolean | number;
};
export type ConnectorConfig<LocalDevOptions extends BaseConnectorLocalDevOptions | BaseConnectorLocalDevOptions[] = BaseConnectorLocalDevOptions> = {
    localDevOptions: LocalDevOptions;
    supports: Partial<ConnectorSupports>;
    typePrefix: string;
    autoFormatGraphQLTypesAndFields?: boolean;
};
export type ProxiedSchemaFn<State extends ConnectorContextState, OptionsSchema extends BaseOptionsSchema> = (options: {
    options: DefineOptionsSchemaOutput<OptionsSchema>;
    state: State;
    typePrefix: string;
    getRemoteGraphQLSchema(args: getRemoteGraphQLSchema): Promise<GraphQLSchema>;
}) => Promise<GraphQLSchema>;
export interface Cache {
    get<T = unknown>(key: string): Promise<T>;
    set<T = unknown>(key: string, value: T): Promise<void>;
    delete(key: string): Promise<void>;
}
export interface ConnectorAPIUtils<State, OptionsType> {
    /**
     * The data source options passed to the connector (creds etc.)
     */
    options: OptionsType;
    /**
     * Mutable state. Can be used for e.g. API clients. Do not use to store document data.
     */
    state: State;
    /**
     * Cache to store data between builds, e.g. sync tokens. Do not use to store document data.
     */
    cache: Cache;
    /**
     * Platform that the connector is running on.
     */
    platform: PlatformType;
}
export type CreateNodesPluginApi = (createAllNodesApi: {
    models: ModelsIteratorObject;
    cache: SourceNodesArgs["cache"];
    webhookBody: Record<string, any>;
}, pluginOptions: PluginOptions) => Promise<void> | void;
type DefinedImplementation<T = any> = false | ((args?: any, options?: any) => Promise<T> | T);
export type DefinedImplementations<DocumentsType extends {
    userContext: unknown;
}, OptionsSchema extends zodLib.ZodTypeAny, State extends ConnectorContextState> = {
    "assets.upload"?: DefinedImplementation<any> | undefined;
    "documents.create"?: ConnectorDocumentsCreate<DocumentsType, OptionsSchema, State> | false | undefined;
    "documents.delete"?: ConnectorDocumentsDelete<DocumentsType, OptionsSchema, State> | false | undefined;
    "documents.publish"?: ConnectorDocumentsPublish<DocumentsType, OptionsSchema, State> | false | undefined;
    "documents.update"?: ConnectorDocumentsUpdate<DocumentsType, OptionsSchema, State> | false | undefined;
    "event.createAllNodes"?: DefinedImplementation<any> | undefined;
    "event.updateNodes"?: DefinedImplementation<any> | undefined;
    hasAccess?: DefinedImplementation<any> | undefined;
    init?: DefinedImplementation<any> | undefined;
    model?: DefinedImplementation<any> | undefined;
    "scheduledActions.create"?: ConnectorScheduledActionsCreate<DocumentsType, OptionsSchema, State> | false | undefined;
    "scheduledActions.delete"?: ConnectorScheduledActionsDelete<DocumentsType, OptionsSchema, State> | false | undefined;
    "scheduledActions.update"?: ConnectorScheduledActionsUpdate<DocumentsType, OptionsSchema, State> | false | undefined;
    sync?: DefinedImplementation<any> | undefined;
};
export type APIName = keyof DefinedImplementations<any, any, any>;
export type APIPromiseName = APIName | "runtime";
export type ConnectorContext<State extends ConnectorContextState> = {
    state: State;
};
export type ConnectorContextState = {
    [key: string]: unknown;
};
export type PlatformType = "netlify-connect" | "netlify-visual-editor" | "local" | "unknown";
export type ValidationError = {
    message: string;
    objectType: "document" | "asset";
    objectId: string;
    fieldPath: (string | number)[];
    isUniqueValidation?: boolean;
};
export type Asset<AssetContext = unknown> = {
    type: "asset";
    id: string;
    manageUrl: string;
    status: "added" | "modified" | "published" | "deleted";
    createdAt: string;
    createdBy?: string;
    updatedAt: string;
    updatedBy?: string[];
    locale?: string;
    fields: CSITypes.AssetFields;
    context: AssetContext;
    hidden?: boolean;
};
export { type BaseOptionsSchema as ConnectorBaseOptionsSchema, type DefineOptionsSchemaOutput as ConnectorDefineOptionsSchemaOutput, } from "./utils/options.js";
export type ConnectorDefineOptionsOptions = DefineOptionsSchemaOptions;
export type ConnectorDefineOptions<OptionsSchema extends BaseOptionsSchema> = DefineOptionsSchema<OptionsSchema>;
export type ConnectorInitStateOptions<Options> = Omit<ConnectorAPIUtils<never, Options>, "state">;
export type ConnectorInitState<State, Options> = (options: ConnectorInitStateOptions<Options>) => Promise<State & {
    projectManageUrl?: string;
}> | (State & {
    projectManageUrl?: string;
});
//# sourceMappingURL=sdk.d.ts.map