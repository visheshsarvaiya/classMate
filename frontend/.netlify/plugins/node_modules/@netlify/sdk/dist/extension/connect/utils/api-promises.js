/**
 * Get the API promises for a given instance and API name
 *
 * API promises are used to synchronize state between the connector and Connect/Create
 *
 * example:
 *
 * // in Connect
 * ```ts
 * const { connect, create } = getAPIPromises('instance-1', 'init', { create: true });
 * const cache = await create.promise; // wait for the create "init" API promise to resolve and return a cache object
 * // do something with the cache then resolve the connect "init" API promise
 * connector.resolve()
 * ```
 *
 * // in Create
 * ```ts
 * const { connect, create } = getAPIPromises('instance-1', 'init', { create: true });
 * // do something then resolve the create "init" API promise
 * create.resolve(cache);
 * // wait for the connect "init" API promise to resolve
 * await connect.promise;
 * ```
 *
 * In this example, both Create/Connect are using the API to synchronize with each other and send data back and forth, even though Connect/Create have no direct relationship to each other. They are simply running in the same process and being controlled by the SDK via promise resolvers
 */
export function getAPIPromises(instanceID, apiName, shouldHandleCreateSupport) {
    let apiPromises = apiPromisesByInstanceID.get(instanceID);
    if (!apiPromises) {
        apiPromises = new Map();
        apiPromisesByInstanceID.set(instanceID, apiPromises);
    }
    const existingPromises = apiPromises.get(apiName);
    // if we already have promises for this name, return them, this allows multiple codebases to await the same promise
    // they will be deleted from the map when they are resolved so calling this again afterwards will return new promises (below)
    if (existingPromises)
        return existingPromises;
    // promise resolvers for each data framework
    const promiseGroup = {
        connect: promiseWithResolvers(),
        create: promiseWithResolvers(),
    };
    // resolve Netlify Create API promises immmediately if the current runtime is not Netlify Create
    // don't resolve it immediately if we're checking wether or not the runtime is create though
    if (apiName !== `runtime` && !shouldHandleCreateSupport) {
        promiseGroup.create.resolve();
    }
    // store the promises so we can resolve them or look them up later
    apiPromises.set(apiName, promiseGroup);
    // whether the create promise resolved or rejected
    promiseGroup.create.promise?.finally(() => {
        // remove it from the group
        promiseGroup.create.promise = undefined;
        // and if this was the last promise in the group, remove the group from the map
        if (!promiseGroup.connect.promise)
            apiPromises?.delete(apiName);
    });
    // whether the connect promise resolved or rejected
    promiseGroup.connect.promise?.finally(() => {
        // remove it from the group
        promiseGroup.connect.promise = undefined;
        // and if this was the last promise in the group, remove the group from the map
        if (!promiseGroup.create.promise)
            apiPromises?.delete(apiName);
    });
    return promiseGroup;
}
// this allows us to use promises to push/pull data from the connector to/from Connect/Create
// minimal implementation of https://tc39.es/proposal-promise-with-resolvers/
export function promiseWithResolvers() {
    let resolve = () => {
        undefined;
    };
    let reject = () => {
        undefined;
    };
    const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
    });
    return {
        resolve,
        reject,
        promise: promise,
    };
}
// we need to keep track of the promises for each instance of a connector, otherwise all instances will use the same promises and overwrite each other or resolve the wrong promise
const apiPromisesByInstanceID = new Map();
//# sourceMappingURL=api-promises.js.map