import { omitByUndefined } from "../utils/omit-by-undefined.js";
import { slugifyLocale } from "./utils.js";
import { getGlobalConnectorInstance } from "../connector-instance.js";
// See https://www.notion.so/netlify/Connector-localization-stage-1-f2d04ba3c13c4b1aacd60dfd37d781d0?pvs=4
export class ModelTransformer {
    builder;
    definition;
    isVisualEditorType = false;
    constructor(init) {
        this.definition = init.definition;
        this.builder = init.builder;
    }
    get runtimePlatform() {
        return this.builder.runtimePlatform;
    }
    inputNeedsDefaultLocalization(input) {
        if (typeof input === `undefined` ||
            input === null ||
            typeof input === `string` ||
            typeof input === `number`) {
            // any string or number, undefined, or null is not a localized object. needs a default localized wrapper
            return true;
        }
        if (Array.isArray(input))
            return true; // arrays are never a localized object. default localize this
        const typename = this.definition.getTypeName();
        const isComplexScalar = typename === `richText` ||
            typename === `JSON` ||
            typename === `Date` ||
            typename === `DateTime`;
        if (typeof input === `object` &&
            this.definition.isScalarType &&
            !isComplexScalar) {
            // if it's a scalar type and we receive an object, consider it localized even if it doesn't have the correct locale keys
            // a connector may insert an object where the keys are for inactive locales (eg plugin options say only use locale A, but the crappy CMS api always returns all locales and this field only has locale B)
            return false; // don't default localize this value
        }
        if (this.definition.isScalarType &&
            (typename === `Date` || typename === `DateTime`) &&
            input instanceof Date) {
            return true; // a date object is not a localized object. needs a default localized wrapper
        }
        if (typeof input === `object`) {
            // check if the object is localized
            for (const locale of this.definition.ModelBuilder.locales) {
                // atleast one locale code as a property is treated as a user localized field
                if (locale.code in input) {
                    return false; // we found a locale key, don't add a default localized object wrapper
                }
            }
        }
        return true; // we didn't detect the input as having any localized keys. add a default localized object wrapper
    }
    // To allow connectors to easily enable localization without everything breaking, we allow non-localized values on localized fields and treat them as the default locale. This fn normalizes input data that's not localized into a default localized field shape.
    defaultLocalizeFieldValue(input) {
        if (this.inputNeedsDefaultLocalization(input)) {
            const defaultLocale = this.definition.ModelBuilder.getDefaultLocale();
            if (!defaultLocale)
                throw new Error(`No default locale found, but the Netlify SDK attempted to access one. This is a Netlify SDK bug.`);
            return {
                [defaultLocale]: input,
            };
        }
        if (typeof input !== `object` || !input) {
            throw new Error(`Expected value ${input} to be an object, but it's not. This is a Netlify SDK bug.`);
        }
        return input;
    }
    updateTreeContext(field, treeContext) {
        const updatedTreeContext = {
            path: field.name === `<ROOT_NODE>`
                ? treeContext.path
                : [...treeContext.path, field.name],
            visitorState: treeContext.visitorState,
        };
        return updatedTreeContext;
    }
    toOutputValue(input, field, treeContext) {
        const updatedTreeContext = this.updateTreeContext(field, treeContext);
        switch (field.list) {
            case true:
            case "required":
                return this.toOutputValueList(input, field, updatedTreeContext);
            case false:
            case undefined:
                return this.toOutputValueSingle(input, field, updatedTreeContext);
        }
    }
    maybeVisitListValue(input, field, treeContext) {
        if (typeof this.definition.visitor !== "function")
            return input;
        // OH NO: backwards compat. Seems type visitors behave differently for enum vs non-enum list values.
        // enum visitors receive the whole array while all others are visited on each array item.
        if (this.definition.isEnumType) {
            return this.definition.ModelWalker.visitInputValue(input, treeContext.visitorState);
        }
        // OH NO 2: before transformer refactor we weren't running type visitors on relationship fields, only on root node values
        if (this.definition.isNodeType && !field.isRootValue) {
            // backwards compat
            return input;
        }
        return input?.map?.((item) => this.definition.ModelWalker.visitInputValue(item, treeContext.visitorState));
    }
    convertObjectLocaleValues(localized, convertValue, _treeContext) {
        if (typeof localized === `undefined` || localized === null) {
            // if we get into a case where the localized field itself is null
            // return early to prevent errors due to trying to access locales on undefined below
            return localized;
        }
        const convertedLocales = {};
        for (const locale of this.definition.ModelBuilder.locales) {
            const value = localized[locale.code];
            if (typeof value === `undefined` || value === null) {
                continue;
            }
            convertedLocales[locale.code] = convertValue(value, locale.code);
        }
        return convertedLocales;
    }
    parseVisitedInputListLocalized(maybeLocalized, field, treeContext) {
        if (typeof maybeLocalized === `undefined` || maybeLocalized === null) {
            // we're not returning the parsed input here because in the case there's no data,
            // we still need to run validation. This will throw an error if the field value is not nullable
            // below we will still return a localized object shape where the values of locale fields are null/undefined
            this.parseVisitedInputList(maybeLocalized, field, {
                ...treeContext,
                path: [
                    ...treeContext.path,
                    this.definition.ModelBuilder.defaultLocale?.code ||
                        "default_locale_missing",
                ],
            });
        }
        const localized = this.defaultLocalizeFieldValue(maybeLocalized);
        return this.convertObjectLocaleValues(localized, (objectValue, locale) => this.parseVisitedInputList(objectValue, field, {
            ...treeContext,
            path: [...treeContext.path, locale],
        }), treeContext);
    }
    toOutputValueList(input, field, treeContext) {
        const visited = 
        // if the field is localized and the field value is also a localized object
        field.localized && !this.inputNeedsDefaultLocalization(input)
            ? // visit each localized value
                this.convertObjectLocaleValues(input, (fieldVal) => {
                    return this.maybeVisitListValue(fieldVal, field, treeContext);
                }, treeContext)
            : // otherwise visit the input directly, it's not a localized object
                this.maybeVisitListValue(input, field, treeContext);
        if (!visited && field.list !== "required") {
            return null;
        }
        switch (this.runtimePlatform) {
            case "netlify-create": {
                if (field.localized) {
                    const parsed = this.parseVisitedInputListLocalized(visited, field, treeContext);
                    return this.toCreateListFieldValueLocalized(parsed, field, treeContext);
                }
                else {
                    return this.toCreateListFieldValue(this.parseVisitedInputList(visited, field, treeContext), field, treeContext);
                }
            }
            case "netlify-connect": {
                if (field.localized) {
                    const parsed = this.parseVisitedInputListLocalized(visited, field, treeContext);
                    return this.toConnectListFieldValueLocalized(parsed, field, treeContext);
                }
                else {
                    return this.toConnectListFieldValue(this.parseVisitedInputList(visited, field, treeContext), field, treeContext);
                }
            }
        }
    }
    maybeVisitSingleValue(input, field, treeContext) {
        if (typeof this.definition.visitor !== "function")
            return input;
        // OH NOE: before models refactor we were only running type visitors for document types when they weren't relationship fields. In other words document/node visitors only run on the top level inserted node/document, not on any fields of that type
        if (this.definition.isNodeType && !field.isRootValue)
            return input;
        return this.definition.ModelWalker.visitInputValue(input, treeContext.visitorState);
    }
    parseVisitedInputSingleLocalized(maybeLocalized, field, treeContext) {
        if (typeof maybeLocalized === `undefined` || maybeLocalized === null) {
            // we're not returning the parsed input here because in the case there's no data,
            // we still need to run validation. This will throw an error if the field value is not nullable
            // below we will still return a localized object shape where the values of locale fields are null/undefined
            this.parseVisitedInputSingle(maybeLocalized, field, {
                ...treeContext,
                path: [
                    ...treeContext.path,
                    this.definition.ModelBuilder.defaultLocale?.code ||
                        "default_locale_missing",
                ],
            });
        }
        const localized = this.defaultLocalizeFieldValue(maybeLocalized);
        return this.convertObjectLocaleValues(localized, (objectValue, locale) => this.parseVisitedInputSingle(objectValue, field, {
            ...treeContext,
            path: [...treeContext.path, locale],
        }), treeContext);
    }
    toOutputValueSingle(input, field, treeContext) {
        if (this.definition.runtime &&
            // the treeContext.path will be empty when formatting data at runtime
            // if it's not empty then we're currently processing a runtime field at sourcing time so we need to skip it
            // we will also return null here when a runtime object has another nested runtime object inside of it and we're processing the nested runtime object.
            // we return null in that case because GraphQLs recursive resolver execution will call the nested runtime resolver which will lead to this code path again, and we don't want to double process the data
            treeContext.path.length !== 0) {
            return null;
        }
        const visited = 
        // if the field is localized and the field value is also a localized object
        field.localized && !this.inputNeedsDefaultLocalization(input)
            ? // visit each localized value
                this.convertObjectLocaleValues(input, // <- !inputNeedsDefaultLocalization implies this. TODO: refactor this to remove `as`
                (fieldVal) => {
                    return this.maybeVisitSingleValue(fieldVal, field, treeContext);
                }, treeContext)
            : // otherwise visit the input directly, it's not a localized object
                this.maybeVisitSingleValue(input, field, treeContext);
        if (!visited && !field.required) {
            return null;
        }
        switch (this.runtimePlatform) {
            case "netlify-create": {
                if (field.localized) {
                    const parsed = this.parseVisitedInputSingleLocalized(visited, field, treeContext);
                    return this.toCreateSingleFieldValueLocalized(parsed, field, treeContext);
                }
                else {
                    return this.toCreateSingleFieldValue(this.parseVisitedInputSingle(visited, field, treeContext), field, treeContext);
                }
            }
            case "netlify-connect": {
                if (field.localized) {
                    const parsed = this.parseVisitedInputSingleLocalized(visited, field, treeContext);
                    return this.toConnectSingleFieldValueLocalized(parsed, field, treeContext);
                }
                else {
                    return this.toConnectSingleFieldValue(this.parseVisitedInputSingle(visited, field, treeContext), field, treeContext);
                }
            }
        }
    }
    toListFieldValue(input, field, treeContext) {
        if (!input && field.list !== `required`)
            return null;
        switch (this.runtimePlatform) {
            case "netlify-create": {
                return this.toCreateListFieldValue(input, field, treeContext);
            }
            case "netlify-connect": {
                return this.toConnectListFieldValue(input, field, treeContext);
            }
        }
    }
    notImplemented(methodName) {
        return new Error(`ModelTransformer.${methodName}() not implemented for type ${this.definition.getTypeName()} of kind ${this.definition.kind}`);
    }
    removeObjectKeysThatHaveNoFieldWithThatName(visited) {
        // Remove any keys that aren't defined fields
        Object.keys(visited || {}).forEach((key) => {
            const fieldName = this.definition.getFinalFieldName(key, visited?.__typename);
            if (!this.definition.ModelWalker.allowedFieldNames.has(fieldName)) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete visited[key];
            }
        });
        return visited;
    }
    toConnectFieldsDefinitionSDL() {
        const { definition } = this;
        let sdl = ``;
        const typeCustomizations = definition.ModelBuilder.getTypeCustomizations(definition.getTypeName()) ||
            // Netlify UI sends customizations that include the prefix
            definition.ModelBuilder.getTypeCustomizations(definition.prefixedTypeName());
        for (const field of definition.fields) {
            const fieldName = field.name;
            const { type } = field;
            if (field.gql?.hidden === true) {
                continue;
            }
            let runtimeModel;
            typeCustomizations?.fieldCustomizations?.forEach((fieldCustomization) => {
                if (fieldCustomization.mode === "runtime" &&
                    fieldCustomization.name === field.name) {
                    const connector = getGlobalConnectorInstance(fieldCustomization.connectorName, fieldCustomization.instanceID);
                    runtimeModel = connector?.ModelBuilder.models.get(fieldCustomization.type);
                }
            });
            const fieldTypeName = definition.getDefinedTypeName(type, fieldName);
            const transformer = runtimeModel?.ModelTransformer ||
                this.definition.parseNameToTransformer(fieldTypeName);
            const resolvedField = this.definition.resolveModelField(field, definition);
            if (runtimeModel) {
                resolvedField.type = runtimeModel;
                resolvedField.runtime = true;
            }
            const fieldModel = runtimeModel || this.definition.ModelBuilder.models.get(fieldTypeName);
            let authDirective = ``;
            if (fieldModel) {
                const additionalFieldLabels = this.definition.fieldAuthLabels[fieldName];
                authDirective = fieldModel.getAuthorizationDirectiveSDL(additionalFieldLabels);
            }
            else {
                authDirective =
                    this.definition.getAuthorizationDirectiveForScalarFieldSDL(fieldName);
            }
            let fieldSdl = ``;
            if (authDirective) {
                fieldSdl = transformer.toConnectFieldDefinition({
                    ...resolvedField,
                    // auth directive fields must be nullable or unauthed queries will break with unrelated errors about
                    // returning null for non nullable fields
                    required: false,
                    list: resolvedField.list ? true : undefined,
                });
            }
            else {
                fieldSdl = transformer.toConnectFieldDefinition(resolvedField);
            }
            if (!fieldSdl)
                continue;
            fieldSdl += authDirective;
            sdl += fieldSdl;
            sdl += "\n";
            if (field.localized) {
                switch (this.definition.ModelBuilder.runtimePlatform) {
                    case "netlify-connect":
                        for (const { code } of this.definition.ModelBuilder.locales) {
                            const slugCode = slugifyLocale(code);
                            const localizedFieldName = `${fieldName}__${slugCode}`;
                            sdl += `  ${localizedFieldName}: ${this.modelFieldToGraphQlFieldType(resolvedField)}${this.modelFieldToLinkDirective({
                                ...resolvedField,
                                name: localizedFieldName,
                            }, resolvedField.type.isNodeType ? `id` : undefined)} ${this.proxyFrom(`${fieldName}.${slugCode}`)}\n`;
                        }
                        break;
                    case "netlify-create":
                        // TODO: we may need something like this to support filtering by localized field values in Create
                        // in Connect the fieldName__locale fields can be used to filter, but in Create, those don't exist
                        // As of Jun 10th 2024 this wasn't part of requirements for shipping field localization, and I couldn't get this working properly. So I'm leaving this snippet here incase we need to pick back up from this point.
                        //
                        // for (const { code } of this.definition.ModelBuilder.locales) {
                        //   const linkDirective = ` @link(from: "${fieldName}.locales.${code}.value"${
                        //     this.definition?.isMixedUnion ? ` keepObjects: true` : ``
                        //   })`;
                        //
                        //   sdl += `  ${fieldName}__${slugifyLocale(code)}: ${this.modelFieldToGraphQlFieldType(resolvedField)}${linkDirective}\n`;
                        // }
                        break;
                }
            }
        }
        return sdl;
    }
    modelFieldToGraphQlFieldType(modelField, opts) {
        const listOpen = modelField.list ? `[` : ``;
        const type = opts?.asTypeName ||
            this.definition.prefixedTypeName(this.definition.getDefinedTypeName(modelField.type), modelField);
        // localized fields can't be non null in the gql api as it's extremely common for values besides the default language to be nullable, meaning querying for a non-default locale will almost always lead to query errors
        const nullMark = modelField.required && !modelField.localized ? `!` : ``;
        const listClose = modelField.list ? `]` : ``;
        const listNullMark = modelField.list === "required" ? `!` : ``;
        return listOpen + type + nullMark + listClose + listNullMark;
    }
    // Handles converting a ModelField into an SDL field representation, with null marks, lists, and proxies, depending on the field definition.
    modelFieldToGraphQLFieldSDL(modelField, opts) {
        const description = modelField?.description
            ? `  """${modelField.description}"""\n`
            : ``;
        const fieldName = modelField.name;
        const proxyDirective = this.modelFieldToCreateGraphQLProxy(modelField, opts?.proxyFrom);
        const linkDirective = this.modelFieldToLinkDirective(modelField, opts?.linkFrom);
        const localizedDirective = this.fieldToLocalizedDirective(modelField, opts?.proxyFrom);
        return `${description}  ${fieldName}: ${this.modelFieldToGraphQlFieldType(modelField, opts) + localizedDirective + proxyDirective + linkDirective}`;
    }
    modelFieldToLinkDirective(modelField, linkFrom) {
        return linkFrom && !modelField.type.runtime // if it's dynamic, it will resolve directly, not using @link
            ? ` @link(from: "${modelField.name}.${linkFrom}"${this.definition?.isMixedUnion ? ` keepObjects: true` : ``})`
            : ``;
    }
    fieldToLocalizedDirective(modelField, proxyFrom) {
        if (!modelField.localized) {
            return ``;
        }
        // codes item index maps to the same index in codesProxyFrom
        // ie: for slug "en-US"
        // with @localized(codes: ["fr-CA", "en-US"], codesProxyFrom: ["fieldName.something.fr_CA.value", "fieldName.something.en_US.value"])
        // The server would find the codes index of en-US, and use that index to find the relevant proxy in localCodesProxyFrom.
        // Why not use input objects? Seems content-engine&gatsby&connect never supported complex inputs in directive args.
        // Rather than do a bunch of work to fix it everywhere, this index lookup already works and is simple enough
        return ` @localized(
  codes: [${this.definition.ModelBuilder.locales
            .map((locale) => `"${locale.code}"`)
            .join(`, `)}],
  codesProxyFrom: [${this.definition.ModelBuilder.locales
            .map((locale) => `"${this.fieldToLocaleProxyArg(modelField, proxyFrom, locale.code)}"`)
            .join(", ")}]
)`;
    }
    fieldToLocaleProxyArg(modelField, proxyFrom, locale) {
        if (!locale)
            return ``;
        switch (this.runtimePlatform) {
            case "netlify-create":
                return `${modelField.originalName}.locales.${locale}.${proxyFrom}`;
            case "netlify-connect":
                return `${modelField.name}.${locale}${this.definition.isNodeType ? `.id` : ``}`;
        }
    }
    modelFieldToCreateGraphQLProxy(modelField, proxyFrom) {
        if (modelField.localized) {
            // Add a proxy to the default locale when a field is localized
            // this is so Connect and the visual editor gql api can resolve localized fields without yet having the @locale() directive
            // and also resolve the default locale when @locale() is supported, but not provided from the client query.
            return ` @proxy(from: "${this.fieldToLocaleProxyArg(modelField, proxyFrom, this.definition.ModelBuilder.getDefaultLocale())}")`;
        }
        if (!proxyFrom || modelField.type.runtime) {
            return ``;
        }
        const storedFieldName = this.runtimePlatform === `netlify-create`
            ? // in Create, field data is always stored with the original field name
                modelField.originalName
            : // in Connect we store data as whatever the ModelDefinition name is set to (for perf reasons - don't want to double proxy a field)
                modelField.name;
        return this.editorProxyFrom(`${storedFieldName}.${proxyFrom}`);
    }
    editorProxyFrom(proxyFrom) {
        if (this.runtimePlatform !== `netlify-create`) {
            return ``;
        }
        return this.proxyFrom(proxyFrom);
    }
    proxyFrom(proxyFrom) {
        return ` @proxy(from: "${proxyFrom}")`;
    }
    modelFieldToSharedCreateProperties(modelField) {
        return omitByUndefined({
            name: modelField.originalName,
            default: modelField.editor?.initialValue,
            group: modelField.editor?.group,
            readOnly: modelField.editor?.readOnly,
            hidden: modelField.editor?.hidden,
            label: modelField.editor?.label,
            description: modelField.description,
            localized: modelField.localized,
            // any field names starting with _ are internal mandatory fields.
            // they shouldn't be set as required in the Create UI as content admins
            // don't need to set these fields, connector authors do.
            required: modelField.name.startsWith(`_`)
                ? undefined
                : modelField.required,
            controlType: this.modelFieldToSharedControlType(modelField),
        });
    }
    modelFieldToSharedCreateNumberProperties(modelField) {
        const { max, min, step, unit } = modelField.editor?.numberOptions || {};
        return {
            type: "number",
            min,
            max,
            step,
            unit,
        };
    }
    modelFieldToSharedControlType(field) {
        const controlType = field.editor?.controlType;
        // These aren't Netlify Create control types, the SDK uses them to differentiate between an Asset that's a file or an image.
        if (controlType === `file` || controlType === `image`) {
            return undefined;
        }
        return controlType;
    }
    // converts this SDK model into a top level Connect SDL GraphQL type
    toConnectDefinition(_ctx) {
        throw this.notImplemented(`toConnectDefinition`);
    }
    toConnectFieldLocalizedDefinition(_ctx) {
        throw this.notImplemented(`toConnectDefinition`);
    }
    // converts this model into a field definition within another top level SDL type
    toConnectFieldDefinition(modelField) {
        switch (modelField.list) {
            case "required":
            case true:
                return this.toConnectListFieldDefinition(modelField);
            case false:
            default:
                return this.toConnectSingleFieldDefinition(modelField);
        }
    }
    toConnectSingleFieldDefinition(_modelField) {
        throw this.notImplemented(`toConnectFieldDefinition`);
    }
    toConnectListFieldDefinition(_modelField) {
        throw this.notImplemented(`toConnectFieldDefinition`);
    }
    // converts this model into a top level Create model definition
    toCreateDefinition() {
        throw this.notImplemented(`toCreateDefinition`);
    }
    // converts this model into a field definition at any level on another Create model definition or field
    toCreateFieldDefinition(modelField, parentDefinition) {
        const resolvedModelField = this.definition.resolveModelField(modelField, parentDefinition);
        switch (modelField.list) {
            case "required":
            case true:
                return this.toCreateListFieldDefinition(resolvedModelField);
            case false:
            default:
                return this.toCreateSingleFieldDefinition(resolvedModelField);
        }
    }
    // converts this model into a list field definition at any level on another Create model definition or field
    toCreateSingleFieldDefinition(_modelField) {
        throw this.notImplemented(`toCreateSingleFieldDefinition`);
    }
    // converts this model into a list field definition at any level on another Create model definition or field
    toCreateListFieldDefinition(_modelField) {
        throw this.notImplemented(`toCreateListFieldDefinition`);
    }
    // takes in connector user input data and normalizes it for storage in Netlify Create
    toCreateSingleFieldValue(_input, _field, _treeContext) {
        throw this.notImplemented(`toCreateSingleFieldValue`);
    }
    toCreateSingleFieldValueLocalized(_input, _field, _treeContext) {
        throw this.notImplemented(`toCreateSingleFieldValueLocalized`);
    }
    // same as above but for when this type is used in a list
    toCreateListFieldValue(_input, _field, _treeContext) {
        throw this.notImplemented(`toCreateListFieldValue`);
    }
    toCreateListFieldValueLocalized(input, field, treeContext) {
        return {
            type: `list`,
            localized: true,
            locales: this.convertObjectLocaleValues(input, (value, locale) => {
                if (!Array.isArray(value)) {
                    throw new Error(`Encountered non-array value where an array was expected. This may be a bug in the Netlify SDK.`);
                }
                return {
                    locale,
                    items: value.map((v) => this.toCreateSingleFieldValue(v, {
                        ...field,
                        // need to set list to false because this field is a list type, but we're
                        // processing each item in that list using the field definition.
                        list: false,
                        // Also set localized to false since we're already localizing at this level
                        localized: false,
                    }, { ...treeContext, path: [...treeContext.path, locale] })),
                };
            }, treeContext),
        };
    }
    // same as above but for Netlify Connect data storage
    toConnectSingleFieldValue(_input, _field, _treeContext) {
        throw this.notImplemented(`toConnectSingleFieldValue`);
    }
    toConnectSingleFieldValueLocalized(input, field, treeContext) {
        const formattedLocales = {};
        for (const locale of this.definition.ModelBuilder.locales) {
            const value = input[locale.code];
            if (typeof value === `undefined` || value === null) {
                // if we don't continue here, fields where only one locale is set and the rest are undefined or null will throw errors
                continue;
            }
            formattedLocales[locale.code] = this.toConnectSingleFieldValue(value, field, treeContext);
        }
        return formattedLocales;
    }
    toConnectListFieldValue(_input, _field, _treeContext) {
        throw this.notImplemented(`toConnectListFieldValue`);
    }
    toConnectListFieldValueLocalized(input, field, treeContext) {
        const formattedLocales = {};
        for (const locale of this.definition.ModelBuilder.locales) {
            const value = input[locale.code];
            if (typeof value === `undefined` || value === null) {
                // if we don't continue here, fields where only one locale is set and the rest are undefined or null will throw errors
                continue;
            }
            formattedLocales[locale.code] = this.toConnectListFieldValue(value, { ...field, localized: false }, treeContext);
        }
        return formattedLocales;
    }
    // throws helpful errors when the data that's about to be inserted in the DB is the wrong type
    // "parseVisited" because the connector can insert any shape they want, and then transform it to the right shape with a visitor fn. So we need to validate that it's the right type _after_ they've visited it (if they did visit it - we will still parse here if they didn't. naming?)
    // only runs during local dev so that incorrect data in prod doesn't kill the whole sourcing process. or perhaps we can catch ModelError and only warn in prod, but fail sourcing in dev.
    parseVisitedInputSingle(_visited, _field, _treeContext) {
        throw this.notImplemented(`parseVisitedInputSingle`);
    }
    parseVisitedInputList(_visited, _field, _treeContext) {
        throw this.notImplemented(`parseVisitedInputList`);
    }
}
//# sourceMappingURL=transformer.js.map