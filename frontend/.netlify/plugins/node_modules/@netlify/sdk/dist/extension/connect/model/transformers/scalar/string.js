import { ModelError } from "../../error.js";
import { omitByUndefined } from "../../../utils/omit-by-undefined.js";
import { ScalarBaseTransformer } from "../scalar.js";
export class StringTransformer extends ScalarBaseTransformer {
    get visualEditorFieldType() {
        return "string";
    }
    // use Editor.Field here so string-like types can extend this class with a more specific type
    toCreateSingleFieldDefinition(modelField) {
        return omitByUndefined({
            ...this.modelFieldToSharedCreateProperties(modelField),
            type: this.visualEditorFieldType,
        });
    }
    toCreateListFieldDefinition(modelField) {
        return omitByUndefined({
            ...this.modelFieldToSharedCreateProperties(modelField),
            type: "list",
            items: {
                type: this.visualEditorFieldType,
            },
        });
    }
    parseVisitedInputSingle(input, field, treeContext) {
        const isString = typeof input === `string`;
        if (!input && !field.required && !isString) {
            return null;
        }
        const fieldIsNullOrUndefined = typeof input === `undefined` && input !== null;
        if (field.required && fieldIsNullOrUndefined) {
            throw new ModelError(`Insertion failed validation\n  for model "${this.definition.getTypeName()}"\n  on required field "${field.name}" ${`\n  at input path ${treeContext.path.join(`.`)} <- this field\n  required field type "${field.type.getTypeName()}${field.list ? `[]` : ``}"\n  provided field value:\n    ${field.name} is "${JSON.stringify(input, null, 2)}"`.substring(0, 250) + `\n...`}`);
        }
        const isNumber = typeof input === `number`;
        if (!isString && !isNumber) {
            throw new ModelError(`Input data for field ${field.name} is not a string but should be. Received ${typeof input}.\n\n${JSON.stringify(input, null, 2)}`);
        }
        return isNumber ? String(input) : input;
    }
}
export class MarkdownTransformer extends StringTransformer {
    isVisualEditorType = true;
    get visualEditorFieldType() {
        return "markdown";
    }
}
export class UrlTransformer extends StringTransformer {
    isVisualEditorType = true;
    get visualEditorFieldType() {
        return "url";
    }
}
export class TextTransformer extends StringTransformer {
    isVisualEditorType = true;
    get visualEditorFieldType() {
        return "text";
    }
}
export class SlugTransformer extends StringTransformer {
    isVisualEditorType = true;
    get visualEditorFieldType() {
        return "slug";
    }
}
export class HtmlTransformer extends StringTransformer {
    isVisualEditorType = true;
    get visualEditorFieldType() {
        return "html";
    }
}
export class ColorTransformer extends StringTransformer {
    isVisualEditorType = true;
    get visualEditorFieldType() {
        return "color";
    }
}
// NOTE: this is used for the main id: ID! field on document types, but it's also used for any user-defined field of type ID
// also, for now ID is handled exactly like a string. In the future we could add additional transformations or validations here.
export class IDTransformer extends StringTransformer {
    // @ts-ignore we've been returning id: ID field in this non-stackbit compatible format for a long time.
    // it's used as the record ID in lmdb
    // TODO: there's a better way to do this
    toCreateSingleFieldValue(input) {
        return input;
    }
    toCreateSingleFieldDefinition() {
        // TODO: ID type fields should be allowed, we really only want to remove the field definition for any Document.id
        return null; // strip all ID type fields out - this is what we were doing before the transformer refactor
    }
    get visualEditorFieldType() {
        return "string";
    }
}
//# sourceMappingURL=string.js.map