import { ModelError } from "../error.js";
import { ModelTransformer, } from "../transformer.js";
export class EnumTransformer extends ModelTransformer {
    /*
     * Connect/Create input data parsing (runs before data normalizers for each platform below)
     */
    parseVisitedInputList(input, field, treeContext) {
        const isNullable = field.list !== `required`;
        if (isNullable && !input) {
            return null;
        }
        if (!Array.isArray(input)) {
            throw new ModelError(`Input data for field ${field.name} is not an array but should be. Received ${typeof input}.\n\n${JSON.stringify(input, null, 2)}`);
        }
        return input.map((item) => this.parseVisitedInputSingle(item, field, treeContext));
    }
    parseVisitedInputSingle(modelValue, field, treeContext) {
        if (process.env.NODE_ENV === `production`)
            return modelValue;
        const { path } = treeContext;
        if (!field.required && !modelValue)
            return null;
        if (typeof modelValue !== `string`) {
            throw new ModelError(`Enum value at ${path.join(`.`)} is not a string but is required to be a string value. Found ${JSON.stringify(modelValue)}.\n\nAllowed values: ${this.definition?.values?.map((v) => v.value).join(`, `)}`);
        }
        if (!this.definition.values?.find((storedValue) => storedValue.value === modelValue)) {
            const validValues = this.definition.values
                ?.map((v) => v.value)
                .join(`, `);
            throw new ModelError(`Enum value at ${path.join(".")} is "${modelValue}" but must be one of: ${validValues}`);
        }
        return modelValue;
    }
    toCreateDefinition() {
        // Create doesn't have global definitions for enum types
        return null;
    }
    /*
     * Connect schema definitions
     */
    toConnectDefinition() {
        let sdl = ``;
        if (this.definition.description) {
            sdl += `"""${this.definition.description}"""\n`;
        }
        const enumValues = this.definition.values?.map((value) => {
            return `"""${value.label}"""\n  ${value.value}`;
        });
        sdl += `enum ${this.definition.prefixedTypeName()} {
  ${enumValues?.join(`\n  `)}
}`;
        return sdl;
    }
    toConnectSingleFieldDefinition(modelField) {
        return this.modelFieldToGraphQLFieldSDL(modelField, {
            proxyFrom: `value`,
        });
    }
    toConnectListFieldDefinition(modelField) {
        return this.modelFieldToGraphQLFieldSDL(modelField, {
            proxyFrom: `items.value`,
        });
    }
    /*
     * Create schema definitions
     */
    toCreateListFieldDefinition(field) {
        return {
            type: "list",
            ...this.modelFieldToSharedCreateProperties(field),
            items: {
                type: "enum",
                options: this.getEditorEnumOptions(),
            },
        };
    }
    toCreateSingleFieldDefinition(field) {
        return {
            ...this.modelFieldToSharedCreateProperties(field),
            type: "enum",
            options: this.getEditorEnumOptions(),
        };
    }
    getEditorEnumOptions() {
        const fieldModel = this.definition;
        if (!fieldModel?.values) {
            throw new ModelError(`Enum type "${this.definition.getTypeName()}" is missing values. This is a bug in the Netlify SDK as at this point in the code, enums should always have values.`);
        }
        const normalizedValues = fieldModel.values.map((e) => {
            if (e.value === e.label) {
                return e.value;
            }
            return e;
        });
        return normalizedValues;
    }
    /*
     * Connect data normalizers
     */
    toConnectSingleFieldValue(input) {
        return input;
    }
    toConnectListFieldValue(input) {
        return input;
    }
    /*
     * Create data normalizers
     */
    toCreateListFieldValue(input, field, treeContext) {
        const { path, visitorState } = treeContext;
        const listItems = input?.map?.((node, index) => {
            return field.type.ModelWalker.coerceModelValue(node, { ...field, list: false }, [...path, `[${index}]`], visitorState);
        });
        return {
            type: `list`,
            items: listItems,
        };
    }
    toCreateSingleFieldValueLocalized(input, _field, treeContext) {
        return {
            type: `enum`,
            localized: true,
            locales: this.convertObjectLocaleValues(input, (value, locale) => {
                return {
                    locale,
                    value,
                };
            }, treeContext),
        };
    }
    toCreateSingleFieldValue(input) {
        return {
            type: `enum`,
            value: input,
        };
    }
}
//# sourceMappingURL=enum.js.map