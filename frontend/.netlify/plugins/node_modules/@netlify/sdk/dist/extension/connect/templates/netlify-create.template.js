// the next line is replaced with a generated object at bundle time
const templateData = global.$SDK;
import path from "path";
// @ts-expect-error this will exist at runtime not compile time - you can find the source files in "connector/utils/instance-id.ts"
import { makeInstanceID, makeUniqueInstanceIDTracker } from "./instance-id.js";
import { fileURLToPath } from "url";
import { createRequire } from "module";
const { checkUnique } = makeUniqueInstanceIDTracker();
export default class CreateConnector {
    // prevent stackbit dev from bundling index.js with esbuild by using a random filename since it's already bundled
    extension = import(templateData.extensionImportPath).then((m) => {
        const extension = m.extension;
        const connectorDefinition = extension.netlifyConnectPlugin;
        if (!connectorDefinition)
            throw new Error(`No connector found`);
        this.connector = connectorDefinition.getConnectorInstance(this.options, templateData.configSlug);
        this.connector.setRuntimeSupportsCreate();
        if (typeof this.connector.definedImplementations["scheduledActions.create"] === "function" &&
            typeof this.connector.definedImplementations["scheduledActions.update"] === "function" &&
            typeof this.connector.definedImplementations["scheduledActions.delete"] === "function") {
            this.getScheduledActions = () => this.bridge.getScheduledActions();
            this.createScheduledAction = (args) => this.bridge.createScheduledAction(args);
            this.updateScheduledAction = (args) => this.bridge.updateScheduledAction(args);
            this.cancelScheduledAction = (args) => this.bridge.cancelScheduledAction(args);
        }
        if (templateData.addContentEngineConfig) {
            this.getContentEngineConfig = () => {
                const __filename = fileURLToPath(import.meta.url);
                const __dirname = path.dirname(__filename);
                return {
                    connector: templateData.configSlug,
                    plugins: [
                        {
                            resolve: createRequire(import.meta.url).resolve(path.join(__dirname, "package.json")),
                            options: this.options || {},
                        },
                    ],
                };
            };
        }
        return extension;
    });
    options = {};
    instanceID;
    // @ts-ignore
    connector;
    constructor(args) {
        if (args?.options) {
            this.options = args.options;
        }
        // checkUnique will throw if the instance ID is not unique to the memory scope of this file.
        this.instanceID = checkUnique(args?.options?.instanceID ?? makeInstanceID(this.options));
    }
    get bridge() {
        return this.connector.csiModuleAPI;
    }
    getContentSourceType() {
        return this.connector?.slug || templateData.configSlug;
    }
    getProjectId() {
        return this.instanceID;
    }
    async getVersion() {
        return { interfaceVersion: "0.7.3", contentSourceVersion: "0.1" };
    }
    getProjectEnvironment() {
        return "main";
    }
    reset() {
        return Promise.resolve();
    }
    destroy() {
        return Promise.resolve();
    }
    async getSchema() {
        const models = await this.getModels();
        const locales = this.getLocales();
        return {
            models: models || [],
            locales: locales || [],
            context: {},
        };
    }
    // validateDocuments will soon be replaced/deprecated in Netlify Connect - so just return an empty array of errors
    validateDocuments() {
        return Promise.resolve({
            errors: [],
        });
    }
    // bridge methods to the bundled connector
    getLocales = () => this.bridge.getLocales();
    getProjectManageUrl = () => this.bridge.getProjectManageUrl();
    init = (args) => this.bridge.init(args);
    getDocuments = () => this.bridge.getDocuments();
    getAssets = () => this.bridge.getAssets();
    hasAccess = (args) => this.bridge.hasAccess(args);
    uploadAsset = (args) => this.bridge.uploadAsset(args);
    updateDocument = (args) => this.bridge.updateDocument(args);
    createDocument = (args) => this.bridge.createDocument(args);
    deleteDocument = (args) => this.bridge.deleteDocument(args);
    publishDocuments = (args) => this.bridge.publishDocuments(args);
    getModels = () => this.bridge.getModels();
    getScheduledActions;
    createScheduledAction;
    updateScheduledAction;
    cancelScheduledAction;
    getContentEngineConfig;
}
//# sourceMappingURL=netlify-create.template.js.map