"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.delayedCall = exports.isInternalAction = exports.getElapsedTimeMS = exports.getActivity = exports.getGlobalStatus = void 0;
exports.isActivityInProgress = isActivityInProgress;
const index_1 = require("./index");
const convert_hrtime_1 = __importDefault(require("convert-hrtime"));
const constants_1 = require("../constants");
const signal_exit_1 = __importDefault(require("signal-exit"));
function isActivityInProgress(activityStatus) {
    return (activityStatus === constants_1.ActivityStatuses.InProgress ||
        activityStatus === constants_1.ActivityStatuses.NotStarted);
}
const getGlobalStatus = (id, status) => {
    const { logs } = (0, index_1.getStore)().getState();
    const currentActivities = [id, ...Object.keys(logs.activities)];
    return currentActivities.reduce((generatedStatus, activityId) => {
        const activityStatus = activityId === id ? status : logs.activities[activityId].status;
        if (isActivityInProgress(activityStatus)) {
            return constants_1.ActivityStatuses.InProgress;
        }
        else if (activityStatus === constants_1.ActivityStatuses.Failed &&
            generatedStatus !== constants_1.ActivityStatuses.InProgress) {
            return constants_1.ActivityStatuses.Failed;
        }
        else if (activityStatus === constants_1.ActivityStatuses.Interrupted &&
            generatedStatus !== constants_1.ActivityStatuses.InProgress) {
            return constants_1.ActivityStatuses.Interrupted;
        }
        return generatedStatus;
    }, constants_1.ActivityStatuses.Success);
};
exports.getGlobalStatus = getGlobalStatus;
const getActivity = (id) => (0, index_1.getStore)().getState().logs.activities[id];
exports.getActivity = getActivity;
/**
 * @returns {Number} Milliseconds from activity start
 */
const getElapsedTimeMS = (activity) => {
    const elapsed = process.hrtime(activity.startTime);
    return (0, convert_hrtime_1.default)(elapsed).milliseconds;
};
exports.getElapsedTimeMS = getElapsedTimeMS;
const isInternalAction = (action) => {
    switch (action.type) {
        case constants_1.Actions.PendingActivity:
        case constants_1.Actions.CancelActivity:
        case constants_1.Actions.ActivityErrored:
            return true;
        case constants_1.Actions.StartActivity:
        case constants_1.Actions.EndActivity:
            return action.payload.type === constants_1.ActivityTypes.Hidden;
        default:
            return false;
    }
};
exports.isInternalAction = isInternalAction;
/**
 * Like setTimeout, but also handle signalExit
 */
const delayedCall = (fn, timeout) => {
    const fnWrap = () => {
        fn();
        clear();
    };
    const timeoutID = setTimeout(fnWrap, timeout);
    const cancelSignalExit = (0, signal_exit_1.default)(fnWrap);
    const clear = () => {
        clearTimeout(timeoutID);
        cancelSignalExit();
    };
    return clear;
};
exports.delayedCall = delayedCall;
//# sourceMappingURL=utils.js.map