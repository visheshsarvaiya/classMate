"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setLogs = exports.activityTick = exports.setActivityTotal = exports.setActivityStatusText = exports.setActivityErrored = exports.updateActivity = exports.endActivity = exports.startActivity = exports.createPendingActivity = exports.createLog = exports.setStatus = void 0;
const core_utils_1 = require("../../core-utils");
// import { trackCli } from "gatsby-telemetry"
const signal_exit_1 = __importDefault(require("signal-exit"));
const _1 = require(".");
const constants_1 = require("../constants");
const utils_1 = require("./utils");
const ActivityStatusToLogLevel = {
    [constants_1.ActivityStatuses.Interrupted]: constants_1.ActivityLogLevels.Interrupted,
    [constants_1.ActivityStatuses.Failed]: constants_1.ActivityLogLevels.Failed,
    [constants_1.ActivityStatuses.Success]: constants_1.ActivityLogLevels.Success,
};
let weShouldExit = false;
(0, signal_exit_1.default)(() => {
    weShouldExit = true;
});
let cancelDelayedSetStatus;
let pendingStatus = ``;
// We debounce "done" statuses because activities don't always overlap
// and there is timing window after one activity ends and before next one starts
// where technically we are "done" (all activities are done).
// We don't want to emit multiple SET_STATUS events that would toggle between
// IN_PROGRESS and SUCCESS/FAILED in short succession in those cases.
const setStatus = (status, force = false) => (dispatch) => {
    const currentStatus = (0, _1.getStore)().getState().logs.status;
    if (cancelDelayedSetStatus) {
        cancelDelayedSetStatus();
        cancelDelayedSetStatus = null;
    }
    if (status !== currentStatus &&
        (status === constants_1.ActivityStatuses.InProgress || force || weShouldExit)) {
        dispatch({
            type: constants_1.Actions.SetStatus,
            payload: status,
        });
        pendingStatus = ``;
    }
    else {
        // use pending status if truthy, fallback to current status if we don't have pending status
        const pendingOrCurrentStatus = pendingStatus || currentStatus;
        if (status !== pendingOrCurrentStatus) {
            pendingStatus = status;
            cancelDelayedSetStatus = (0, utils_1.delayedCall)(() => {
                (0, exports.setStatus)(status, true)(dispatch);
            }, 1000);
        }
    }
};
exports.setStatus = setStatus;
const createLog = ({ level, text, statusText, duration, group, code, type, category, filePath, location, docsUrl, context, activity_current, activity_total, activity_type, activity_uuid, stack, pluginName, }) => {
    return {
        type: constants_1.Actions.Log,
        payload: {
            level,
            text: !text ? `\u2800` : text,
            statusText,
            duration,
            group,
            code,
            type,
            category,
            filePath,
            location,
            docsUrl,
            context,
            activity_current,
            activity_total,
            activity_type,
            activity_uuid,
            timestamp: new Date().toJSON(),
            stack,
            pluginName,
        },
    };
};
exports.createLog = createLog;
const createPendingActivity = ({ id, status = constants_1.ActivityStatuses.NotStarted, }) => {
    const globalStatus = (0, utils_1.getGlobalStatus)(id, status);
    return [
        (0, exports.setStatus)(globalStatus),
        {
            type: constants_1.Actions.PendingActivity,
            payload: {
                id,
                type: constants_1.ActivityTypes.Pending,
                startTime: process.hrtime(),
                status,
            },
        },
    ];
};
exports.createPendingActivity = createPendingActivity;
const startActivity = ({ id, text, type, status = constants_1.ActivityStatuses.InProgress, current, total, }) => {
    const globalStatus = (0, utils_1.getGlobalStatus)(id, status);
    return [
        (0, exports.setStatus)(globalStatus),
        {
            type: constants_1.Actions.StartActivity,
            payload: {
                id,
                uuid: core_utils_1.uuid.v4(),
                text,
                type,
                status,
                startTime: process.hrtime(),
                statusText: ``,
                current,
                total,
            },
        },
    ];
};
exports.startActivity = startActivity;
const endActivity = ({ id, status, }) => {
    const activity = (0, utils_1.getActivity)(id);
    if (!activity) {
        return null;
    }
    const actionsToEmit = [];
    const durationMS = (0, utils_1.getElapsedTimeMS)(activity);
    const durationS = durationMS / 1000;
    if (activity.type === constants_1.ActivityTypes.Pending) {
        actionsToEmit.push({
            type: constants_1.Actions.CancelActivity,
            payload: {
                id,
                status: constants_1.ActivityStatuses.Cancelled,
                type: activity.type,
                duration: durationS,
            },
        });
    }
    else if (activity.status === constants_1.ActivityStatuses.InProgress) {
        // trackCli(`ACTIVITY_DURATION`, {
        //   name: activity.text,
        //   duration: Math.round(durationMS),
        // })
        if (activity.errored) {
            status = constants_1.ActivityStatuses.Failed;
        }
        actionsToEmit.push({
            type: constants_1.Actions.EndActivity,
            payload: {
                uuid: activity.uuid,
                id,
                status,
                duration: durationS,
                type: activity.type,
            },
        });
        if (activity.type !== constants_1.ActivityTypes.Hidden) {
            actionsToEmit.push((0, exports.createLog)({
                text: activity.text,
                level: ActivityStatusToLogLevel[status],
                duration: durationS,
                statusText: activity.statusText ||
                    (status === constants_1.ActivityStatuses.Success &&
                        activity.type === constants_1.ActivityTypes.Progress
                        ? `${activity.current}/${activity.total} ${((activity.total || 0) / durationS).toFixed(2)}/s`
                        : undefined),
                activity_uuid: activity.uuid,
                activity_current: activity.current,
                activity_total: activity.total,
                activity_type: activity.type,
            }));
        }
    }
    const globalStatus = (0, utils_1.getGlobalStatus)(id, status);
    actionsToEmit.push((0, exports.setStatus)(globalStatus));
    return actionsToEmit;
};
exports.endActivity = endActivity;
const updateActivity = ({ id = ``, ...rest }) => {
    const activity = (0, utils_1.getActivity)(id);
    if (!activity) {
        return null;
    }
    return {
        type: constants_1.Actions.UpdateActivity,
        payload: {
            uuid: activity.uuid,
            id,
            ...rest,
        },
    };
};
exports.updateActivity = updateActivity;
const setActivityErrored = ({ id, }) => {
    const activity = (0, utils_1.getActivity)(id);
    if (!activity) {
        return null;
    }
    return {
        type: constants_1.Actions.ActivityErrored,
        payload: {
            id,
        },
    };
};
exports.setActivityErrored = setActivityErrored;
const setActivityStatusText = ({ id, statusText, }) => (0, exports.updateActivity)({
    id,
    statusText,
});
exports.setActivityStatusText = setActivityStatusText;
const setActivityTotal = ({ id, total, }) => (0, exports.updateActivity)({
    id,
    total,
});
exports.setActivityTotal = setActivityTotal;
const activityTick = ({ id, increment = 1, }) => {
    const activity = (0, utils_1.getActivity)(id);
    if (!activity) {
        return null;
    }
    return (0, exports.updateActivity)({
        id,
        current: (activity.current || 0) + increment,
    });
};
exports.activityTick = activityTick;
const setLogs = (logs) => {
    return {
        type: constants_1.Actions.SetLogs,
        payload: logs,
    };
};
exports.setLogs = setLogs;
//# sourceMappingURL=internal-actions.js.map