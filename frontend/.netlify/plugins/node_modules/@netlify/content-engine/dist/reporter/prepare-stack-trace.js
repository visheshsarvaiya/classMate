"use strict";
/* Code borrowed and based on
 * https://github.com/evanw/node-source-map-support/blob/master/source-map-support.js
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrorWithCodeFrame = void 0;
exports.prepareStackTrace = prepareStackTrace;
const fs_1 = require("fs");
const code_frame_1 = require("@babel/code-frame");
const stack_trace_1 = __importDefault(require("stack-trace"));
const trace_mapping_1 = require("@jridgewell/trace-mapping");
const path = __importStar(require("path"));
class ErrorWithCodeFrame extends Error {
    codeFrame = ``;
    constructor(error) {
        super(error.message);
        // We must use getOwnProperty because keys like `stack` are not enumerable,
        // but we want to copy over the entire error
        Object.getOwnPropertyNames(error).forEach((key) => {
            this[key] = error[key];
        });
    }
}
exports.ErrorWithCodeFrame = ErrorWithCodeFrame;
function prepareStackTrace(error, sourceOfMainMap) {
    const newError = new ErrorWithCodeFrame(error);
    // source point to single map, but with code splitting for build-html we need to handle more maps
    // we use fact that all .map files will be in same dir as main one here
    const bundleDir = path.dirname(sourceOfMainMap);
    const bundleDirMapFiles = (0, fs_1.readdirSync)(bundleDir)
        .filter((fileName) => fileName.endsWith(`.js.map`))
        .map((fileName) => path.join(bundleDir, fileName));
    const maps = bundleDirMapFiles.map((source) => new trace_mapping_1.TraceMap((0, fs_1.readFileSync)(source, `utf8`)));
    const stack = stack_trace_1.default
        .parse(newError)
        .map((frame) => wrapCallSite(maps, frame))
        .filter((frame) => `wasConverted` in frame &&
        (!frame.getFileName() ||
            !frame
                .getFileName()
                .match(/^webpack:\/+(lib\/)?(webpack\/|\.cache\/)/)));
    newError.codeFrame = getErrorSource(maps, stack[0]);
    newError.stack =
        `${newError.name}: ${newError.message}\n` +
            stack.map((frame) => `    at ${frame}`).join(`\n`);
    return newError;
}
function getErrorSource(maps, topFrame) {
    let source;
    for (const map of maps) {
        source = (0, trace_mapping_1.sourceContentFor)(map, topFrame.getFileName());
        if (source) {
            break;
        }
    }
    return source
        ? (0, code_frame_1.codeFrameColumns)(source, {
            start: {
                line: topFrame.getLineNumber(),
                column: topFrame.getColumnNumber(),
            },
        }, {
            highlightCode: true,
        })
        : ``;
}
function wrapCallSite(maps, frame) {
    const source = frame.getFileName();
    if (!source)
        return frame;
    const position = getPosition({ maps, frame });
    if (!position.source)
        return frame;
    return {
        getFileName: () => position.source || ``,
        getLineNumber: () => position.line || 0,
        getColumnNumber: () => (position.column || 0) + 1,
        getScriptNameOrSourceURL: () => position.source || ``,
        toString: CallSiteToString,
        wasConverted: true,
    };
}
function getPosition({ maps, frame, }) {
    if (frame.getFileName().includes(`webpack:`)) {
        // if source-map-register is initiated, stack traces would already be converted
        return {
            column: frame.getColumnNumber() - 1,
            line: frame.getLineNumber(),
            source: frame
                .getFileName()
                .slice(frame.getFileName().indexOf(`webpack:`))
                .replace(/webpack:\/+/g, `webpack://`),
            name: null,
        };
    }
    const line = frame.getLineNumber();
    const column = frame.getColumnNumber();
    for (const map of maps) {
        const test = (0, trace_mapping_1.originalPositionFor)(map, { line, column });
        if (test.source) {
            return test;
        }
    }
    return { source: null, column: null, line: null, name: null };
}
// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js.
function CallSiteToString() {
    // @ts-ignore
    const _this = this; // eslint-disable-line @typescript-eslint/no-this-alias
    const self = _this;
    let fileName;
    let fileLocation = ``;
    if (`isNative` in self && self.isNative()) {
        fileLocation = `native`;
    }
    else {
        fileName =
            (`getScriptNameOrSourceURL` in self && self.getScriptNameOrSourceURL()) ||
                (`getFileName` in self && self.getFileName());
        if (!fileName && `isEval` in self && self.isEval()) {
            fileLocation = `${self.getEvalOrigin()}, `;
        }
        if (fileName) {
            fileLocation += fileName.replace(/^webpack:\/+(lib\/)?/, ``);
        }
        else {
            // Source code does not originate from a file and is not native, but we
            // can still get the source position inside the source string, e.g. in
            // an eval string.
            fileLocation += `<anonymous>`;
        }
        const lineNumber = `getLineNumber` in self ? self.getLineNumber() : null;
        if (lineNumber != null) {
            fileLocation += `:${lineNumber}`;
            const columnNumber = `getColumnNumber` in self ? self.getColumnNumber() : null;
            if (columnNumber) {
                fileLocation += `:${columnNumber}`;
            }
        }
    }
    let line = ``;
    const functionName = `getFunctionName` in self ? self.getFunctionName() : ``;
    let addSuffix = true;
    const isConstructor = `isConstructor` in self && self.isConstructor();
    const methodName = `getMethodName` in self ? self.getMethodName() : ``;
    const typeName = `getTypeName` in self ? self.getTypeName() : ``;
    const isMethodCall = methodName &&
        !((`isToplevel` in self && self.isToplevel()) || isConstructor);
    if (isMethodCall && functionName) {
        if (typeName && functionName.indexOf(typeName) != 0) {
            line += `${typeName}.`;
        }
        line += functionName;
        if (functionName.indexOf(`.` + methodName) !=
            functionName.length - (methodName || ``).length - 1) {
            line += ` [as ${methodName}]`;
        }
    }
    else if (typeName && !functionName) {
        line += typeName + `.` + (methodName || `<anonymous>`);
    }
    else if (isConstructor) {
        line += `new ` + (functionName || `<anonymous>`);
    }
    else if (functionName) {
        line += functionName;
    }
    else {
        line += fileLocation;
        addSuffix = false;
    }
    if (addSuffix)
        line += ` (${fileLocation})`;
    return line;
}
//# sourceMappingURL=prepare-stack-trace.js.map