"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sanitizeStructuredStackTrace = void 0;
exports.getErrorFormatter = getErrorFormatter;
exports.createErrorFromString = createErrorFromString;
const pretty_error_1 = __importDefault(require("pretty-error"));
const prepare_stack_trace_1 = require("./prepare-stack-trace");
const core_utils_1 = require("../core-utils");
const fs_extra_1 = require("fs-extra");
const code_frame_1 = require("@babel/code-frame");
const packagesToSkip = [
    `core-js`,
    `bluebird`,
    `regenerator-runtime`,
    `graphql`,
];
const packagesToSkipTest = new RegExp(`node_modules[\\/](${packagesToSkip.join(`|`)})`);
// TO-DO: move this this out of this file (and probably delete this file completely)
// it's here because it re-implements similar thing as `pretty-error` already does
const sanitizeStructuredStackTrace = (stack) => {
    // first filter out not useful call sites
    stack = stack.filter((callSite) => {
        if (!callSite.getFileName()) {
            return false;
        }
        if (packagesToSkipTest.test(callSite.getFileName())) {
            return false;
        }
        if (callSite.getFileName().includes(`asyncToGenerator.js`)) {
            return false;
        }
        if ((0, core_utils_1.isNodeInternalModulePath)(callSite.getFileName())) {
            return false;
        }
        return true;
    });
    // then sanitize individual call site objects to make sure we don't
    // emit objects with extra fields that won't be handled by consumers
    return stack.map((callSite) => {
        return {
            fileName: callSite.getFileName(),
            functionName: callSite.getFunctionName(),
            columnNumber: callSite.getColumnNumber(),
            lineNumber: callSite.getLineNumber(),
        };
    });
};
exports.sanitizeStructuredStackTrace = sanitizeStructuredStackTrace;
function getErrorFormatter() {
    const prettyError = new pretty_error_1.default();
    const baseRender = prettyError.render;
    prettyError.skipNodeFiles();
    prettyError.skipPackage(`regenerator-runtime`, `graphql`, `core-js`);
    // @ts-ignore the type defs in prettyError are wrong
    prettyError.skip((traceLine) => {
        if (traceLine && traceLine.file === `asyncToGenerator.js`)
            return true;
        return false;
    });
    prettyError.appendStyle({
        "pretty-error": {
            marginTop: 1,
        },
        "pretty-error > header": {
            background: `red`,
        },
        "pretty-error > header > colon": {
            color: `white`,
        },
    });
    if (process.env.FORCE_COLOR === `0`) {
        prettyError.withoutColors();
    }
    prettyError.render = (err) => {
        if (Array.isArray(err)) {
            return err.map((e) => prettyError.render(e)).join(`\n`);
        }
        let rendered = baseRender.call(prettyError, err);
        if (`codeFrame` in err)
            rendered = `\n${err.codeFrame}\n${rendered}`;
        return rendered;
    };
    return prettyError;
}
/**
 * Convert a stringified webpack compilation error back into
 * an Error instance so it can be formatted properly
 */
function createErrorFromString(errorOrErrorStack = ``, sourceMapFile) {
    if (typeof errorOrErrorStack === `string`) {
        const errorStr = errorOrErrorStack;
        let [message, ...rest] = errorStr.split(/\r\n|[\n\r]/g);
        // pull the message from the first line then remove the `Error:` prefix
        // FIXME: when https://github.com/AriaMinaei/pretty-error/pull/49 is merged
        message = message.replace(/^(Error:)/, ``);
        const error = new Error(message);
        error.stack = [message, rest.join(`\n`)].join(`\n`);
        error.name = `WebpackError`;
        try {
            if (sourceMapFile) {
                return (0, prepare_stack_trace_1.prepareStackTrace)(error, sourceMapFile);
            }
        }
        catch (err) {
            // don't shadow a real error because of a parsing issue
        }
        return error;
    }
    else {
        if (errorOrErrorStack.forcedLocation) {
            const forcedLocation = errorOrErrorStack.forcedLocation;
            const error = new Error(errorOrErrorStack.message);
            error.stack = `${errorOrErrorStack.message}
  at ${forcedLocation.functionName ?? `<anonymous>`} (${forcedLocation.fileName}${forcedLocation.lineNumber
                ? `:${forcedLocation.lineNumber}${forcedLocation.columnNumber ? `:${forcedLocation.columnNumber}` : ``}`
                : ``})`;
            try {
                const source = (0, fs_extra_1.readFileSync)(forcedLocation.fileName, `utf8`);
                error.codeFrame = (0, code_frame_1.codeFrameColumns)(source, {
                    start: {
                        line: forcedLocation.lineNumber ?? 0,
                        column: forcedLocation.columnNumber ?? 0,
                    },
                    end: forcedLocation.endColumnNumber
                        ? {
                            line: forcedLocation.endLineNumber ?? 0,
                            column: forcedLocation.endColumnNumber ?? 0,
                        }
                        : undefined,
                }, {
                    highlightCode: true,
                });
            }
            catch (e) {
                // failed to generate codeframe, we still should show an error so we keep going
            }
            return error;
        }
        else {
            return createErrorFromString(errorOrErrorStack.stack, sourceMapFile);
        }
    }
}
//# sourceMappingURL=errors.js.map