"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reporter = void 0;
const common_tags_1 = require("common-tags");
const chalk_1 = __importDefault(require("chalk"));
// import { trackError } from "gatsby-telemetry"
const opentracing_1 = require("opentracing");
const reduxReporterActions = __importStar(require("./redux/actions"));
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const construct_error_1 = __importDefault(require("../structured-errors/construct-error"));
const catch_exit_signals_1 = require("./catch-exit-signals");
const reporter_timer_1 = require("./reporter-timer");
const reporter_phantom_1 = require("./reporter-phantom");
const reporter_progress_1 = require("./reporter-progress");
const diagnostics_1 = require("./redux/diagnostics");
const core_utils_1 = require("../core-utils");
const errorFormatter = (0, errors_1.getErrorFormatter)();
const tracer = (0, opentracing_1.globalTracer)();
let reporterActions = reduxReporterActions;
let isVerbose = (0, core_utils_1.isTruthy)(process.env.GATSBY_REPORTER_ISVERBOSE);
function isLogIntentMessage(msg) {
    return msg && msg.type === `LOG_INTENT`;
}
/**
 * Reporter module.
 * @module reporter
 */
class Reporter {
    /**
     * Strip initial indentation template function.
     */
    stripIndent = common_tags_1.stripIndent;
    format = chalk_1.default;
    errorMap = {};
    /**
     * Set a custom error map to the reporter. This allows
     * the reporter to extend the internal error map
     *
     * Please note: The entered IDs ideally should be different from the ones we internally use:
     * https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-cli/src/structured-errors/error-map.ts
     */
    setErrorMap = (entry) => {
        this.errorMap = {
            ...this.errorMap,
            ...entry,
        };
    };
    /**
     * Toggle verbosity.
     */
    setVerbose = (_isVerbose = true) => {
        isVerbose = _isVerbose;
        process.env.GATSBY_REPORTER_ISVERBOSE = isVerbose ? `1` : `0`;
    };
    /**
     * Turn off colors in error output.
     */
    setNoColor = (isNoColor = false) => {
        if (isNoColor) {
            errorFormatter.withoutColors();
        }
        // disables colors in popular terminal output coloring packages
        //  - chalk: see https://www.npmjs.com/package/chalk#chalksupportscolor
        //  - ansi-colors: see https://github.com/doowb/ansi-colors/blob/8024126c7115a0efb25a9a0e87bc5e29fd66831f/index.js#L5-L7
        if (isNoColor) {
            process.env.FORCE_COLOR = `0`;
            // chalk determines color level at import time. Before we reach this point,
            // chalk was already imported, so we need to retroactively adjust level
            chalk_1.default.level = 0;
        }
    };
    /**
     * Log arguments and exit process with status 1.
     */
    panic = (errorMeta, error, pluginName) => {
        // const reporterError =
        this.error(errorMeta, error, pluginName);
        // trackError(`GENERAL_PANIC`, { error: reporterError })
        (0, catch_exit_signals_1.prematureEnd)();
        return process.exit(1);
    };
    panicOnBuild = (errorMeta, error, pluginName) => {
        const reporterError = this.error(errorMeta, error, pluginName);
        // trackError(`BUILD_PANIC`, { error: reporterError })
        if (process.env.gatsby_executing_command === `build`) {
            (0, catch_exit_signals_1.prematureEnd)();
            process.exit(1);
        }
        return reporterError;
    };
    error = (errorMeta, error, pluginName) => {
        let details = {
            context: {},
        };
        // Many paths to retain backcompat :scream:
        // 1.
        //   reporter.error(any, Error);
        //   reporter.error(any, [Error]);
        if (error) {
            if (Array.isArray(error)) {
                return error.map((errorItem) => this.error(errorMeta, errorItem));
            }
            details.error = error;
            details.context = {
                sourceMessage: errorMeta + ` ` + error.message,
            };
            // 2.
            //    reporter.error(Error);
        }
        else if (errorMeta instanceof Error) {
            details.error = errorMeta;
            details.context = {
                sourceMessage: errorMeta.message,
            };
            // 3.
            //    reporter.error([Error]);
        }
        else if (Array.isArray(errorMeta)) {
            // when we get an array of messages, call this function once for each error
            return errorMeta.map((errorItem) => this.error(errorItem));
            // 4.
            //    reporter.error(errorMeta);
        }
        else if (typeof errorMeta === `object`) {
            details = { ...errorMeta };
            // 5.
            //    reporter.error('foo');
        }
        else if (typeof errorMeta === `string`) {
            details.context = {
                sourceMessage: errorMeta,
            };
        }
        if (pluginName) {
            details.pluginName = pluginName;
            const id = details?.id;
            if (id) {
                const isPrefixed = id.includes(`${pluginName}_`);
                if (!isPrefixed) {
                    details.id = `${pluginName}_${id}`;
                }
            }
        }
        const structuredError = (0, construct_error_1.default)({ details }, this.errorMap);
        if (structuredError) {
            reporterActions.createLog(structuredError);
            // trackError(`GENERIC_ERROR`, { error: structuredError })
        }
        // TODO: remove this once Error component can render this info
        // log formatted stacktrace
        if (structuredError.error) {
            this.log(errorFormatter.render(structuredError.error));
        }
        return structuredError;
    };
    /**
     * Set prefix on uptime.
     */
    uptime = (prefix) => {
        this.verbose(`${prefix}: ${(process.uptime() * 1000).toFixed(3)}ms`);
    };
    verbose = (text) => {
        if (isVerbose) {
            reporterActions.createLog({
                level: constants_1.LogLevels.Debug,
                text,
            });
        }
    };
    success = (text) => reporterActions.createLog({ level: constants_1.LogLevels.Success, text });
    info = (text) => 
    // if (isVerbose) {
    reporterActions.createLog({ level: constants_1.LogLevels.Info, text });
    // }
    warn = (text) => reporterActions.createLog({ level: constants_1.LogLevels.Warning, text });
    log = (text) => reporterActions.createLog({ level: constants_1.LogLevels.Log, text });
    pendingActivity = reporterActions.createPendingActivity;
    completeActivity = (id, status = constants_1.ActivityStatuses.Success) => {
        reporterActions.endActivity({ id, status });
    };
    /**
     * Time an activity.
     */
    activityTimer = (text, activityArgs = {}, pluginName) => {
        let { parentSpan, id, tags } = activityArgs;
        const spanArgs = parentSpan ? { childOf: parentSpan, tags } : { tags };
        if (!id) {
            id = text;
        }
        const span = tracer.startSpan(text, spanArgs);
        return (0, reporter_timer_1.createTimerReporter)({
            text,
            id,
            span,
            reporter: this,
            reporterActions,
            pluginName,
        });
    };
    /**
     * Create an Activity that is not visible to the user
     *
     * During the lifecycle of the Gatsby process, sometimes we need to do some
     * async work and wait for it to complete. A typical example of this is a job.
     * This work should set the status of the process to `in progress` while running and
     * `complete` (or `failure`) when complete. Activities do just this! However, they
     * are visible to the user. So this function can be used to create a _hidden_ activity
     * that while not displayed in the CLI, still triggers a change in process status.
     */
    phantomActivity = (text, activityArgs = {}) => {
        let { parentSpan, id, tags } = activityArgs;
        const spanArgs = parentSpan ? { childOf: parentSpan, tags } : { tags };
        if (!id) {
            id = text;
        }
        const span = tracer.startSpan(text, spanArgs);
        return (0, reporter_phantom_1.createPhantomReporter)({ id, text, span, reporterActions });
    };
    /**
     * Create a progress bar for an activity
     */
    createProgress = (text, total = 0, start = 0, activityArgs = {}, pluginName) => {
        let { parentSpan, id, tags } = activityArgs;
        const spanArgs = parentSpan ? { childOf: parentSpan, tags } : { tags };
        if (!id) {
            id = text;
        }
        const span = tracer.startSpan(text, spanArgs);
        return (0, reporter_progress_1.createProgressReporter)({
            id,
            text,
            total,
            start,
            span,
            reporter: this,
            reporterActions,
            pluginName,
        });
    };
    // This method is called by core when initializing worker process, so it can communicate with main process
    // and dispatch structured logs created by workers to parent process.
    _initReporterMessagingInWorker(sendMessage) {
        const intentifiedActionCreators = {};
        for (const actionCreatorName of Object.keys(reduxReporterActions)) {
            // swap each reporter action creator with function that send intent
            // to main process
            intentifiedActionCreators[actionCreatorName] = (...args) => {
                sendMessage({
                    type: `LOG_INTENT`,
                    payload: {
                        name: actionCreatorName,
                        args,
                    },
                });
            };
        }
        reporterActions = intentifiedActionCreators;
    }
    // This method is called by core when initializing worker pool, so main process can receive
    // messages from workers and dispatch structured logs created by workers to parent process.
    _initReporterMessagingInMain(onMessage) {
        onMessage((msg) => {
            if (isLogIntentMessage(msg)) {
                reduxReporterActions[msg.payload.name].call(reduxReporterActions, 
                // @ts-ignore Next line (`...msg.payload.args`) cause "A spread argument
                // must either have a tuple type or be passed to a rest parameter"
                ...msg.payload.args);
            }
        });
    }
    _registerAdditionalDiagnosticOutputHandler(handler) {
        (0, diagnostics_1.registerAdditionalDiagnosticOutputHandler)(handler);
    }
}
exports.reporter = new Reporter();
//# sourceMappingURL=reporter.js.map