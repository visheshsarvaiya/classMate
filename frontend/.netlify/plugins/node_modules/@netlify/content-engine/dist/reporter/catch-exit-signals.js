"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.catchExitSignals = exports.prematureEnd = void 0;
/*
 * This module is used to catch if the user kills the gatsby process via cmd+c
 * When this happens, there is some clean up logic we need to fire offf
 */
const signal_exit_1 = __importDefault(require("signal-exit"));
const redux_1 = require("./redux");
const actions_1 = require("./redux/actions");
const constants_1 = require("./constants");
const reporter_1 = require("./reporter");
const interruptActivities = () => {
    const { activities } = (0, redux_1.getStore)().getState().logs;
    Object.keys(activities).forEach((activityId) => {
        const activity = activities[activityId];
        if (activity.status === constants_1.ActivityStatuses.InProgress ||
            activity.status === constants_1.ActivityStatuses.NotStarted) {
            reporter_1.reporter.completeActivity(activityId, constants_1.ActivityStatuses.Interrupted);
        }
    });
};
const prematureEnd = () => {
    // hack so at least one activity is surely failed, so
    // we are guaranteed to generate FAILED status
    // if none of activity did explicitly fail
    (0, actions_1.createPendingActivity)({
        id: `panic`,
        status: constants_1.ActivityStatuses.Failed,
    });
    interruptActivities();
};
exports.prematureEnd = prematureEnd;
const catchExitSignals = () => {
    (0, signal_exit_1.default)((code, signal) => {
        if (code !== 0 && signal !== `SIGINT` && signal !== `SIGTERM`)
            (0, exports.prematureEnd)();
        else
            interruptActivities();
    });
};
exports.catchExitSignals = catchExitSignals;
//# sourceMappingURL=catch-exit-signals.js.map