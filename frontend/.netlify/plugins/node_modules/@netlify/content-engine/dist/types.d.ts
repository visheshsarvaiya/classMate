import { EventEmitter } from "events";
import { Reporter } from "./reporter";
import { Span } from "opentracing";
export { Reporter };
import { EnumTypeComposerAsObjectDefinition as ComposeEnumTypeConfig, InputTypeComposerAsObjectDefinition as ComposeInputObjectTypeConfig, InterfaceTypeComposerAsObjectDefinition as ComposeInterfaceTypeConfig, ObjectTypeComposerAsObjectDefinition as ComposeObjectTypeConfig, ScalarTypeComposerAsObjectDefinition as ComposeScalarTypeConfig, UnionTypeComposerAsObjectDefinition as ComposeUnionTypeConfig } from "graphql-compose";
import { GraphQLOutputType } from "graphql";
import { PluginOptionsSchemaJoi, ObjectSchema } from "./plugin-utils";
export interface IMatch {
    id: string;
    context: {
        sourceMessage: string;
        [key: string]: unknown;
    };
    error?: Error | undefined;
    [key: string]: unknown;
}
export type AvailableFeatures = "image-cdn" | "graphql-typegen" | "content-file-path" | "stateful-source-nodes";
interface Proxy {
    prefix: string;
    url: string;
}
/**
 * Gatsby configuration API.
 *
 * @see https://www.gatsbyjs.com/docs/reference/config-files/gatsby-config/
 */
export interface GatsbyConfig {
    /** When you want to reuse common pieces of data across the site (for example, your site title), you can store that here. */
    siteMetadata?: Record<string, unknown>;
    /** Plugins are Node.js packages that implement Gatsby APIs. The config file accepts an array of plugins. Some plugins may need only to be listed by name, while others may take options. */
    plugins?: Array<PluginRef>;
    /** You can activate and deactivate current experiments here. These are experimental features that are currently under development and need testing. When opting in to an experiment you'll receive a console message with more information of what it does and a link to an umbrella discussion. */
    /**
     * Setting the proxy config option will tell the develop server to proxy any unknown requests to your specified server.
     * @see https://www.gatsbyjs.com/docs/api-proxy/
     * */
    proxy?: Proxy | Array<Proxy>;
    /** Sometimes you need more granular/flexible access to the development server. Gatsby exposes the Express.js development server to your site’s engine-config.js where you can add Express middleware as needed. */
    developMiddleware?(app: any): void;
}
/**
 * Gatsby API for Node.js.
 *
 * @see https://www.gatsbyjs.com/docs/node-apis/
 */
export interface GatsbyNode<TNode extends Record<string, unknown> = Record<string, unknown>> {
    /**
     * Run when gatsby develop server is started, its useful to add proxy and middleware
     * to the dev server app
     * @param {object} $0
     * @param {Express} $0.app The [Express app](https://expressjs.com/en/4x/api.html#app) used to run the dev server
     *
     * @example
     *
     * exports.onCreateDevServer = ({ app }) => {
     *   app.get('/hello', function (req, res) {
     *     res.send('hello world')
     *   })
     * }
     */
    onCreateDevServer(args: CreateDevServerArgs, options: PluginOptions): void | Promise<void>;
    /**
     * Called when a new node is created. Plugins wishing to extend or
     * transform nodes created by other plugins should implement this API.
     *
     * See also the documentation for `createNode`
     * and [`createNodeField`](https://www.gatsbyjs.com/docs/reference/config-files/actions/#createNodeField)
     * @param {object} $0
     * @param {object} $0.node A node object.
     * @param {object} $0.actions
     * @param {function} $0.actions.createNode Create a new node.
     * @param {function} $0.actions.createNodeField Extend another node. The new node field is placed under the fields key on the extended node object.
     * @example
     * exports.onCreateNode = ({ node, getNode, actions }) => {
     *   const { createNodeField } = actions
     *
     *   if (node.internal.type === `MarkdownRemark`) {
     *     const nodePath = node.fileAbsolutePath
     *
     *     if (nodePath.match(/\/blog\//)) {
     *       const postSlug = createFilePath({
     *         node,
     *         getNode,
     *         basePath: `src/content`,
     *         trailingSlash: true,
     *       })
     *
     *       createNodeField({
     *         node,
     *         name: `slug`,
     *         value: `/blog/${postSlug}/`,
     *       })
     *     }
     *   }
     * }
     */
    onCreateNode(args: CreateNodeArgs<TNode>, options: PluginOptions, callback: PluginCallback<void>): void;
    /**
     * Called before scheduling a `onCreateNode` callback for a plugin. If it returns falsy
     * then Gatsby will not schedule the `onCreateNode` callback for this node for this plugin.
     * Note: this API does not receive the regular `api` that other callbacks get as first arg.
     *
     * @gatsbyVersion 2.24.80
     * @example
     * exports.shouldOnCreateNode = ({node}, pluginOptions) => node.internal.type === 'Image'
     */
    shouldOnCreateNode(args: {
        node: TNode;
    }, options: PluginOptions): boolean;
    /**
     * Lifecycle executed in each process (one time per process). Used to store actions, etc. for later use. Plugins should use this over other APIs like "onPreBootstrap" or "onPreInit" since onPluginInit will run in main process + all workers to support Parallel Query Running.
     * @gatsbyVersion 3.9.0
     * @example
     * let createJobV2
     * exports.onPluginInit = ({ actions }) => {
     *   // Store job creation action to use it later
     *   createJobV2 = actions.createJobV2
     * }
     */
    onPluginInit(args: ParentSpanPluginArgs, options: PluginOptions, callback: PluginCallback<void>): void;
    /** The first API called during Gatsby execution, runs as soon as plugins are loaded, before cache initialization and bootstrap preparation. If you indend to use this API in a plugin, use "onPluginInit" instead. */
    onPreInit(args: PreInitArgs, options: PluginOptions, callback: PluginCallback<void>): void;
    /**
     * Called during the creation of the GraphQL schema. Allows plugins
     * to add new fields to the types created from data nodes. It will be called
     * separately for each type.
     *
     * This function should return an object in the shape of
     * [GraphQLFieldConfigMap](https://graphql.org/graphql-js/type/#graphqlobjecttype)
     * which will be appended to fields inferred by Gatsby from data nodes.
     *
     * *Note:* Import GraphQL types from `gatsby/graphql` and don't add the `graphql`
     * package to your project/plugin dependencies to avoid Schema must
     * contain unique named types but contains multiple types named errors.
     * `gatsby/graphql` exports all builtin GraphQL types as well as the `graphQLJSON`
     * type.
     *
     * Many transformer plugins use this to add fields that take arguments.
     *
     * @see https://www.gatsbyjs.com/docs/node-apis/#setFieldsOnGraphQLNodeType
     */
    setFieldsOnGraphQLNodeType(args: SetFieldsOnGraphQLNodeTypeArgs, options: PluginOptions, callback: PluginCallback<any>): void;
    /**
     * Extension point to tell plugins to source nodes. This API is called during
     * the Gatsby bootstrap sequence. Source plugins use this hook to create nodes.
     * This API is called exactly once per plugin (and once for your site's
     * `gatsby-config.js` file). If you define this hook in `gatsby-node.js` it
     * will be called exactly once after all of your source plugins have finished
     * creating nodes.
     *
     * @see https://www.gatsbyjs.com/docs/node-apis/#sourceNodes
     */
    sourceNodes(args: SourceNodesArgs, options: PluginOptions): void;
    /**
     * Add custom field resolvers to the GraphQL schema.
     *
     * Allows adding new fields to types by providing field configs, or adding resolver
     * functions to existing fields.
     *
     * Things to note:
     * * Overriding field types is disallowed, instead use the `createTypes`
     *   action. In case of types added from third-party schemas, where this is not
     *   possible, overriding field types is allowed.
     * * New fields will not be available on `filter` and `sort` input types. Extend
     *   types defined with `createTypes` if you need this.
     * * In field configs, types can be referenced as strings.
     * * When extending a field with an existing field resolver, the original
     *   resolver function is available from `info.originalResolver`.
     * * The `createResolvers` API is called as the last step in schema generation.
     *   Thus, an intermediate schema is made available on the `schema` property.
     *   In resolver functions themselves, it is recommended to access the final
     *   built schema from `info.schema`.
     * * Gatsby's data layer, including all internal query capabilities, is
     *   exposed on [`context.nodeModel`](/docs/node-model/). The node store can be
     *   queried directly with `findOne`, `getNodeById` and `getNodesByIds`,
     *   while more advanced queries can be composed with `findAll`.
     * * It is possible to add fields to the root `Query` type.
     * * When using the first resolver argument (`source` in the example below,
     *   often also called `parent` or `root`), take care of the fact that field
     *   resolvers can be called more than once in a query, e.g. when the field is
     *   present both in the input filter and in the selection set. This means that
     *   foreign-key fields on `source` can be either resolved or not-resolved.
     *
     * For fuller examples, see [`using-type-definitions`](https://github.com/gatsbyjs/gatsby/tree/master/examples/using-type-definitions).
     *
     * @see https://www.gatsbyjs.com/docs/reference/config-files/gatsby-node/#createResolvers
     */
    createResolvers(args: CreateResolversArgs, options: PluginOptions): void;
    /**
     * Customize Gatsby’s GraphQL schema by creating type definitions, field extensions or adding third-party schemas.
     * The createTypes, createFieldExtension and addThirdPartySchema actions are only available in this API.
     *
     * For details on their usage please refer to the actions documentation.
     *
     * This API runs immediately before schema generation. For modifications of the generated schema, e.g.
     * to customize added third-party types, use the createResolvers API.
     * @see https://www.gatsbyjs.com/docs/node-apis/#createSchemaCustomization
     */
    createSchemaCustomization(args: CreateSchemaCustomizationArgs, options: PluginOptions): void;
    /**
     * Add a Joi schema for the possible options of your plugin.
     * Currently experimental and not enabled by default.
     */
    pluginOptionsSchema(args: PluginOptionsSchemaArgs): ObjectSchema;
}
export interface PluginOptions {
    plugins: Array<unknown>;
    [key: string]: unknown;
}
export type PluginCallback<R = any> = (err: Error | null, result?: R) => void;
export interface CreateDevServerArgs extends ParentSpanPluginArgs {
    app: any;
}
export interface CreateNodeArgs<TNode extends Record<string, unknown> = Record<string, unknown>> extends ParentSpanPluginArgs {
    node: Node & TNode;
    traceId: string;
    traceTags: {
        nodeId: string;
        nodeType: string;
    };
}
export interface SetFieldsOnGraphQLNodeTypeArgs extends ParentSpanPluginArgs {
    type: {
        name: string;
        nodes: Array<any>;
    };
    traceId: "initial-setFieldsOnGraphQLNodeType";
}
export interface GatsbyGraphQLObjectType {
    kind: "OBJECT";
    config: ComposeObjectTypeConfig<any, any>;
}
export interface GatsbyGraphQLInputObjectType {
    kind: "INPUT_OBJECT";
    config: ComposeInputObjectTypeConfig;
}
export interface GatsbyGraphQLUnionType {
    kind: "UNION";
    config: ComposeUnionTypeConfig<any, any>;
}
export interface GatsbyGraphQLInterfaceType {
    kind: "INTERFACE";
    config: ComposeInterfaceTypeConfig<any, any>;
}
export interface GatsbyGraphQLEnumType {
    kind: "ENUM";
    config: ComposeEnumTypeConfig;
}
export interface GatsbyGraphQLScalarType {
    kind: "SCALAR";
    config: ComposeScalarTypeConfig<any, any>;
}
export type GatsbyGraphQLType = GatsbyGraphQLObjectType | GatsbyGraphQLInputObjectType | GatsbyGraphQLUnionType | GatsbyGraphQLInterfaceType | GatsbyGraphQLEnumType | GatsbyGraphQLScalarType;
export interface NodePluginSchema {
    buildObjectType(config: ComposeObjectTypeConfig<any, any>): GatsbyGraphQLObjectType;
    buildUnionType(config: ComposeUnionTypeConfig<any, any>): GatsbyGraphQLUnionType;
    buildInterfaceType(config: ComposeInterfaceTypeConfig<any, any>): GatsbyGraphQLInterfaceType;
    buildInputObjectType(config: ComposeInputObjectTypeConfig): GatsbyGraphQLInputObjectType;
    buildEnumType(config: ComposeEnumTypeConfig): GatsbyGraphQLEnumType;
    buildScalarType(config: ComposeScalarTypeConfig<any, any>): GatsbyGraphQLScalarType;
}
export interface PreInitArgs extends ParentSpanPluginArgs {
    actions: Actions;
}
export interface SourceNodesArgs extends ParentSpanPluginArgs {
    traceId: "initial-sourceNodes";
    waitForCascadingActions: boolean;
    webhookBody: any;
}
export interface CreateResolversArgs extends ParentSpanPluginArgs {
    intermediateSchema: Record<string, unknown>;
    createResolvers: (...args: Array<unknown>) => unknown;
    traceId: "initial-createResolvers";
}
export interface CreateSchemaCustomizationArgs extends ParentSpanPluginArgs {
    traceId: "initial-createSchemaCustomization";
}
export interface ParentSpanPluginArgs extends NodePluginArgs {
    parentSpan: Span;
}
export interface NodePluginArgs {
    /**
     * This is the same as `pathPrefix` passed in `gatsby-config.js`.
     * It's an empty string if you don't pass `pathPrefix`.
     * When using assetPrefix, you can use this instead of pathPrefix to recieve the string you set in `gatsby-config.js`.
     * It won't include the `assetPrefix`.
     */
    basePath: string;
    /**
     * Collection of functions used to programmatically modify Gatsby’s internal state.
     */
    actions: Actions;
    /**
     * Get content for a node from the plugin that created it.
     *
     * @example
     * module.exports = async function onCreateNode(
     *   { node, loadNodeContent, actions, createNodeId }
     * ) {
     *   if (node.internal.mediaType === 'text/markdown') {
     *     const { createNode, createParentChildLink } = actions
     *     const textContent = await loadNodeContent(node)
     *     // process textContent and create child nodes
     *   }
     * }
     */
    loadNodeContent(this: void, node: Node): Promise<string>;
    /**
     * Internal redux state used for application state. Do not use, unless you
     * absolutely must. Store is considered a private API and can change with
     * any version.
     */
    store: Store;
    /**
     * Internal event emitter / listener.  Do not use, unless you absolutely
     * must. Emitter is considered a private API and can change with any version.
     */
    emitter: EventEmitter;
    /**
     * Get array of all nodes.
     *
     * @returns Array of nodes.
     * @example
     * const allNodes = getNodes()
     */
    getNodes(this: void): Array<Node>;
    /**
     * Get single node by given ID.
     * Don't use this in graphql resolvers - see
     * `getNodeAndSavePathDependency`
     *
     * @param id id of the node.
     * @returns Single node instance.
     * @example
     * const node = getNode(id)
     */
    getNode(this: void, id: string): Node | undefined;
    /**
     * Get array of nodes of given type.
     * @param type Type of nodes
     * @returns Array of nodes.
     *
     * @example
     * const markdownNodes = getNodesByType(`MarkdownRemark`)
     */
    getNodesByType(this: void, type: string): Array<Node>;
    /**
     * Set of utilities to output information to user
     */
    reporter: Reporter;
    /**
     * Key-value store used to persist results of time/memory/cpu intensive
     * tasks. All functions are async and return promises.
     */
    cache: GatsbyCache;
    /**
     * Get cache instance by name - this should only be used by plugins that accept subplugins.
     * @param id id of the node
     * @returns See [cache](https://www.gatsbyjs.com/docs/reference/config-files/node-api-helpers/#cache) section for reference.
     */
    getCache(this: void, id: string): GatsbyCache;
    /**
     * Utility function useful to generate globally unique and stable node IDs.
     * It will generate different IDs for different plugins if they use same
     * input.
     *
     * @returns UUIDv5 ID string
     * @example
     * const node = {
     *   id: createNodeId(`${backendData.type}${backendData.id}`),
     *   ...restOfNodeData
     * }
     */
    createNodeId(this: void, input: string): string;
    /**
     * Create a stable content digest from a string or object, you can use the
     * result of this function to set the `internal.contentDigest` field
     * on nodes. Gatsby uses the value of this field to invalidate stale data
     * when your content changes.
     * @param input
     * @returns Hash string
     * @example
     * const node = {
     *   ...nodeData,
     *   internal: {
     *     type: `TypeOfNode`,
     *     contentDigest: createContentDigest(nodeData)
     *   }
     * }
     */
    createContentDigest(this: void, input: string | Record<string, unknown>): string;
    /**
     * Set of utilities that allow adding more detailed tracing for plugins.
     * Check
     * [Performance tracing](https://www.gatsbyjs.com/docs/performance-tracing)
     * page for more details.
     */
    tracing: Tracing;
    schema: NodePluginSchema;
    [key: string]: unknown;
}
interface ActionPlugin {
    name: string;
}
interface ActionOptions {
    [key: string]: unknown;
}
export interface BuildArgs extends ParentSpanPluginArgs {
    graphql<TData, TVariables = any>(query: string, variables?: TVariables): Promise<{
        errors?: any;
        data?: TData;
    }>;
}
export interface Actions {
    /** @see https://www.gatsbyjs.com/docs/actions/#deleteNode */
    deleteNode(node: NodeInput, plugin?: ActionPlugin): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#createNode */
    createNode<TNode = Record<string, unknown>>(this: void, node: NodeInput & TNode, plugin?: ActionPlugin, options?: ActionOptions): void | Promise<void>;
    /** @see https://www.gatsbyjs.com/docs/actions/#touchNode */
    touchNode(node: NodeInput, plugin?: ActionPlugin): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#createNodeField */
    createNodeField(this: void, args: {
        node: Node;
        name?: string;
        value: any;
    }, plugin?: ActionPlugin, options?: ActionOptions): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#createParentChildLink */
    createParentChildLink(this: void, args: {
        parent: Node;
        child: NodeInput;
    }, plugin?: ActionPlugin): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#setRequestHeaders */
    setRequestHeaders(this: void, args: {
        domain: string;
        headers: Record<string, string>;
    }, plugin?: ActionPlugin): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#createJob */
    createJob(this: void, job: Record<string, unknown> & {
        id: string;
    }, plugin?: ActionPlugin): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#createJobV2 */
    createJobV2(this: void, job: {
        name: string;
        inputPaths: Array<string>;
        outputDir: string;
        args: Record<string, unknown>;
    }, plugin?: ActionPlugin): Promise<unknown>;
    /** @see https://www.gatsbyjs.com/docs/actions/#addGatsbyImageSourceUrl */
    addGatsbyImageSourceUrl(this: void, sourceUrl: string): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#setJob */
    setJob(this: void, job: Record<string, unknown> & {
        id: string;
    }, plugin?: ActionPlugin): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#endJob */
    endJob(this: void, job: {
        id: string;
    }, plugin?: ActionPlugin): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#setPluginStatus */
    setPluginStatus(this: void, status: Record<string, unknown>, plugin?: ActionPlugin): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#addThirdPartySchema */
    addThirdPartySchema(this: void, args: {
        schema: Record<string, unknown>;
    }, plugin?: ActionPlugin, traceId?: string): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#createTypes */
    createTypes(this: void, types: string | GraphQLOutputType | GatsbyGraphQLType | Array<string | GraphQLOutputType | GatsbyGraphQLType>, plugin?: ActionPlugin, traceId?: string): void;
    /** @see https://www.gatsbyjs.com/docs/actions/#createFieldExtension */
    createFieldExtension(this: void, extension: Record<string, unknown>, plugin?: ActionPlugin, traceId?: string): void;
    printTypeDefinitions(this: void, options: {
        path?: string;
        include?: {
            types?: Array<string>;
            plugins?: Array<string>;
        };
        exclude?: {
            types?: Array<string>;
            plugins?: Array<string>;
        };
        withFieldTypes?: boolean;
    }, plugin?: ActionPlugin, traceId?: string): void;
    /**
     * Marks the source plugin that called this function as stateful. Gatsby will not check for stale nodes for any plugin that calls this.
     */
    enableStatefulSourceNodes(this: void, plugin?: ActionPlugin): void;
}
export interface Store {
    dispatch: (...args: Array<unknown>) => unknown;
    subscribe: (...args: Array<unknown>) => unknown;
    getState: (...args: Array<unknown>) => unknown;
    replaceReducer: (...args: Array<unknown>) => unknown;
}
export interface ActivityTracker {
    start(): () => void;
    end(): () => void;
    span: Record<string, unknown>;
    setStatus(status: string): void;
    panic: (errorMeta: string | Record<string, unknown>, error?: Record<string, unknown>) => never;
    panicOnBuild: (errorMeta: string | Record<string, unknown>, error?: Record<string, unknown>) => void;
}
export type ProgressActivityTracker = Omit<ActivityTracker, "end"> & {
    tick(increment?: number): void;
    done(): void;
    total: number;
};
export interface ActivityArgs {
    parentSpan?: Record<string, unknown>;
    id?: string;
}
/**
 * @deprecated Use `GatsbyCache` instead
 */
export interface Cache {
    name: string;
    store: {
        create: (...args: Array<unknown>) => unknown;
    };
    cache: {
        getAndPassUp: (...args: Array<unknown>) => unknown;
        wrap: (...args: Array<unknown>) => unknown;
        set: (...args: Array<unknown>) => unknown;
        mset: (...args: Array<unknown>) => unknown;
        get: (...args: Array<unknown>) => unknown;
        mget: (...args: Array<unknown>) => unknown;
        del: (...args: Array<unknown>) => unknown;
        reset: (...args: Array<unknown>) => unknown;
    };
}
export interface GatsbyCache {
    name: string;
    directory: string;
    /**
     * Retrieve cached value
     * @param key Cache key
     * @returns Promise resolving to cached value
     * @example
     * const value = await cache.get(`unique-key`)
     */
    get(key: string): Promise<any>;
    /**
     * Cache value
     * @param key Cache key
     * @param value Value to be cached
     * @returns Promise resolving to cached value
     * @example
     * await cache.set(`unique-key`, value)
     */
    set(key: string, value: any): Promise<any>;
    /**
     * Deletes cached value
     * @param {string} key Cache key
     * @returns {Promise<void>} Promise resolving once key is deleted from cache
     * @example
     * await cache.del(`unique-key`)
     */
    del(key: string): Promise<void>;
}
export interface Tracing {
    tracer: Record<string, unknown>;
    parentSpan: Record<string, unknown>;
    startSpan: (...args: Array<unknown>) => unknown;
}
export interface PackageJson {
    name?: string;
    description?: string;
    version?: string;
    main?: string;
    author?: string | {
        name: string;
        email: string;
    };
    license?: string;
    dependencies?: Record<string, string>;
    devDependencies?: Record<string, string>;
    peerDependencies?: Record<string, string>;
    optionalDependencies?: Record<string, string>;
    bundledDependencies?: Array<string>;
    keywords?: Array<string>;
}
export interface WebpackRules {
    js: (...args: Array<unknown>) => unknown;
    mjs: (...args: Array<unknown>) => unknown;
    eslint: (...args: Array<unknown>) => unknown;
    yaml: (...args: Array<unknown>) => unknown;
    fonts: (...args: Array<unknown>) => unknown;
    images: (...args: Array<unknown>) => unknown;
    media: (...args: Array<unknown>) => unknown;
    miscAssets: (...args: Array<unknown>) => unknown;
    css: (...args: Array<unknown>) => unknown;
    cssModules: (...args: Array<unknown>) => unknown;
    postcss: (...args: Array<unknown>) => unknown;
    [key: string]: (...args: Array<unknown>) => unknown;
}
export interface WebpackLoaders {
    json: (...args: Array<unknown>) => unknown;
    yaml: (...args: Array<unknown>) => unknown;
    null: (...args: Array<unknown>) => unknown;
    raw: (...args: Array<unknown>) => unknown;
    style: (...args: Array<unknown>) => unknown;
    miniCssExtract: (...args: Array<unknown>) => unknown;
    css: (...args: Array<unknown>) => unknown;
    postcss: (...args: Array<unknown>) => unknown;
    file: (...args: Array<unknown>) => unknown;
    url: (...args: Array<unknown>) => unknown;
    js: (...args: Array<unknown>) => unknown;
    eslint: (...args: Array<unknown>) => unknown;
    imports: (...args: Array<unknown>) => unknown;
    exports: (...args: Array<unknown>) => unknown;
    [key: string]: (...args: Array<unknown>) => unknown;
}
export interface WebpackPlugins {
    normalModuleReplacement: (...args: Array<unknown>) => unknown;
    contextReplacement: (...args: Array<unknown>) => unknown;
    ignore: (...args: Array<unknown>) => unknown;
    watchIgnore: (...args: Array<unknown>) => unknown;
    banner: (...args: Array<unknown>) => unknown;
    prefetch: (...args: Array<unknown>) => unknown;
    automaticPrefetch: (...args: Array<unknown>) => unknown;
    define: (...args: Array<unknown>) => unknown;
    provide: (...args: Array<unknown>) => unknown;
    hotModuleReplacement: (...args: Array<unknown>) => unknown;
    sourceMapDevTool: (...args: Array<unknown>) => unknown;
    evalSourceMapDevTool: (...args: Array<unknown>) => unknown;
    evalDevToolModule: (...args: Array<unknown>) => unknown;
    cache: (...args: Array<unknown>) => unknown;
    extendedAPI: (...args: Array<unknown>) => unknown;
    externals: (...args: Array<unknown>) => unknown;
    jsonpTemplate: (...args: Array<unknown>) => unknown;
    libraryTemplate: (...args: Array<unknown>) => unknown;
    loaderTarget: (...args: Array<unknown>) => unknown;
    memoryOutputFile: (...args: Array<unknown>) => unknown;
    progress: (...args: Array<unknown>) => unknown;
    setVarMainTemplate: (...args: Array<unknown>) => unknown;
    umdMainTemplate: (...args: Array<unknown>) => unknown;
    noErrors: (...args: Array<unknown>) => unknown;
    noEmitOnErrors: (...args: Array<unknown>) => unknown;
    newWatching: (...args: Array<unknown>) => unknown;
    environment: (...args: Array<unknown>) => unknown;
    dll: (...args: Array<unknown>) => unknown;
    dllReference: (...args: Array<unknown>) => unknown;
    loaderOptions: (...args: Array<unknown>) => unknown;
    namedModules: (...args: Array<unknown>) => unknown;
    namedChunks: (...args: Array<unknown>) => unknown;
    hashedModuleIds: (...args: Array<unknown>) => unknown;
    moduleFilenameH: (...args: Array<unknown>) => unknown;
    aggressiveMerging: (...args: Array<unknown>) => unknown;
    aggressiveSplitting: (...args: Array<unknown>) => unknown;
    splitChunks: (...args: Array<unknown>) => unknown;
    chunkModuleIdRange: (...args: Array<unknown>) => unknown;
    dedupe: (...args: Array<unknown>) => unknown;
    limitChunkCount: (...args: Array<unknown>) => unknown;
    minChunkSize: (...args: Array<unknown>) => unknown;
    occurrenceOrder: (...args: Array<unknown>) => unknown;
    moduleConcatenation: (...args: Array<unknown>) => unknown;
    minifyJs: (...args: Array<unknown>) => unknown;
    minifyCss: (...args: Array<unknown>) => unknown;
    extractText: (...args: Array<unknown>) => unknown;
    moment: (...args: Array<unknown>) => unknown;
    [key: string]: (...args: Array<unknown>) => unknown;
}
export interface NodeInput {
    id: string;
    parent?: string | null;
    children?: Array<string>;
    internal: {
        type: string;
        mediaType?: string;
        content?: string;
        contentDigest: string;
        description?: string;
        contentFilePath?: string;
    };
    [key: string]: unknown;
}
export interface Node extends NodeInput {
    parent: string | null;
    children: Array<string>;
    internal: NodeInput["internal"] & {
        owner: string;
    };
    [key: string]: unknown;
}
export interface IPluginRefObject {
    resolve: string;
    options?: IPluginRefOptions;
    parentDir?: string;
    /** @private Internal key used by create-gatsby during plugin installation. Not necessary to define and can be removed. */
    __key?: string;
}
export type PluginRef = string | IPluginRefObject;
export interface IPluginRefOptions {
    plugins?: Array<PluginRef>;
    path?: string;
    [option: string]: unknown;
}
export interface PluginOptionsSchemaArgs {
    Joi: PluginOptionsSchemaJoi;
}
//# sourceMappingURL=types.d.ts.map