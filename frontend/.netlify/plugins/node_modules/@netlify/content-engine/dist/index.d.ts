import { IGatsbyNode } from "./redux/types";
import { ChildProcess } from "child_process";
import { GatsbyConfig } from "./types";
import { ExecutionResult } from "graphql";
import { IDataStore } from "./datastore/types";
import { LedgerAction } from "./services/replication/ledger-writer";
export * from "./types";
export { setFrameworkHook } from "./framework-hooks/index";
export interface ContentEngineConfiguration {
    directory?: string;
    verbose?: boolean;
    openTracingConfigFile?: string;
    host?: string;
    port?: number | string;
    engineConfig?: GatsbyConfig;
    env?: Record<string, string>;
    frameworkHooks?: string;
    printLogs?: false;
    pluginDirectories?: string[];
    ledger?: {
        api: string;
        type: "READER" | "WRITER";
        resourceId: string;
    };
    runInSubProcess?: boolean;
}
type InitializeOptions = {
    clearCache?: boolean;
    context?: Record<string, unknown>;
} & Pick<ContentEngineConfiguration, "env">;
type SyncOptions = InitializeOptions & {
    runServer?: boolean;
    webhookBody?: {
        [key: string]: any;
    };
    connector?: string;
    buildSchema?: true | boolean;
    ledger?: {
        type: "READER";
        cacheId: string;
        configurationId: string;
        untilBlockId?: string;
        onAction?: (action: LedgerAction) => void;
        headers?: Record<string, string>;
    } | {
        type: "WRITER";
        writeBlockId: string;
        cacheId: string;
        headers?: Record<string, string>;
    };
};
export interface SyncState {
    exitCode?: number;
    exited?: boolean;
    error?: {
        message: string;
        stack: string;
    };
    totalLedgerActions?: number;
    configurationId: string;
    schemaHash?: string;
    schemaHashChanged?: boolean;
    invalidations?: {
        typename: string;
        id: string;
    }[];
}
export interface syncLedgerArgs {
    dataLayerId: string;
    sourcingConfigurationId: string;
    cacheSourceVersionId: string;
    blockVersionId?: string;
    onAction?: (action: Record<string, any>) => void;
}
export interface DataStore extends Pick<IDataStore, "getNode" | "getTypes" | "countNodes" | "runQuery"> {
    getNodes: IDataStore["iterateNodes"];
    getNodesByType: IDataStore["iterateNodesByType"];
}
export interface ContentEngine {
    sync: (options?: SyncOptions) => Promise<SyncState>;
    startGraphQLServer: () => Promise<void>;
    initialize: (options?: InitializeOptions) => Promise<string | undefined>;
    restart: (options?: SyncOptions) => Promise<SyncState>;
    stop: () => Promise<void>;
    config: (config: ContentEngineConfiguration) => Promise<ContentEnginePublicAPI>;
    onStdOut: (callback: (data: string) => void) => void;
    onStdErr: (callback: (data: string) => void) => void;
    onMessage: (callback: (message: any) => void) => void;
    sendMessage: (message: any) => void;
    clearListeners: () => void;
    clearIndexes: () => Promise<void> | void;
    /**
     * Test utils, only available when process.env.NODE_ENV === `test`
     */
    test: {
        query: <TData>(query: string, variables?: Record<string, unknown>, querySettings?: {
            context?: Record<string, any>;
        }) => Promise<ExecutionResult<TData>>;
        getNodes: <NodeFields>() => Promise<Array<IGatsbyNode & NodeFields>>;
        getNode: <NodeFields>(id: string) => Promise<IGatsbyNode & NodeFields>;
        getNodesByType: <NodeFields>(type: string) => Promise<Array<IGatsbyNode & NodeFields>>;
    };
    query: (query: string, variables?: Record<string, unknown>, querySettings?: {
        context?: Record<string, any>;
    }) => Promise<any>;
    store?: DataStore;
    getProcess: () => ChildProcess;
    buildSchema(): Promise<void>;
}
export type ContentEnginePublicAPI = ContentEngine;
export declare const contentEngine: (engineOptions?: ContentEngineConfiguration) => ContentEnginePublicAPI;
export declare function throwOutsideTestEnv<T>(fns: Record<string, any>): T;
//# sourceMappingURL=index.d.ts.map