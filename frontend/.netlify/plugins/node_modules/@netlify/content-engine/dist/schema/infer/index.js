"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addInferredType = exports.addInferredTypes = void 0;
const reporter_1 = __importDefault(require("../../reporter"));
const graphql_compose_1 = require("graphql-compose");
const inference_metadata_1 = require("./inference-metadata");
const build_example_data_1 = require("./build-example-data");
const node_interface_1 = require("../types/node-interface");
const add_inferred_fields_1 = require("./add-inferred-fields");
const datastore_1 = require("../../datastore");
const addInferredTypes = ({ schemaComposer, typeConflictReporter, typeMapping, inferenceMetadata, }) => {
    // XXX(freiksenet): Won't be needed after plugins set typedefs
    // Infer File first so all the links to it would work
    const { typeMap } = inferenceMetadata;
    const typesWithNodes = Object.keys(typeMap).filter((typeName) => (0, inference_metadata_1.hasNodes)(typeMap[typeName]));
    const typeNames = putFileFirst(typesWithNodes);
    const noNodeInterfaceTypes = [];
    const typesToInfer = [];
    typeNames.forEach((typeName) => {
        let typeComposer;
        if (schemaComposer.has(typeName)) {
            typeComposer = schemaComposer.getOTC(typeName);
            const runInfer = typeComposer.hasExtension(`infer`)
                ? typeComposer.getExtension(`infer`)
                : true;
            if (runInfer) {
                if (!typeComposer.hasInterface(`Node`)) {
                    noNodeInterfaceTypes.push(typeName);
                }
                typesToInfer.push(typeComposer);
            }
        }
        else {
            typeComposer = graphql_compose_1.ObjectTypeComposer.create(typeName, schemaComposer);
            (0, node_interface_1.addNodeInterface)({ schemaComposer, typeComposer });
            typeComposer.setExtension(`createdFrom`, `inference`);
            typesToInfer.push(typeComposer);
        }
    });
    if (noNodeInterfaceTypes.length > 0) {
        noNodeInterfaceTypes.forEach((typeName) => {
            reporter_1.default.warn(`Type \`${typeName}\` declared in \`createTypes\` looks like a node, ` +
                `but doesn't implement a \`Node\` interface. It's likely that you should ` +
                `add the \`Node\` interface to your type def:\n\n` +
                `\`type ${typeName} implements Node { ... }\`\n\n` +
                `If you know that you don't want it to be a node (which would mean no ` +
                `root queries to retrieve it), you can explicitly disable inference ` +
                `for it:\n\n` +
                `\`type ${typeName} @dontInfer { ... }\``);
        });
        reporter_1.default.panic(`Building schema failed`);
    }
    return typesToInfer.map((typeComposer) => (0, exports.addInferredType)({
        schemaComposer,
        typeComposer,
        typeConflictReporter,
        typeMapping,
        inferenceMetadata,
    }));
};
exports.addInferredTypes = addInferredTypes;
const addInferredType = ({ schemaComposer, typeComposer, typeConflictReporter, typeMapping, inferenceMetadata = {}, }) => {
    const typeName = typeComposer.getTypeName();
    // TODO: Move this to where the type is created once we can get
    // node type owner information directly from store
    if (typeComposer.getExtension(`createdFrom`) === `inference` &&
        (0, inference_metadata_1.hasNodes)(inferenceMetadata.typeMap[typeName])) {
        let firstNode;
        for (const node of (0, datastore_1.getDataStore)().iterateNodesByType(typeName)) {
            firstNode = node;
            break;
        }
        if (firstNode) {
            typeComposer.setExtension(`plugin`, firstNode.internal.owner);
        }
    }
    const exampleValue = (0, build_example_data_1.getExampleObject)({
        ...inferenceMetadata.typeMap[typeName],
        typeName,
        typeConflictReporter,
    });
    (0, add_inferred_fields_1.addInferredFields)({
        schemaComposer,
        typeComposer,
        exampleValue,
        typeMapping,
    });
    return typeComposer;
};
exports.addInferredType = addInferredType;
const putFileFirst = (typeNames) => {
    const index = typeNames.indexOf(`File`);
    if (index !== -1) {
        return [
            `File`,
            ...typeNames.slice(0, index),
            ...typeNames.slice(index + 1),
        ];
    }
    else {
        return typeNames;
    }
};
//# sourceMappingURL=index.js.map