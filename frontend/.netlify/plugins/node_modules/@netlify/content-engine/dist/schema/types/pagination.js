"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPagination = exports.getGroup = exports.getEdge = exports.getPageInfo = void 0;
const graphql_compose_1 = require("graphql-compose");
// import { getFieldsEnum } from "./sort"
const derived_types_1 = require("./derived-types");
const resolvers_1 = require("../resolvers");
const utils_1 = require("./utils");
const sort_1 = require("./sort");
const getPageInfo = ({ schemaComposer, }) => schemaComposer.getOrCreateOTC(`PageInfo`, (tc) => {
    tc.addFields({
        currentPage: `Int!`,
        hasPreviousPage: `Boolean!`,
        hasNextPage: `Boolean!`,
        itemCount: `Int!`,
        pageCount: `Int!`,
        perPage: `Int`,
        totalCount: `Int!`,
    });
});
exports.getPageInfo = getPageInfo;
const getEdge = ({ schemaComposer, typeComposer, }) => {
    const typeName = `${typeComposer.getTypeName()}Edge`;
    (0, derived_types_1.addDerivedType)({ typeComposer, derivedTypeName: typeName });
    return schemaComposer.getOrCreateOTC(typeName, (tc) => {
        tc.addFields({
            next: typeComposer,
            node: typeComposer.getTypeNonNull(),
            previous: typeComposer,
        });
    });
};
exports.getEdge = getEdge;
const getGroup = ({ schemaComposer, typeComposer, }) => {
    const typeName = `${typeComposer.getTypeName()}GroupConnection`;
    const fields = {
        field: `String!`,
        fieldValue: `String`,
    };
    return createPagination({ schemaComposer, typeComposer, typeName, fields });
};
exports.getGroup = getGroup;
const getPagination = ({ schemaComposer, typeComposer, }) => {
    const typeName = `${typeComposer.getTypeName()}Connection`;
    return createPagination({ schemaComposer, typeComposer, typeName });
};
exports.getPagination = getPagination;
function getFieldSelectorTC({ schemaComposer, typeComposer, }) {
    return (0, utils_1.convertToNestedInputType)({
        schemaComposer,
        typeComposer,
        onEnter: ({ fieldName, typeComposer }) => {
            const sortable = typeComposer instanceof graphql_compose_1.UnionTypeComposer ||
                typeComposer instanceof graphql_compose_1.ScalarTypeComposer
                ? undefined
                : typeComposer.getFieldExtension(fieldName, `sortable`);
            if (sortable === sort_1.SORTABLE_ENUM.NOT_SORTABLE) {
                // stop traversing
                return null;
            }
            else if (sortable === sort_1.SORTABLE_ENUM.DEPRECATED_SORTABLE) {
                // mark this and all nested fields as deprecated
                return {
                    deprecationReason: `Sorting on fields that need arguments to resolve is deprecated.`,
                };
            }
            // continue
            return undefined;
        },
        leafInputComposer: schemaComposer.getOrCreateETC(`FieldSelectorEnum`, (etc) => {
            etc.setFields({
                // GraphQL spec doesn't allow using "true" (or "false" or "null") as enum values
                // so we "SELECT"
                SELECT: { value: `SELECT` },
            });
        }),
        postfix: `FieldSelector`,
    }).getTypeNonNull();
}
function createPagination({ schemaComposer, typeComposer, fields, typeName, }) {
    const fieldTC = getFieldSelectorTC({ schemaComposer, typeComposer });
    const paginationTypeComposer = schemaComposer.getOrCreateOTC(typeName, (tc) => {
        // getGroup() will create a recursive call to pagination,
        // so only add it and other aggregate functions on onCreate.
        // Cast into their own category to avoid Typescript conflicts.
        const aggregationFields = {
            distinct: {
                type: [`String!`],
                args: {
                    field: fieldTC,
                },
                resolve: (0, resolvers_1.createDistinctResolver)(typeComposer.getTypeName()),
            },
            max: {
                type: `Float`,
                args: {
                    field: fieldTC,
                },
                resolve: (0, resolvers_1.createMaxResolver)(typeComposer.getTypeName()),
            },
            min: {
                type: `Float`,
                args: {
                    field: fieldTC,
                },
                resolve: (0, resolvers_1.createMinResolver)(typeComposer.getTypeName()),
            },
            sum: {
                type: `Float`,
                args: {
                    field: fieldTC,
                },
                resolve: (0, resolvers_1.createSumResolver)(typeComposer.getTypeName()),
            },
            group: {
                type: [(0, exports.getGroup)({ schemaComposer, typeComposer }).getTypeNonNull()],
                args: {
                    skip: `Int`,
                    limit: `Int`,
                    field: fieldTC,
                },
                resolve: (0, resolvers_1.createGroupResolver)(typeComposer.getTypeName()),
            },
        };
        tc.addFields({
            totalCount: `Int!`,
            edges: [(0, exports.getEdge)({ schemaComposer, typeComposer }).getTypeNonNull()],
            nodes: [typeComposer.getTypeNonNull()],
            pageInfo: (0, exports.getPageInfo)({ schemaComposer }).getTypeNonNull(),
            ...aggregationFields,
            ...fields,
        });
    });
    paginationTypeComposer.makeFieldNonNull(`edges`);
    paginationTypeComposer.makeFieldNonNull(`nodes`);
    paginationTypeComposer.makeFieldNonNull(`distinct`);
    paginationTypeComposer.makeFieldNonNull(`group`);
    (0, derived_types_1.addDerivedType)({ typeComposer, derivedTypeName: typeName });
    return paginationTypeComposer;
}
//# sourceMappingURL=pagination.js.map