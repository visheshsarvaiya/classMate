"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToNestedInputType = exports.SEARCHABLE_ENUM = void 0;
const graphql_1 = require("graphql");
const derived_types_1 = require("./derived-types");
const graphql_compose_1 = require("graphql-compose");
exports.SEARCHABLE_ENUM = {
    SEARCHABLE: `SEARCHABLE`,
    NOT_SEARCHABLE: `NON_SEARCHABLE`,
    DEPRECATED_SEARCHABLE: `DERPECATED_SEARCHABLE`,
};
const removeEmptyFields = ({ inputTypeComposer }, cache = new Set()) => {
    const convert = (itc) => {
        if (cache.has(itc)) {
            return itc;
        }
        cache.add(itc);
        const fields = itc.getFields();
        const nonEmptyFields = {};
        Object.keys(fields).forEach((fieldName) => {
            const fieldITC = fields[fieldName].type;
            if (fieldITC instanceof graphql_compose_1.InputTypeComposer) {
                const convertedITC = convert(fieldITC);
                if (convertedITC.getFieldNames().length) {
                    nonEmptyFields[fieldName] = convertedITC;
                }
            }
            else {
                nonEmptyFields[fieldName] = fieldITC;
            }
        });
        itc.setFields(nonEmptyFields);
        return itc;
    };
    return convert(inputTypeComposer);
};
const convert = ({ schemaComposer, typeComposer, inputTypeComposer, preCreatedInputComposer, deprecationReason, postfix, onEnter, leafInputComposer, listInputComposer, }) => {
    const inputTypeName = inputTypeComposer
        .getTypeName()
        .replace(/Input$/, postfix);
    (0, derived_types_1.addDerivedType)({ typeComposer, derivedTypeName: inputTypeName });
    let convertedITC;
    if (preCreatedInputComposer) {
        convertedITC = preCreatedInputComposer;
    }
    else if (schemaComposer.has(inputTypeName)) {
        return schemaComposer.getITC(inputTypeName);
    }
    else {
        convertedITC = new graphql_compose_1.InputTypeComposer(new graphql_1.GraphQLInputObjectType({
            name: inputTypeName,
            fields: {},
        }), schemaComposer);
    }
    schemaComposer.add(convertedITC);
    const fieldNames = inputTypeComposer.getFieldNames();
    const convertedFields = {};
    fieldNames.forEach((fieldName) => {
        const maybeContext = onEnter({
            fieldName,
            typeComposer,
        });
        if (maybeContext === null) {
            return;
        }
        const fieldConfig = inputTypeComposer.getFieldConfig(fieldName);
        const type = (0, graphql_1.getNamedType)(fieldConfig.type);
        if (type instanceof graphql_1.GraphQLInputObjectType) {
            // Input type composers has names `FooInput`, get the type associated
            // with it
            const typeComposer = schemaComposer.getAnyTC(type.name.replace(/Input$/, ``));
            const itc = new graphql_compose_1.InputTypeComposer(type, schemaComposer);
            const operatorsInputTC = convert({
                schemaComposer,
                typeComposer,
                inputTypeComposer: itc,
                deprecationReason: maybeContext?.deprecationReason ?? deprecationReason,
                postfix,
                onEnter,
                leafInputComposer,
                listInputComposer,
            });
            // TODO: array of arrays?
            const isListType = (0, graphql_1.getNullableType)(fieldConfig.type) instanceof graphql_1.GraphQLList;
            convertedFields[fieldName] = isListType
                ? typeof listInputComposer === `function`
                    ? listInputComposer({
                        schemaComposer,
                        inputTypeComposer: operatorsInputTC,
                    })
                    : operatorsInputTC
                : operatorsInputTC;
        }
        else {
            // GraphQLScalarType || GraphQLEnumType
            const operatorFields = typeof leafInputComposer === `function`
                ? leafInputComposer({ schemaComposer, type })
                : leafInputComposer;
            if (operatorFields) {
                convertedFields[fieldName] = operatorFields;
            }
        }
        if (convertedFields[fieldName]) {
            convertedFields[fieldName].deprecationReason = deprecationReason;
        }
    });
    convertedITC.addFields(convertedFields);
    return convertedITC;
};
const convertToNestedInputType = ({ schemaComposer, typeComposer, postfix, onEnter, leafInputComposer, listInputComposer, }) => {
    const typeName = typeComposer.getTypeName();
    const preCreatedInputComposer = schemaComposer.getOrCreateITC(`${typeName}${postfix}`);
    const inputTypeComposer = typeComposer.getInputTypeComposer({
        fallbackType: null,
    });
    if (inputTypeComposer?.hasField(`id`) &&
        (0, graphql_1.getNamedType)(inputTypeComposer.getFieldType(`id`)).name === `ID`) {
        inputTypeComposer.extendField(`id`, { type: `String` });
    }
    const filterInputTC = convert({
        schemaComposer,
        typeComposer,
        inputTypeComposer,
        preCreatedInputComposer,
        postfix,
        onEnter,
        leafInputComposer,
        listInputComposer,
    });
    return removeEmptyFields({ inputTypeComposer: filterInputTC });
};
exports.convertToNestedInputType = convertToNestedInputType;
//# sourceMappingURL=utils.js.map