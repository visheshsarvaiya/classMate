import { Node } from "../types";
import { GraphQLOutputType } from "graphql";
import { GatsbyIterable } from "../datastore/common/iterable";
type TypeOrTypeName = string | GraphQLOutputType;
export interface NodeModel {
    getNodeById(input: {
        id: string;
        type?: TypeOrTypeName;
    }): any | null;
    getNodesByIds(input: {
        ids: Array<string>;
        type?: TypeOrTypeName;
    }): Array<any>;
    getTypes(): Array<string>;
    findRootNodeAncestor(obj: any, predicate: () => boolean): Node | null;
    getFieldValue(node: Node, fieldPath: string): Promise<any>;
}
declare class LocalNodeModel {
    constructor({ schema, schemaComposer, createPageDependency, _rootNodeMap, _trackedRootNodes, }: {
        schema: any;
        schemaComposer: any;
        createPageDependency: any;
        _rootNodeMap: any;
        _trackedRootNodes: any;
    });
    createPageDependency(): void;
    /**
     * Replace the cache either with the value passed on (mainly for tests) or
     * an empty new Map.
     *
     * @param {undefined | null | FiltersCache} map
     * This cache caches a set of buckets (Sets) of Nodes based on filter and tracks this for each set of types which are
     * actually queried. If the filter targets `id` directly, only one Node is
     * cached instead of a Set of Nodes. If null, don't create or use a cache.
     */
    replaceFiltersCache(map?: Map<any, any>): void;
    withContext(context: any): ContextualNodeModel;
    /**
     * Get a node from the store by ID and optional type.
     *
     * @param {Object} args
     * @param {string} args.id ID of the requested node
     * @param {(string|GraphQLOutputType)} [args.type] Optional type of the node
     * @param {PageDependencies} [pageDependencies]
     * @returns {(Node|null)}
     * @example
     * // Using only the id
     * getNodeById({ id: `123` })
     * // Using id and type
     * getNodeById({ id: `123`, type: `MyType` })
     * // Providing page dependencies
     * getNodeById({ id: `123` }, { path: `/` })
     */
    getNodeById(args: any, pageDependencies: any): any;
    /**
     * Get nodes from the store by IDs and optional type.
     *
     * @param {Object} args
     * @param {string[]} args.ids IDs of the requested nodes
     * @param {boolean} args.keepObjects wether to return mixed node/non-node objects
     * @param {(string|GraphQLOutputType)} [args.type] Optional type of the nodes
     * @returns {Node[]}
     * @example
     * // Using only the id
     * getNodeByIds({ ids: [`123`, `456`] })
     *
     * // Using id and type
     * getNodeByIds({ ids: [`123`, `456`], type: `MyType` })
     *
     * // Providing page dependencies
     * getNodeByIds({ ids: [`123`, `456`] })
     */
    getNodesByIds(args: any): any;
    _query(args: any): Promise<{
        gqlType: any;
        entries: GatsbyIterable<any>;
        totalCount: () => Promise<0 | 1>;
    } | {
        gqlType: any;
        entries: GatsbyIterable<import("../internal").IGatsbyNode>;
        totalCount: () => Promise<number>;
    }>;
    /**
     * Get all nodes in the store, or all nodes of a specified type (optionally with limit/skip).
     * Returns slice of result as iterable and total count of nodes.
     *
     * You can directly return its `entries` result in your resolver.
     *
     * @param {*} args
     * @param {Object} args.query Query arguments (e.g. `limit` and `skip`)
     * @param {(string|GraphQLOutputType)} args.type Type
     * @param {PageDependencies} [pageDependencies]
     * @return {Promise<Object>} Object containing `{ entries: GatsbyIterable, totalCount: () => Promise<number> }`
     * @example
     * // Get all nodes of a type
     * const { entries, totalCount } = await findAll({ type: `MyType` })
     *
     * // Get all nodes of a type while filtering and sorting
     * const { entries, totalCount } = await findAll({
     *   type: `MyType`,
     *   query: {
     *     sort: { fields: [`date`], order: [`desc`] },
     *     filter: { published: { eq: false } },
     *   },
     * })
     *
     * // The `entries` return value is a `GatsbyIterable` (check its TypeScript definition for more details) and allows you to execute array like methods like filter, map, slice, forEach. Calling these methods is more performant than first turning the iterable into an array and then calling the array methods.
     * const { entries, totalCount } = await findAll({ type: `MyType` })
     *
     * const count = await totalCount()
     * const filteredEntries = entries.filter(entry => entry.published)
     *
     * // However, if a method is not available on the `GatsbyIterable` you can turn it into an array first.
     * const filteredEntries = entries.filter(entry => entry.published)
     * return Array.from(posts).length
     */
    findAll(args: any): Promise<{
        entries: import("../internal").IGatsbyNode[] | undefined;
        totalCount: (() => Promise<number>) | (() => Promise<0 | 1>);
    }>;
    /**
     * Get one node in the store. Only returns the first result. When possible, always use this method instead of fetching all nodes and then filtering them. `findOne` is more performant in that regard.
     *
     * @param {*} args
     * @param {Object} args.query Query arguments (e.g. `filter`). Doesn't support `sort`, `limit`, `skip`.
     * @param {(string|GraphQLOutputType)} args.type Type
     * @param {PageDependencies} [pageDependencies]
     * @returns {Promise<Node>}
     * @example
     * // Get one node of type `MyType` by its title
     * const node = await findOne({
     *   type: `MyType`,
     *   query: { filter: { title: { eq: `My Title` } } },
     * })
     */
    findOne(args: any, pageDependencies?: {}): Promise<any>;
    prepareNodes(type: any, queryFields: any, fieldsToResolve: any): any;
    _doResolvePrepareNodesQueue(type: any): Promise<void>;
    /**
     * Get the names of all node types in the store.
     *
     * @returns {string[]}
     */
    getTypes(): string[];
    /**
     * Finds top most ancestor of node that contains passed Object or Array
     * @param {(Object|Array)} obj Object/Array belonging to Node object or Node object
     * @param {nodePredicate} [predicate] Optional callback to check if ancestor meets defined conditions
     * @returns {Node} Top most ancestor if predicate is not specified
     * or first node that meet predicate conditions if predicate is specified
     */
    findRootNodeAncestor(obj: any, predicate?: null): import("../internal").IGatsbyNode | null;
    /**
     * Given a result, that's either a single node or an array of them, track them
     * using pageDependencies. Defaults to tracking according to current resolver
     * path. Returns the result back.
     *
     * @param {Node | Node[]} result
     * @param {PageDependencies} [pageDependencies]
     * @returns {Node | Node[]}
     */
    trackPageDependencies(result: any): any;
    /**
     * Utility to get a field value from a node, even when that value needs to be materialized first (e.g. nested field that was connected via @link directive)
     * @param {Node} node
     * @param {string} fieldPath
     * @returns {any}
     * @example
     * // Example: Via schema customization the author ID is linked to the Author type
     * const blogPostNode = {
     *   author: 'author-id-1',
     *   // Rest of node fields...
     * }
     *
     * getFieldValue(blogPostNode, 'author.name')
     */
    getFieldValue: (node: any, fieldPath: any) => Promise<any>;
}
declare class ContextualNodeModel {
    constructor(rootNodeModel: any, context: any);
    withContext(context: any): ContextualNodeModel;
    _getFullDependencies(pageDependencies: any): any;
    getNodeById(args: any, pageDependencies: any): any;
    getNodesByIds(args: any, pageDependencies: any): any;
    findOne(args: any, pageDependencies: any): any;
    findAll(args: any, pageDependencies: any): any;
    prepareNodes(...args: any[]): any;
    getTypes(...args: any[]): any;
    findRootNodeAncestor(...args: any[]): any;
    createPageDependency(...args: any[]): any;
    trackPageDependencies(result: any, pageDependencies: any): any;
    getFieldValue: (...args: any[]) => any;
}
export { LocalNodeModel };
//# sourceMappingURL=node-model.d.ts.map