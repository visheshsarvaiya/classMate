"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFilterInput = exports.SEARCHABLE_ENUM = void 0;
const graphql_1 = require("graphql");
const graphql_compose_1 = require("graphql-compose");
const date_1 = require("./date");
const utils_1 = require("./utils");
exports.SEARCHABLE_ENUM = {
    SEARCHABLE: `SEARCHABLE`,
    NOT_SEARCHABLE: `NON_SEARCHABLE`,
    DEPRECATED_SEARCHABLE: `DERPECATED_SEARCHABLE`,
};
const getQueryOperatorListInput = ({ schemaComposer, inputTypeComposer, }) => {
    const typeName = inputTypeComposer
        .getTypeName()
        .replace(/Input/, `ListInput`);
    return schemaComposer.getOrCreateITC(typeName, (itc) => {
        itc.addFields({
            elemMatch: inputTypeComposer,
        });
    });
};
const EQ = `eq`;
const NE = `ne`;
const GT = `gt`;
const GTE = `gte`;
const LT = `lt`;
const LTE = `lte`;
const IN = `in`;
const NIN = `nin`;
const REGEX = `regex`;
const GLOB = `glob`;
const ALLOWED_OPERATORS = {
    Boolean: [EQ, NE, IN, NIN],
    Date: [EQ, NE, GT, GTE, LT, LTE, IN, NIN],
    Float: [EQ, NE, GT, GTE, LT, LTE, IN, NIN],
    ID: [EQ, NE, IN, NIN],
    Int: [EQ, NE, GT, GTE, LT, LTE, IN, NIN],
    JSON: [EQ, NE, IN, NIN, REGEX, GLOB],
    String: [EQ, NE, IN, NIN, REGEX, GLOB],
    Enum: [EQ, NE, IN, NIN],
    CustomScalar: [EQ, NE, IN, NIN],
};
const ARRAY_OPERATORS = [IN, NIN];
const getOperatorFields = (fieldType, operators) => {
    const result = {};
    operators.forEach((op) => {
        if (ARRAY_OPERATORS.includes(op)) {
            result[op] = [fieldType];
        }
        else {
            result[op] = fieldType;
        }
    });
    return result;
};
const isBuiltInScalarType = (type) => (0, graphql_1.isSpecifiedScalarType)(type) || type === date_1.GraphQLDate || type === graphql_compose_1.GraphQLJSON;
const getQueryOperatorInput = ({ schemaComposer, type, }) => {
    let typeName;
    if (type instanceof graphql_1.GraphQLEnumType) {
        typeName = `Enum`;
    }
    else if (isBuiltInScalarType(type)) {
        typeName = type.name;
    }
    else {
        typeName = `CustomScalar`;
    }
    const operators = ALLOWED_OPERATORS[typeName];
    return schemaComposer.getOrCreateITC(type.name + `QueryOperatorInput`, (itc) => itc.addFields(getOperatorFields(type, operators)));
};
const getFilterInput = ({ schemaComposer, typeComposer, }) => (0, utils_1.convertToNestedInputType)({
    schemaComposer,
    typeComposer,
    postfix: `FilterInput`,
    onEnter: ({ fieldName, typeComposer }) => {
        const hasExtensions = !(typeComposer instanceof graphql_compose_1.UnionTypeComposer ||
            typeComposer instanceof graphql_compose_1.ScalarTypeComposer);
        const isRuntime = hasExtensions
            ? typeComposer.getFieldExtension(fieldName, `runtime`)
            : undefined;
        const searchable = hasExtensions
            ? typeComposer.getFieldExtension(fieldName, `searchable`)
            : undefined;
        if (searchable === exports.SEARCHABLE_ENUM.NOT_SEARCHABLE || isRuntime) {
            // stop traversing
            return null;
        }
        else if (searchable === exports.SEARCHABLE_ENUM.DEPRECATED_SEARCHABLE) {
            // mark this and all nested fields as deprecated
            return {
                deprecationReason: `Filtering on fields that need arguments to resolve is deprecated.`,
            };
        }
        // continue
        return undefined;
    },
    leafInputComposer: getQueryOperatorInput,
    // elemMatch operator
    listInputComposer: getQueryOperatorListInput,
});
exports.getFilterInput = getFilterInput;
//# sourceMappingURL=filter.js.map