"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fieldPathNeedToResolve = exports.fieldNeedToResolve = exports.toNodeTypeNames = exports.toTypeNames = void 0;
exports.isObjectOrInterfaceTypeComposer = isObjectOrInterfaceTypeComposer;
exports.getResolvedFields = getResolvedFields;
exports.pathObjectToPathString = pathObjectToPathString;
exports.maybeConvertSortInputObjectToSortPath = maybeConvertSortInputObjectToSortPath;
const graphql_1 = require("graphql");
const graphql_compose_1 = require("graphql-compose");
const lodash_isplainobject_1 = __importDefault(require("lodash.isplainobject"));
const redux_1 = require("../redux");
const toTypeNames = (schema, gqlTypeName) => {
    const gqlType = typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName;
    if (!gqlType || !((0, graphql_1.isObjectType)(gqlType) || (0, graphql_1.isAbstractType)(gqlType))) {
        return [];
    }
    const possibleTypes = (0, graphql_1.isAbstractType)(gqlType)
        ? schema.getPossibleTypes(gqlType)
        : [gqlType];
    return possibleTypes.map((type) => type.name);
};
exports.toTypeNames = toTypeNames;
const toNodeTypeNames = (schema, gqlTypeName) => {
    const gqlType = typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName;
    if (!gqlType || !((0, graphql_1.isObjectType)(gqlType) || (0, graphql_1.isAbstractType)(gqlType))) {
        return [];
    }
    const possibleTypes = (0, graphql_1.isAbstractType)(gqlType)
        ? schema.getPossibleTypes(gqlType)
        : [gqlType];
    return possibleTypes
        .filter((type) => type.getInterfaces().some((iface) => iface.name === `Node`))
        .map((type) => type.name);
};
exports.toNodeTypeNames = toNodeTypeNames;
function isObjectOrInterfaceTypeComposer(type) {
    return (type instanceof graphql_compose_1.ObjectTypeComposer || type instanceof graphql_compose_1.InterfaceTypeComposer);
}
const fieldNeedToResolve = ({ schema, gqlType, typeComposer, schemaComposer, fieldName, }) => {
    const nodeTypeNames = (0, exports.toNodeTypeNames)(schema, gqlType);
    const possibleTCs = [
        typeComposer,
        ...nodeTypeNames
            .map((name) => schemaComposer.getAnyTC(name))
            .filter(isObjectOrInterfaceTypeComposer),
    ];
    for (const tc of possibleTCs) {
        if (tc.getFieldExtension(fieldName, `needsResolve`) || false) {
            return true;
        }
    }
    return false;
};
exports.fieldNeedToResolve = fieldNeedToResolve;
const fieldPathNeedToResolve = ({ selector, type, }) => {
    const { schema, schemaCustomization: { composer: schemaComposer }, } = redux_1.store.getState();
    if (!schemaComposer) {
        throw new Error(`Schema composer isn't set yet`);
    }
    const selectors = typeof selector === `string` ? selector.split(`.`) : selector;
    let gqlType = typeof type === `string` ? schema.getType(type) : type;
    if (!gqlType || !((0, graphql_1.isObjectType)(gqlType) || (0, graphql_1.isInterfaceType)(gqlType))) {
        return false;
    }
    for (let i = 0; i < selectors.length; i++) {
        const fieldName = selectors[i];
        const typeComposer = schemaComposer.getAnyTC(gqlType.name);
        if (!isObjectOrInterfaceTypeComposer(typeComposer)) {
            return false;
        }
        if ((0, exports.fieldNeedToResolve)({
            schema,
            gqlType,
            typeComposer,
            schemaComposer,
            fieldName,
        })) {
            return true;
        }
        const nextType = (0, graphql_1.getNamedType)(gqlType.getFields()[fieldName].type);
        if (!nextType || !((0, graphql_1.isObjectType)(nextType) || (0, graphql_1.isInterfaceType)(nextType))) {
            return false;
        }
        else {
            gqlType = nextType;
        }
    }
    return false;
};
exports.fieldPathNeedToResolve = fieldPathNeedToResolve;
function getResolvedFields(node) {
    const typeName = node.internal.type;
    const resolvedNodes = redux_1.store.getState().resolvedNodesCache.get(typeName);
    return resolvedNodes?.get(node.id);
}
function pathObjectToPathString(input) {
    const path = [];
    let currentValue = input;
    let leaf = undefined;
    while (currentValue) {
        if ((0, lodash_isplainobject_1.default)(currentValue)) {
            const entries = Object.entries(currentValue);
            if (entries.length !== 1) {
                throw new Error(`Invalid field arg`);
            }
            for (const [key, value] of entries) {
                path.push(key);
                currentValue = value;
            }
        }
        else {
            leaf = currentValue;
            currentValue = undefined;
        }
    }
    return {
        path: path.join(`.`),
        leaf,
    };
}
function maybeConvertSortInputObjectToSortPath(args) {
    if (!args.sort) {
        return args;
    }
    // check if it's already in expected format
    if (Array.isArray(args.sort?.fields) &&
        Array.isArray(args.sort?.order) &&
        args.sort.order.every((item) => typeof item === `string` &&
            (item.toLowerCase() === `asc` || item.toLowerCase() === `desc`))) {
        return args;
    }
    let sorts = args.sort;
    if (!Array.isArray(sorts)) {
        sorts = [sorts];
    }
    const modifiedSort = {
        fields: [],
        order: [],
    };
    for (const sort of sorts) {
        const { path, leaf } = pathObjectToPathString(sort);
        modifiedSort.fields.push(path);
        modifiedSort.order.push(leaf);
    }
    return {
        ...args,
        sort: modifiedSort,
    };
    return args;
}
//# sourceMappingURL=utils.js.map