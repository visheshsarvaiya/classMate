"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resizeResolver = resizeResolver;
exports.generateResizeFieldConfig = generateResizeFieldConfig;
const url_generator_1 = require("../utils/url-generator");
const mime_type_helpers_1 = require("../utils/mime-type-helpers");
const strip_indent_1 = require("../utils/strip-indent");
const dispatchers_1 = require("../jobs/dispatchers");
const types_1 = require("../types");
const utils_1 = require("./utils");
const DEFAULT_QUALITY = 75;
const allowedFormats = [
    `jpg`,
    `png`,
    `webp`,
    `avif`,
    `auto`,
];
async function resizeResolver(source, args, actions, store) {
    if (!(0, types_1.isImage)(source)) {
        return null;
    }
    if (!args.format) {
        args.format = `auto`;
    }
    if (!args.quality) {
        args.quality = DEFAULT_QUALITY;
    }
    if (!allowedFormats.includes(args.format)) {
        throw new Error(`Unknown format "${args.format}" was given to resize ${source.url}`);
    }
    if (!args.width && !args.height) {
        throw new Error(`No width or height is given to resize "${source.url}"`);
    }
    const formats = (0, utils_1.validateAndNormalizeFormats)([args.format], (0, mime_type_helpers_1.getImageFormatFromMimeType)(source.mimeType));
    const [format] = formats;
    const { width, height } = (0, utils_1.calculateImageDimensions)(source, args);
    if ((0, dispatchers_1.shouldDispatch)()) {
        (0, dispatchers_1.dispatchLocalImageServiceJob)({
            url: source.url,
            mimeType: source.mimeType,
            filename: source.filename,
            contentDigest: source.internal.contentDigest,
        }, {
            ...args,
            width,
            height,
            format,
        }, actions, store);
    }
    const src = (0, url_generator_1.generateImageUrl)(source, {
        ...args,
        width,
        height,
        format,
    }, store);
    return {
        src,
        width,
        height,
    };
}
function generateResizeFieldConfig(enums, actions, store) {
    return {
        type: `RemoteFileResize`,
        args: {
            width: `Int`,
            height: `Int`,
            aspectRatio: `Float`,
            fit: {
                type: enums.fit.getTypeName(),
                defaultValue: enums.fit.getField(`COVER`).value,
            },
            format: {
                type: enums.format.getTypeName(),
                defaultValue: enums.format.getField(`AUTO`).value,
                description: (0, strip_indent_1.stripIndent) `
      The image formats to generate. Valid values are AUTO (meaning the same format as the source image), JPG, PNG, WEBP and AVIF.
      The default value is [AUTO, WEBP, AVIF], and you should rarely need to change this. Take care if you specify JPG or PNG when you do
      not know the formats of the source images, as this could lead to unwanted results such as converting JPEGs to PNGs. Specifying
      both PNG and JPG is not supported and will be ignored.`,
            },
            cropFocus: {
                type: enums.cropFocus.List.getTypeName(),
            },
            quality: {
                type: `Int`,
                defaultValue: DEFAULT_QUALITY,
            },
        },
        resolve(source, args) {
            return resizeResolver(source, args, actions, store);
        },
    };
}
//# sourceMappingURL=resize-resolver.js.map