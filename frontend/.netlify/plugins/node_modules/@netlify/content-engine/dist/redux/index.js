"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadPartialStateFromDisk = exports.savePartialStateToDisk = exports.saveState = exports.replaceReducer = exports.store = exports.configureStore = exports.readState = exports.emitter = void 0;
const redux_1 = require("redux");
const lodash_pick_1 = __importDefault(require("lodash.pick"));
// import telemetry from "gatsby-telemetry"
const mett_1 = require("../utils/mett");
const redux_thunk_1 = __importDefault(require("redux-thunk"));
const reducers = __importStar(require("./reducers"));
const persist_1 = require("./persist");
const create_require_from_path_1 = require("../core-utils/create-require-from-path");
const gatsbyRedux = (0, create_require_from_path_1.checkIfGatsbyIsOverridden)()
    ? {}
    : (0, create_require_from_path_1.requireFromInstalledGatsbyDist)(`redux/index.js`);
// Create event emitter for actions
exports.emitter = gatsbyRedux?.emitter || (0, mett_1.mett)();
// Read old node data from cache.
exports.readState = gatsbyRedux?.readState ||
    (() => {
        try {
            const state = (0, persist_1.readFromCache)();
            if (state.nodes) {
                // re-create nodesByType
                state.nodesByType = new Map();
                state.nodes.forEach((node) => {
                    const { type } = node.internal;
                    if (!state.nodesByType.has(type)) {
                        state.nodesByType.set(type, new Map());
                    }
                    // The `.has` and `.set` calls above make this safe
                    state.nodesByType.get(type).set(node.id, node);
                });
            }
            // jsonDataPaths was removed in the per-page-manifest
            // changes. Explicitly delete it here to cover case where user
            // runs gatsby the first time after upgrading.
            delete state[`jsonDataPaths`];
            // telemetry.trackCli(`CACHE_STATUS`, {
            //   cacheStatus: `WARM`,
            // })
            return state;
        }
        catch (e) {
            // telemetry.trackCli(`CACHE_STATUS`, {
            //   cacheStatus: `COLD`,
            // })
            return {};
        }
    });
/**
 * Redux middleware handling array of actions
 */
const multi = ({ dispatch }) => (next) => (action) => Array.isArray(action) ? action.filter(Boolean).map(dispatch) : next(action);
exports.configureStore = gatsbyRedux?.configureStore ||
    ((initialState) => (0, redux_1.createStore)((0, redux_1.combineReducers)({ ...reducers }), initialState, (0, redux_1.applyMiddleware)(redux_thunk_1.default, multi)));
exports.store = gatsbyRedux?.store ||
    (0, exports.configureStore)(process.env.GATSBY_WORKER_POOL_WORKER ? {} : (0, exports.readState)());
/**
 * Allows overloading some reducers (e.g. when setting a custom datastore)
 */
exports.replaceReducer = gatsbyRedux?.replaceReducer ||
    ((customReducers) => {
        exports.store.replaceReducer((0, redux_1.combineReducers)({ ...reducers, ...customReducers }));
    });
// Persist state.
exports.saveState = gatsbyRedux?.saveState ||
    (() => {
        const state = exports.store.getState();
        return (0, persist_1.writeToCache)({
            nodes: state.nodes,
            typeOwners: state.typeOwners,
            statefulSourcePlugins: state.statefulSourcePlugins,
            status: state.status,
            jobsV2: state.jobsV2,
            schemaCustomization: {
                types: state.schemaCustomization?.types,
            },
        });
    });
exports.savePartialStateToDisk = gatsbyRedux?.savePartialStateToDisk ||
    ((keys, transformState) => {
        const state = exports.store.getState();
        const contents = (0, lodash_pick_1.default)(state, keys);
        const savedContents = transformState ? transformState(contents) : contents;
        return (0, persist_1.writeToCache)(savedContents);
    });
exports.loadPartialStateFromDisk = gatsbyRedux?.loadPartialStateFromDisk ||
    (() => {
        try {
            return (0, persist_1.readFromCache)();
        }
        catch (e) {
            // ignore errors.
        }
        return {};
    });
// if we're using Gatsby's redux then it will already be emitting the following:
if (!gatsbyRedux?.emitter) {
    exports.store.subscribe(() => {
        const lastAction = exports.store.getState().lastAction;
        exports.emitter.emit(lastAction.type, lastAction);
    });
}
//# sourceMappingURL=index.js.map