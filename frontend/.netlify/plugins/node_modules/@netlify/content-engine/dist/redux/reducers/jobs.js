"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.jobsReducer = void 0;
const lodash_get_1 = __importDefault(require("lodash.get"));
const lodash_merge_1 = __importDefault(require("lodash.merge"));
const common_tags_1 = require("common-tags");
const moment_1 = __importDefault(require("moment"));
const jobsReducer = (state = { active: [], done: [] }, action) => {
    switch (action.type) {
        case `CREATE_JOB`:
        case `SET_JOB`: {
            if (!action.payload.id) {
                throw new Error(`An ID must be provided when creating or setting job`);
            }
            const index = state.active?.findIndex((j) => j.id === action.payload.id);
            if (index !== -1) {
                const mergedJob = (0, lodash_merge_1.default)(state.active[index], {
                    ...action.payload,
                    createdAt: Date.now(),
                    plugin: action.plugin,
                });
                state.active[index] = mergedJob;
                return state;
            }
            else {
                state.active.push({
                    ...action.payload,
                    createdAt: Date.now(),
                    plugin: action.plugin,
                });
                return state;
            }
        }
        case `END_JOB`: {
            if (!action.payload.id) {
                throw new Error(`An ID must be provided when ending a job`);
            }
            const completedAt = Date.now();
            const index = state.active?.findIndex((j) => j.id === action.payload.id);
            if (index === -1) {
                throw new Error((0, common_tags_1.oneLine) `
          The plugin "${(0, lodash_get_1.default)(action, `plugin.name`, `anonymous`)}"
          tried to end a job with the id "${action.payload.id}"
          that either hasn't yet been created or has already been ended`);
            }
            const job = state.active.splice(index, 1)[0];
            state.done.push({
                ...job,
                completedAt,
                runTime: (0, moment_1.default)(completedAt).diff((0, moment_1.default)(job.createdAt)),
            });
            return state;
        }
    }
    return state;
};
exports.jobsReducer = jobsReducer;
//# sourceMappingURL=jobs.js.map