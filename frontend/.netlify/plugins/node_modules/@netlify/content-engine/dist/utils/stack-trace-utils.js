"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNonGatsbyCodeFrameFormatted = exports.getNonGatsbyCodeFrame = void 0;
exports.findOriginalSourcePositionAndContent = findOriginalSourcePositionAndContent;
const stack_trace_1 = __importDefault(require("stack-trace"));
const code_frame_1 = require("@babel/code-frame");
const trace_mapping_1 = require("@jridgewell/trace-mapping");
const fs = require(`fs-extra`);
const path = require(`path`);
const chalk = require(`chalk`);
const { isNodeInternalModulePath } = require(`../core-utils`);
const getDirName = (arg) => {
    // Caveat related to executing in engines:
    // After webpack bundling we would get number here (webpack module id) and that would crash when doing
    // path.dirname(number).
    if (typeof arg === `string`) {
        return path.dirname(arg);
    }
    return `-cant-resolve-`;
};
const contentEngineLocation = getDirName(require.resolve(`../../package.json`));
const reduxThunkLocation = getDirName(require.resolve(`redux-thunk/package.json`));
const reduxLocation = getDirName(require.resolve(`redux/package.json`));
const getNonGatsbyCallSite = () => stack_trace_1.default
    .get()
    .find((callSite) => callSite &&
    callSite.getFileName() &&
    !callSite.getFileName().includes(contentEngineLocation) &&
    !callSite.getFileName().includes(reduxLocation) &&
    !callSite.getFileName().includes(reduxThunkLocation) &&
    !isNodeInternalModulePath(callSite.getFileName()));
const getNonGatsbyCodeFrame = ({ highlightCode = true, stack, } = {}) => {
    let callSite;
    if (stack) {
        callSite = stack_trace_1.default.parse({ stack, name: ``, message: `` })[0];
    }
    else {
        callSite = getNonGatsbyCallSite();
    }
    if (!callSite) {
        return null;
    }
    const fileName = callSite.getFileName();
    const line = callSite.getLineNumber();
    const column = callSite.getColumnNumber();
    const code = fs.readFileSync(fileName, { encoding: `utf-8` });
    return {
        fileName,
        line,
        column,
        codeFrame: (0, code_frame_1.codeFrameColumns)(code, {
            start: {
                line,
                column,
            },
        }, {
            highlightCode,
        }),
    };
};
exports.getNonGatsbyCodeFrame = getNonGatsbyCodeFrame;
const getNonGatsbyCodeFrameFormatted = ({ highlightCode = true, stack, } = {}) => {
    const possibleCodeFrame = (0, exports.getNonGatsbyCodeFrame)({
        highlightCode,
        stack,
    });
    if (!possibleCodeFrame) {
        return null;
    }
    const { fileName, line, column, codeFrame } = possibleCodeFrame;
    return `File ${chalk.bold(`${fileName}:${line}:${column}`)}\n${codeFrame}`;
};
exports.getNonGatsbyCodeFrameFormatted = getNonGatsbyCodeFrameFormatted;
function findOriginalSourcePositionAndContent(webpackSource, position) {
    const tracer = new trace_mapping_1.TraceMap(webpackSource);
    const sourcePosition = (0, trace_mapping_1.originalPositionFor)(tracer, {
        line: position.line,
        column: position.column ?? 0,
    });
    if (!sourcePosition.source) {
        return {
            sourcePosition: null,
            sourceContent: null,
        };
    }
    const sourceContent = (0, trace_mapping_1.sourceContentFor)(tracer, sourcePosition.source);
    return {
        sourcePosition,
        sourceContent,
    };
}
//# sourceMappingURL=stack-trace-utils.js.map