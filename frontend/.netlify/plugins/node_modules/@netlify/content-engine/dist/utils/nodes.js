"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNodeAndSavePathDependency = exports.hasNodeChanged = void 0;
exports.loadNodeContent = loadNodeContent;
const datastore_1 = require("../datastore");
const redux_1 = require("../redux");
/**
 * Determine if node has changed.
 */
const hasNodeChanged = (id, digest) => {
    const node = (0, datastore_1.getNode)(id);
    if (!node) {
        return true;
    }
    else {
        return node.internal.contentDigest !== digest;
    }
};
exports.hasNodeChanged = hasNodeChanged;
/**
 * Get node and save path dependency.
 */
const getNodeAndSavePathDependency = (id) => {
    const node = (0, datastore_1.getNode)(id);
    if (!node) {
        console.error(`getNodeAndSavePathDependency failed for node id: ${id} as it was not found in cache`);
        return undefined;
    }
    return node;
};
exports.getNodeAndSavePathDependency = getNodeAndSavePathDependency;
/**
 * Get content for a node from the plugin that created it.
 */
async function loadNodeContent(node) {
    if (typeof node.internal.content === `string`) {
        return node.internal.content;
    }
    // Load plugin's loader function
    const plugin = redux_1.store
        .getState()
        .flattenedPlugins.find((plug) => plug.name === node.internal.owner);
    if (!plugin) {
        throw new Error(`Could not find owner plugin of node for loadNodeContent with owner \`${node.internal.owner}\``);
    }
    const { loadNodeContent } = require(plugin.resolve);
    if (!loadNodeContent) {
        throw new Error(`Could not find function loadNodeContent for plugin ${plugin.name}`);
    }
    const content = await loadNodeContent(node);
    node.internal.content = content;
    return content;
}
//# sourceMappingURL=nodes.js.map